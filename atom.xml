<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PGzxc的博客</title>
  
  <subtitle>纸上得来终觉浅 绝知此事要躬行</subtitle>
  <link href="http://pgzxc.github.io/atom.xml" rel="self"/>
  
  <link href="http://pgzxc.github.io/"/>
  <updated>2020-08-17T13:59:44.715Z</updated>
  <id>http://pgzxc.github.io/</id>
  
  <author>
    <name>PGzxc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#开发之——将查询结果保存到DataSet或DataTable中(15.8)</title>
    <link href="http://pgzxc.github.io/posts/20df0623.html"/>
    <id>http://pgzxc.github.io/posts/20df0623.html</id>
    <published>2020-08-17T13:58:59.000Z</published>
    <updated>2020-08-17T13:59:44.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在执行对表中数据的查询时还能将数据保存到 DataSet 中，但需要借助 DataAdapter 类来实现。</li><li>在实际应用中，DataAdapter 与 DataSet 是在查询操作中使用最多的类。</li><li>此外，还可以通过 DataSet 实现对表中数据的增加、修改、删除操作 </li></ul><a id="more"></a><h2 id="二-DataAdapter-与-DataSet-类简介"><a href="#二-DataAdapter-与-DataSet-类简介" class="headerlink" title="二 DataAdapter 与 DataSet 类简介"></a>二 DataAdapter 与 DataSet 类简介</h2><p> DataAdapter 类用于将数据表中的数据查询出来并添加到 DataSet 中，DataAdapter 在 System.Data.SqlClient 命名空间下对应的类名是 SqlDataAdapter </p><h3 id="2-1-SqlDataAdapter-类的主要构造方法"><a href="#2-1-SqlDataAdapter-类的主要构造方法" class="headerlink" title="2.1  SqlDataAdapter 类的主要构造方法"></a>2.1  SqlDataAdapter 类的主要构造方法</h3><table><thead><tr><th align="center"><strong>构造方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">SqlDataAdapter(SqlCommand cmd)</td><td align="center">带参数的构造方法，传递 SqlCommand 类的对象作为参数</td></tr><tr><td align="center">SqlDataAdapter(string sql, SqlConnection conn)</td><td align="center">带参数的构造方法，sql 参数是指定对数据表执行的 SQL 语句，conn 是数据库的连接对象</td></tr><tr><td align="center">SqlDataAdapter()</td><td align="center">不带参数的构造方法</td></tr></tbody></table><p> 从 SqlDataAdapter 类的构造方法可以看出，SqlDataAdapter 类需要与 SqlCommand 类和 SqlConnection 类一起使用 </p><h3 id="2-2-SqlDataAdapter-类常用的属性和方法"><a href="#2-2-SqlDataAdapter-类常用的属性和方法" class="headerlink" title="2.2  SqlDataAdapter 类常用的属性和方法"></a>2.2  SqlDataAdapter 类常用的属性和方法</h3><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">SelectCommand</td><td align="center">属性，设置 SqlDataAdapter 中要执行的查询语句</td></tr><tr><td align="center">InsertCommand</td><td align="center">属性，设置 SqlDataAdapter 中要执行的添加语句</td></tr><tr><td align="center">UpdateCommand</td><td align="center">属性，设置 SqlDataAdapter 中要执行的修改语句</td></tr><tr><td align="center">DeleteCommand</td><td align="center">属性，设置 SqlDataAdapter 中要执行的删除语句</td></tr><tr><td align="center">Fill(DataSet ds)</td><td align="center">方法，将 SqlDataAdapter 类中查询出的结果填充到 DataSet 对象中</td></tr><tr><td align="center">Fill(DataTable dt)</td><td align="center">方法，将 SqlDataAdapter 类中查询出的结果填充到 DataTable 对象 中，DataTable是数据表对象，在一个DataSet对象中由多个 DataTable对象构成</td></tr><tr><td align="center">Update(DataSet ds)</td><td align="center">方法，更新 DataSet 对象中的数据</td></tr><tr><td align="center">Update(DataTable dt)</td><td align="center">方法，更新 DataTable 对象中的数据</td></tr></tbody></table><p> DataSet 类是一种与数据库结构类似的数据集，每个 DataSet 都是由若干个数据表构成的，DataTable 即数据表，每个 DataTable 也都是由行和列构成的，行使用 DataRow 类表示、列使用 DataColumn 类表示。 </p><p> 此外，用户还可以通过 DataRelation 类设置数据表之间的关系 </p><h2 id="三-DataSet-类以及-DataTable-类"><a href="#三-DataSet-类以及-DataTable-类" class="headerlink" title="三  DataSet 类以及 DataTable 类"></a>三  DataSet 类以及 DataTable 类</h2><h3 id="3-1-DataSet-类"><a href="#3-1-DataSet-类" class="headerlink" title="3.1  DataSet 类"></a>3.1  DataSet 类</h3><h4 id="3-1-1-DataSet-类中的构造方法"><a href="#3-1-1-DataSet-类中的构造方法" class="headerlink" title="3.1.1  DataSet 类中的构造方法"></a>3.1.1  DataSet 类中的构造方法</h4><table><thead><tr><th align="center"><strong>构造方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">DataSet()</td><td align="center">无参构造方法</td></tr><tr><td align="center">DataSet(string DataSetName)</td><td align="center">带参数的构造方法，DataSetName 参数用于指定数据集名称</td></tr></tbody></table><h4 id="3-1-2-DataSet-类中常用的属性和方法"><a href="#3-1-2-DataSet-类中常用的属性和方法" class="headerlink" title="3.1.2  DataSet 类中常用的属性和方法"></a>3.1.2  DataSet 类中常用的属性和方法</h4><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">Tables</td><td align="center">属性，获取 DataSet 中所有数据表的集合，Tables[0] 代表集合中的第一个数据表</td></tr><tr><td align="center">CaseSensitive</td><td align="center">属性，获取或设置 DataSet 中的字符串是否区分大小写</td></tr><tr><td align="center">Relations</td><td align="center">属性，获取 DataSet 中包含的关系集合</td></tr><tr><td align="center">Clear()</td><td align="center">方法，清空 DataSet 中的数据</td></tr><tr><td align="center">Copy()</td><td align="center">方法，复制 DataSet 中的数据</td></tr><tr><td align="center">AcceptChanges()</td><td align="center">方法，更新 DataSet 中的数据</td></tr><tr><td align="center">HasChanges()</td><td align="center">方法，获取 DataSet 中是否有数据发生变化</td></tr><tr><td align="center">RejectChanges()</td><td align="center">方法，撤销对 DataSet 中数据的更改</td></tr></tbody></table><h3 id="3-2-DataTable"><a href="#3-2-DataTable" class="headerlink" title="3.2 DataTable"></a>3.2 DataTable</h3><p> DataTable 作为 DataSet 中的重要对象，其与数据表的定义是类似的，都是由行和列构成，并有唯一的表名 </p><p> 从 SqlDataAdapter 类的填充方法 (Fill) 中可以看出允许将数据直接填充到 DataTable 中，这样既能节省存储空间也能简化查找数据表中的数据。</p><h4 id="3-2-1-DataTable-中常用的构造方法"><a href="#3-2-1-DataTable-中常用的构造方法" class="headerlink" title="3.2.1  DataTable 中常用的构造方法"></a>3.2.1  DataTable 中常用的构造方法</h4><table><thead><tr><th align="center"><strong>构造方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">DataTable()</td><td align="center">无参构造方法</td></tr><tr><td align="center">DataTable(string TableName)</td><td align="center">带参数的构造方法， TableName 参数用于指定数据表的名称</td></tr></tbody></table><h4 id="3-2-2-DataTable-与-DataSet-有很多相似的属性和方法"><a href="#3-2-2-DataTable-与-DataSet-有很多相似的属性和方法" class="headerlink" title="3.2.2  DataTable 与 DataSet 有很多相似的属性和方法"></a>3.2.2  DataTable 与 DataSet 有很多相似的属性和方法</h4><table><thead><tr><th align="center"><strong>属性</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">TableName</td><td align="center">属性，获取或设置 DataTable 的名称</td></tr><tr><td align="center">Columns</td><td align="center">属性，获取 DataTable 中列的集合</td></tr><tr><td align="center">Rows</td><td align="center">属性，获取 DataTable 中行的集合</td></tr><tr><td align="center">DataSet</td><td align="center">属性，获取 DataTable 所在的 DataSet</td></tr><tr><td align="center">Constraints</td><td align="center">属性，获取 DataTable 中的所有约束</td></tr></tbody></table><h3 id="3-3-使用-DataSet-和-DataTable-类存放查询结果"><a href="#3-3-使用-DataSet-和-DataTable-类存放查询结果" class="headerlink" title="3.3 使用 DataSet 和 DataTable 类存放查询结果"></a>3.3 使用 DataSet 和 DataTable 类存放查询结果</h3><p> 在实际应用中，将查询结果存储到 DataSet 类或 DataTable 类中均可，在操作查询结果时也非常类似。</p><p>下面分别通过实例来演示 DataSet 和 DataTable 的使用。 </p><h2 id="四-实例-创建-Windows-应用程序，查询用户信息表（userinfo）中的所有用户名，并将用户名显示在列表控件（ListBox）中"><a href="#四-实例-创建-Windows-应用程序，查询用户信息表（userinfo）中的所有用户名，并将用户名显示在列表控件（ListBox）中" class="headerlink" title="四 实例  创建 Windows 应用程序，查询用户信息表（userinfo）中的所有用户名，并将用户名显示在列表控件（ListBox）中"></a>四 实例  创建 Windows 应用程序，查询用户信息表（userinfo）中的所有用户名，并将用户名显示在列表控件（ListBox）中</h2><h3 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1 分析"></a>4.1 分析</h3><p> 单击“查询全部用户名”按钮，将所有用户名显示到 ListBox 控件中，首先使用 DataSet 对象存储查询结果 </p><h3 id="4-2-界面布局"><a href="#4-2-界面布局" class="headerlink" title="4.2 界面布局"></a>4.2 界面布局</h3><p>包含以下组件：</p><ul><li>查询全部用户名：Button</li><li>数据展示：ListBox</li></ul><p><img src="https://images.pgzxc.com/csharp-sql-dataset-layout.png" alt=""></p><h3 id="4-3-代码"><a href="#4-3-代码" class="headerlink" title="4.3 代码"></a>4.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;“查询全部用户”按钮的单击事件</span><br><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">    string connStr &#x3D; &quot;Data Source&#x3D;.; Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">    &#x2F;&#x2F;创建 SQLConnection 的实例</span><br><span class="line">    SqlConnection conn &#x3D; null;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">        &#x2F;&#x2F;打开数据库连接</span><br><span class="line">        conn.Open();</span><br><span class="line">        string sql &#x3D; &quot;select name from userinfo&quot;;</span><br><span class="line">        &#x2F;&#x2F;创建 SQLDataAdapter 类的对象</span><br><span class="line">        SqlDataAdapter sda &#x3D; new SqlDataAdapter(sql, conn);</span><br><span class="line">        &#x2F;&#x2F;创建DataSet类的对象</span><br><span class="line">        DataSet ds &#x3D; new DataSet();</span><br><span class="line">        &#x2F;&#x2F;使用SQLDataAdapter对象sda将查询结果填充到Dataset对象ds中</span><br><span class="line">        sda.Fill(ds);</span><br><span class="line">        &#x2F;&#x2F;设置ListBox控件的数据源（DataSource）属性</span><br><span class="line">        listBox1.DataSource &#x3D; ds.Tables[0];</span><br><span class="line">        &#x2F;&#x2F;在listBox控件中显示name列的值</span><br><span class="line">        listBox1.DisplayMember &#x3D; ds.Tables[0].Columns[0].ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;查询失败！&quot; + ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        if (conn !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭数据库连接</span><br><span class="line">            conn.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-效果图"><a href="#4-4-效果图" class="headerlink" title="4.4 效果图"></a>4.4 效果图</h3><p><img src="https://images.pgzxc.com/csharp-sql-dataset-view.gif" alt=""></p><h3 id="4-5-说明"><a href="#4-5-说明" class="headerlink" title="4.5 说明"></a>4.5 说明</h3><p>从上面的运行效果可以看出，已经将用户信息表 (userinfo) 中的所有用户名显示在列表控件 (ListBox) 中。</p><p>需要注意的是，ListBox 控件中的 DataSource 属性用于设置控件中内容的数据源，并需要通过 DisplayMember 属性来指定显示在 ListBox 控件中的内容</p><h3 id="4-6-延伸-在本实例中将-DataSet-对象换成-DataTable-对象"><a href="#4-6-延伸-在本实例中将-DataSet-对象换成-DataTable-对象" class="headerlink" title="4.6 延伸  在本实例中将 DataSet 对象换成 DataTable 对象"></a>4.6 延伸  在本实例中将 DataSet 对象换成 DataTable 对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建 SqlDataAdapter 类的对象</span><br><span class="line">SqlDataAdapter sda &#x3D; new SqlDataAdapter(sql, conn);</span><br><span class="line">&#x2F;&#x2F;创建 DataTable 类的对象</span><br><span class="line">DataTable dt &#x3D; new DataTable();</span><br><span class="line">&#x2F;&#x2F;使用 SqlDataAdapter 对象 sda 将查询结果填充到 DataSet 对象 dt 中</span><br><span class="line">sda.Fill(dt);</span><br><span class="line">&#x2F;&#x2F;设置 ListBox 控件的数据源(DataSource)属性</span><br><span class="line">listBox1.DataSource &#x3D; dt;</span><br><span class="line">&#x2F;&#x2F;在 ListBox 控件中显示 name 列的值</span><br><span class="line">listBox1.DisplayMember &#x3D; dt.Columns[0].ToStiring();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在执行对表中数据的查询时还能将数据保存到 DataSet 中，但需要借助 DataAdapter 类来实现。&lt;/li&gt;
&lt;li&gt;在实际应用中，DataAdapter 与 DataSet 是在查询操作中使用最多的类。&lt;/li&gt;
&lt;li&gt;此外，还可以通过 DataSet 实现对表中数据的增加、修改、删除操作 &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——读取查询结果(15.7)</title>
    <link href="http://pgzxc.github.io/posts/b3124fd9.html"/>
    <id>http://pgzxc.github.io/posts/b3124fd9.html</id>
    <published>2020-08-17T13:57:58.000Z</published>
    <updated>2020-08-17T13:59:04.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#中DataReader类的作用是读取查询结果，与在C# 数据库操作中介绍的Command类中的ExecuteReader方法一起使用</li><li>本节介绍DataReader类中常用的属性和方法，以及如何使用该类查询表中的数据</li></ul><a id="more"></a><h2 id="二-DataReader-类概述"><a href="#二-DataReader-类概述" class="headerlink" title="二 DataReader 类概述"></a>二 DataReader 类概述</h2><h3 id="2-1-DataReader概述"><a href="#2-1-DataReader概述" class="headerlink" title="2.1 DataReader概述"></a>2.1 DataReader概述</h3><p> DataReader 类在 System.Data.SqlClient 命名空间中，对应的类是 SqlDataReader，主要用于读取表中的查询结果，并且是以只读方式读取的（即不能修改 DataReader 中存放的数据）。</p><p>正是由于 DataReader 类的特殊的读取方式，其访问数据的速度比较快，占用的服务器资源比较少。 </p><h3 id="2-2-常用的属性和方法"><a href="#2-2-常用的属性和方法" class="headerlink" title="2.2 常用的属性和方法"></a>2.2 常用的属性和方法</h3><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">FieldCount</td><td align="center">属性，获取当前行中的列数</td></tr><tr><td align="center">HasRows</td><td align="center">属性，获取 DataReader 中是否包含数据</td></tr><tr><td align="center">IsClosed</td><td align="center">属性，获取 DataReader 的状态是否为已经被关闭</td></tr><tr><td align="center">Read</td><td align="center">方法，让 DataReader 对象前进到下一条记录</td></tr><tr><td align="center">Close</td><td align="center">方法，关闭 DataReader 对象</td></tr><tr><td align="center">Get XXX (int i)</td><td align="center">方法，获取指定列的值，其中XXX代表的是数据类型。例如获取当前行第1列 double 类型的值，获取方法为GetDouble(o)</td></tr></tbody></table><h2 id="三-使用-DataReader-类读取查询结果"><a href="#三-使用-DataReader-类读取查询结果" class="headerlink" title="三 使用 DataReader 类读取查询结果"></a>三 使用 DataReader 类读取查询结果</h2><p> 在使用 DataReader 类读取查询结果时需要注意，当查询结果仅为一条时，可以使用 if 语句查询 DataReader 对象中的数据，如果返回值是多条数据，需要通过 while 语句遍历 DataReader 对象中的数据。</p><p>在使用 DataReader 类读取查询结果时需要通过以下步骤完成： </p><h3 id="3-1-执行-SqlCommand-对象中的-ExecuteReader-方法"><a href="#3-1-执行-SqlCommand-对象中的-ExecuteReader-方法" class="headerlink" title="3.1 执行 SqlCommand 对象中的 ExecuteReader 方法"></a>3.1 执行 SqlCommand 对象中的 ExecuteReader 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlDataReader dr&#x3D;SqlCommand 类实例 .ExecuteReader();</span><br></pre></td></tr></table></figure><h3 id="3-2-遍历-SqlDataReader-中的结果"><a href="#3-2-遍历-SqlDataReader-中的结果" class="headerlink" title="3.2 遍历 SqlDataReader 中的结果"></a>3.2 遍历 SqlDataReader 中的结果</h3><p> SqlDataReader 类中提供的 Read 方法用于判断其是否有值，并指向 SqlDataReader 结果中的下一条记录。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dr.Read()</span><br></pre></td></tr></table></figure><p> 如果返回值为 True，则可以读取该条记录，否则无法读取。 </p><p> 在读取记录时，要根据表中的数据类型来读取表中相应的列。 </p><h3 id="3-3-关闭-SqlDataReader"><a href="#3-3-关闭-SqlDataReader" class="headerlink" title="3.3 关闭 SqlDataReader"></a>3.3 关闭 SqlDataReader</h3><p>操作完成以后关闭数据流</p><h2 id="四-实例-根据用户姓名查询用户的编号和密码，并将编号和密码显示在标签控件-Label-上"><a href="#四-实例-根据用户姓名查询用户的编号和密码，并将编号和密码显示在标签控件-Label-上" class="headerlink" title="四 实例  根据用户姓名查询用户的编号和密码，并将编号和密码显示在标签控件 (Label) 上"></a>四 实例  根据用户姓名查询用户的编号和密码，并将编号和密码显示在标签控件 (Label) 上</h2><h3 id="4-1-界面布局"><a href="#4-1-界面布局" class="headerlink" title="4.1 界面布局"></a>4.1 界面布局</h3><p>包含以下组件：</p><ul><li>用户名：Label</li><li>输入框：TextBox</li><li>查询按钮：Button</li><li>查询结果：Label</li></ul><p><img src="https://images.pgzxc.com/csharp-sql-query-user-layout.png" alt=""></p><h3 id="4-2-代码-查询"><a href="#4-2-代码-查询" class="headerlink" title="4.2 代码(查询)"></a>4.2 代码(查询)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">  string connStr &#x3D; &quot;Data Source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">  &#x2F;&#x2F;创建 SqlConnection的实例</span><br><span class="line">  SqlConnection conn &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F;定义SqlDataReader类的对象</span><br><span class="line">  SqlDataReader dr &#x3D; null;</span><br><span class="line">  try</span><br><span class="line">    &#123;</span><br><span class="line">      conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">      &#x2F;&#x2F;打开数据库连接</span><br><span class="line">      conn.Open();</span><br><span class="line">      string sql &#x3D; &quot;select id,password from userinfo where name&#x3D;&#39;&#123;0&#125;&#39;&quot;;</span><br><span class="line">      &#x2F;&#x2F;填充SQL语句</span><br><span class="line">      sql &#x3D; string.Format(sql, textBox1.Text);</span><br><span class="line">      &#x2F;&#x2F;创建SqlCommand对象</span><br><span class="line">      SqlCommand cmd &#x3D; new SqlCommand(sql, conn);</span><br><span class="line">      &#x2F;&#x2F;执行Sql语句</span><br><span class="line">      dr &#x3D; cmd.ExecuteReader();</span><br><span class="line">      &#x2F;&#x2F;判断SQL语句是否执行成功</span><br><span class="line">      if (dr.Read())</span><br><span class="line">      &#123;</span><br><span class="line">         &#x2F;&#x2F;读取指定用户名对应的用户编号和密码</span><br><span class="line">         string msg &#x3D; &quot;用户编号：&quot; + dr[0] + &quot; 密码：&quot; + dr[1];</span><br><span class="line">         &#x2F;&#x2F;将msg的值显示在标签上</span><br><span class="line">         label2.Text &#x3D; msg;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">             label2.Text &#x3D; &quot;没有符合条件的结果&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Exception ex)</span><br><span class="line">      &#123;</span><br><span class="line">          MessageBox.Show(&quot;查询失败！&quot; + ex.Message);</span><br><span class="line">      &#125;</span><br><span class="line">      finally</span><br><span class="line">      &#123;</span><br><span class="line">         if (dr !&#x3D; null)</span><br><span class="line">         &#123;</span><br><span class="line">            &#x2F;&#x2F;判断dr不为空，关闭SqlDataReader对象</span><br><span class="line">            dr.Close();</span><br><span class="line">         &#125;</span><br><span class="line">         if (conn !&#x3D; null)</span><br><span class="line">          &#123;</span><br><span class="line">             &#x2F;&#x2F;关闭数据库连接</span><br><span class="line">             conn.Close();</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-效果图"><a href="#4-3-效果图" class="headerlink" title="4.3 效果图"></a>4.3 效果图</h3><p><img src="https://images.pgzxc.com/csharp-sql-query-user-view.gif" alt=""></p><h3 id="4-4-说明"><a href="#4-4-说明" class="headerlink" title="4.4 说明"></a>4.4 说明</h3><p>从上面的运行效果可以看出，“张三”用户对应的用户编号为 1、密码为 123456。</p><p>需要注意的是，实现上述功能的要求是用户表中的用户名是唯一的，以避免出现查询错误</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#中DataReader类的作用是读取查询结果，与在C# 数据库操作中介绍的Command类中的ExecuteReader方法一起使用&lt;/li&gt;
&lt;li&gt;本节介绍DataReader类中常用的属性和方法，以及如何使用该类查询表中的数据&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——操作数据库(15.6)</title>
    <link href="http://pgzxc.github.io/posts/61a87d4c.html"/>
    <id>http://pgzxc.github.io/posts/61a87d4c.html</id>
    <published>2020-08-17T13:56:27.000Z</published>
    <updated>2020-08-17T13:57:17.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在上一节 C# Connection中我们讲解了 C#语言连接数据库的方法，在与数据库建立连接之后即可开始操作数据库中的对象。</li><li>操作数据库需则要用到 Command 类中提供的属性和方法。下面来介绍一下如何使用 Command 类来操作数据表中的数据 </li></ul><a id="more"></a><h2 id="二-Command-类概述"><a href="#二-Command-类概述" class="headerlink" title="二 Command 类概述"></a>二 Command 类概述</h2><p> 在 System.Data.SqlClient 命名空间下，对应的 Command 类为 SqlCommand，在创建 SqlCommand 实例前必须已经创建了与数据库的连接。 </p><h3 id="2-1-常用构造方法"><a href="#2-1-常用构造方法" class="headerlink" title="2.1 常用构造方法"></a>2.1 常用构造方法</h3><table><thead><tr><th align="center"><strong>构造方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">SqlCommand()</td><td align="center">无参构造方法</td></tr><tr><td align="center">SqlCommand(string commandText,SqlConnection conn)</td><td align="center">带参的构造方法，第 1 个参数是要执行的 SQL 语句，第 2 个参数是数据库的连接对象</td></tr></tbody></table><h3 id="2-2-常用属性和方法"><a href="#2-2-常用属性和方法" class="headerlink" title="2.2 常用属性和方法"></a>2.2 常用属性和方法</h3><p>对数据库中对象的操作不仅包括对数据表的操作，还包括对数据库、视图、存储过程等数据库对象的操作，接下来主要介绍的是对数据表和存储过程的操作。</p><p>在对不同数据库对象进行操作时，SqlCommand 类提供了不同的属性和方法，常用的属性和方法如下表所示 </p><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">CommandText</td><td align="center">属性，Command 对象中要执行的 SQL 语句</td></tr><tr><td align="center">Connection</td><td align="center">属性，获取或设置数据库的连接对象</td></tr><tr><td align="center">CommandType</td><td align="center">属性，获取或设置命令类型</td></tr><tr><td align="center">Parameters</td><td align="center">属性，设置 Command 对象中 SQL 语句的参数</td></tr><tr><td align="center">ExecuteReader()</td><td align="center">方法，获取执行查询语句的结果</td></tr><tr><td align="center">ExecuteScalar()</td><td align="center">方法，返回查询结果中第 1 行第 1 列的值</td></tr><tr><td align="center">ExecuteNonQuery()</td><td align="center">方法，执行对数据表的增加、删除、修改操作</td></tr></tbody></table><h2 id="三-使用-Command-类操作数据库"><a href="#三-使用-Command-类操作数据库" class="headerlink" title="三 使用 Command 类操作数据库"></a>三 使用 Command 类操作数据库</h2><ul><li>Command 类中提供了 3 种命令类型，分别是 Text、TableDirect 以及 StoredProcedure，默认情况下是 Text。 </li><li>所谓 Text 类型是指使用 SQL 语句的形式，包括增加、删除、修改以及查询的SQL语句。</li><li>StoredProcedure 用于执行存储过程；TableDirect 仅在 OLE DB 驱动程序中有效  </li><li>在使用 Command 类操作数据库时需要通过以下步骤完成 </li></ul><h3 id="3-1-创建-SqlCommand-类的实例"><a href="#3-1-创建-SqlCommand-类的实例" class="headerlink" title="3.1 创建 SqlCommand 类的实例"></a>3.1 创建 SqlCommand 类的实例</h3><p> 创建 SqlCommand 类的实例分两种情况，一种是命令类型为 Text 的，一种是命令类型为 StoredProcedure 的。 </p><h4 id="3-1-1-命令类型为-Text"><a href="#3-1-1-命令类型为-Text" class="headerlink" title="3.1.1 命令类型为 Text"></a>3.1.1 命令类型为 Text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlCommand SqlCommand 类的实例名 &#x3D; new SqlCommand(SQL语句 , 数据库连接类的实例 );</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>SQL语句：指该SqlCommand类的实例要执行的SQL语句</li><li>数据库连接类的实例： 指使用 SqlConnection 类创建的实例，通常数据库连接类的实例处于打开的状态 </li></ul><h4 id="3-1-2-命令类型为-StoredProcedure"><a href="#3-1-2-命令类型为-StoredProcedure" class="headerlink" title="3.1.2 命令类型为 StoredProcedure"></a>3.1.2 命令类型为 StoredProcedure</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlCommand SqlCommand 类的实例名 &#x3D; new SqlCommand( 存储过程名称 , 数据库连接类的实例 );</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li><p>存储过程必须是当前数据库实例中的存储过程，并且在调用带参数的存储过程时，还需要在 SqlCommand 类的实例中添加对应的存储过程参数 </p><p>为存储过程添加参数，需要使用 SqlCommand 类实例的 Parameters 属性来设置，具体的代码如下 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlCommand 类实例 .Parameters.Add( 参数名 , 参数值 );</span><br></pre></td></tr></table></figure><p>在这里，参数名与存储过程中定义的参数名要一致 </p><h3 id="3-2-执行对数据表的操作"><a href="#3-2-执行对数据表的操作" class="headerlink" title="3.2  执行对数据表的操作"></a>3.2  执行对数据表的操作</h3><p> 在执行对数据表的操作时通常分为两种情况，一种是执行非查询 SQL 语句的操作，即增加、修改、删除的操作，一种是执行查询 SQL 语句的操作 </p><h4 id="3-2-1-执行非查询-SQL-语句的操作"><a href="#3-2-1-执行非查询-SQL-语句的操作" class="headerlink" title="3.2.1 执行非查询 SQL 语句的操作"></a>3.2.1 执行非查询 SQL 语句的操作</h4><p>在执行非查询 SQL 语句时并不需要返回表中的数据，直接使用 SqlCommand 类的 ExecuteNonQuery 方法即可，该方法的返回值是一个整数，用于返回 SqlCommand 类在执行 SQL 语句后，对表中数据影响的行数</p><p>当该方法的返回值为 -1 时，代表 SQL 语句执行失败，当该方法的返回值为 0 时，代表 SQL 语句对当前数据表中的数据没有影响 </p><p>例如 要删除学号为 1100 的学生的信息，而表中不存在该学号的学生的信息，SQL语句可以正常执行，但对表中的影响行数是 0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlCommand 类的实例 .ExecuteNonQuery();</span><br></pre></td></tr></table></figure><p> 需要注意的是，如果执行的 SQL 语句在数据库中执行错误，则会产生异常，因此该部分需要进行异常处理 </p><h4 id="3-2-2-执行查询语句的操作"><a href="#3-2-2-执行查询语句的操作" class="headerlink" title="3.2.2 执行查询语句的操作"></a>3.2.2 执行查询语句的操作</h4><p> 在执行查询语句时通常需要返回查询结果，SqlCommand 类中提供的 ExecuteReader 方法在执行查询 SQL 语句后，会返回一个 SqlDataReader 类型的值，通过遍历 SqlDataReader 类中的结果即可得到返回值。 </p><p>具体的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlDataReader dr &#x3D; SqlCommand 类的实例 .ExecuteReader();</span><br></pre></td></tr></table></figure><p> 此外，如果在执行查询语句后并不需要返回所有的查询结果，而仅需要返回一个值，例如查询表中的记录行数，这时可以使用 ExecuteScalar 方法。具体的代码如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int returnvalue &#x3D; SqlCommand 类的实例 .ExecuteScalar();</span><br></pre></td></tr></table></figure><h2 id="五-实例-表的创建见15-5"><a href="#五-实例-表的创建见15-5" class="headerlink" title="五 实例(表的创建见15.5)"></a>五 实例(表的创建见15.5)</h2><h3 id="5-1-实例一-制作一个用户注册界面，使用-SqlCommand-类向用户信息表中添加一条记录"><a href="#5-1-实例一-制作一个用户注册界面，使用-SqlCommand-类向用户信息表中添加一条记录" class="headerlink" title="5.1 实例一  制作一个用户注册界面，使用 SqlCommand 类向用户信息表中添加一条记录"></a>5.1 实例一  制作一个用户注册界面，使用 SqlCommand 类向用户信息表中添加一条记录</h3><h4 id="5-1-1-效果图"><a href="#5-1-1-效果图" class="headerlink" title="5.1.1  效果图"></a>5.1.1  效果图</h4><p>  <img src="https://images.pgzxc.com/csharp-sql-register-view.gif" alt=""></p><h4 id="5-1-2-代码"><a href="#5-1-2-代码" class="headerlink" title="5.1.2 代码"></a>5.1.2 代码</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;“注册”按钮的单击事件</span><br><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">    string connStr &#x3D; &quot;Data Source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">    &#x2F;&#x2F;创建 SqlConnection的实例</span><br><span class="line">    SqlConnection conn &#x3D; null;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">        &#x2F;&#x2F;打开数据库连接</span><br><span class="line">        conn.Open();</span><br><span class="line">        string sql &#x3D; &quot;insert into userinfo(name,password) values(&#39;&#123;0&#125;&#39;,&#39;&#123;1&#125;&#39;)&quot;;</span><br><span class="line">        &#x2F;&#x2F;填充SQL语句</span><br><span class="line">        sql &#x3D; string.Format(sql, textBox1.Text, textBox2.Text);</span><br><span class="line">        &#x2F;&#x2F;创建SqlCommand对象</span><br><span class="line">        SqlCommand cmd &#x3D; new SqlCommand(sql, conn);</span><br><span class="line">        &#x2F;&#x2F;执行SQL语句</span><br><span class="line">        int returnvalue &#x3D; cmd.ExecuteNonQuery();</span><br><span class="line">        &#x2F;&#x2F;判断SQL语句是否执行成功</span><br><span class="line">        if(returnvalue !&#x3D; -1)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;注册成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;注册失败！&quot;+ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        if (conn !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭数据库连接</span><br><span class="line">            conn.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-实例二-制作一个登录界面，使用-SqlCommand-类判断用户是否登录成功"><a href="#5-2-实例二-制作一个登录界面，使用-SqlCommand-类判断用户是否登录成功" class="headerlink" title="5.2 实例二 制作一个登录界面，使用 SqlCommand 类判断用户是否登录成功"></a>5.2 实例二 制作一个登录界面，使用 SqlCommand 类判断用户是否登录成功</h3><h4 id="5-2-1-效果图"><a href="#5-2-1-效果图" class="headerlink" title="5.2.1 效果图"></a>5.2.1 效果图</h4><p>  <img src="https://images.pgzxc.com/csharp-sql-login-cancle-view.png" alt=""></p><h4 id="5-2-2-代码"><a href="#5-2-2-代码" class="headerlink" title="5.2.2 代码"></a>5.2.2 代码</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&quot;登录&quot;按钮的单击事件</span><br><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">    string connStr &#x3D; &quot;Data Source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">    &#x2F;&#x2F;创建SQLConnection的实例</span><br><span class="line">    SqlConnection conn &#x3D; null;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">        &#x2F;&#x2F;打开数据库连接</span><br><span class="line">        conn.Open();</span><br><span class="line">        string sql &#x3D; &quot;Select count(*) from userinfo where name&#x3D;&#39;&#123;0&#125;&#39; and password&#x3D;&#39;&#123;1&#125;&#39;&quot;;</span><br><span class="line">        &#x2F;&#x2F;填充SQL语句</span><br><span class="line">        sql &#x3D; string.Format(sql, textBox1.Text, textBox2.Text);</span><br><span class="line">        &#x2F;&#x2F;创建SqlCommand对象</span><br><span class="line">        SqlCommand cmd &#x3D; new SqlCommand(sql, conn);</span><br><span class="line">        &#x2F;&#x2F;执行SQL语句</span><br><span class="line">        int returnvalue &#x3D; (int)cmd.ExecuteScalar();</span><br><span class="line">        &#x2F;&#x2F;判断SQL语句是否执行成功</span><br><span class="line">        if (returnvalue !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;登录成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;登录失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;注册失败！&quot; + ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        if (conn !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭数据库连接</span><br><span class="line">            conn.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;“取消”按钮的单击事件</span><br><span class="line">private void button2_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    this.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-实例三-改进用户注册功能，使用户在注册时用户名唯一"><a href="#5-3-实例三-改进用户注册功能，使用户在注册时用户名唯一" class="headerlink" title="5.3 实例三  改进用户注册功能，使用户在注册时用户名唯一"></a>5.3 实例三  改进用户注册功能，使用户在注册时用户名唯一</h3><h4 id="5-3-1-效果图"><a href="#5-3-1-效果图" class="headerlink" title="5.3.1 效果图"></a>5.3.1 效果图</h4><p>  <img src="https://images.pgzxc.com/charp-sql-register-username-exist.png" alt=""></p><h4 id="5-3-2-代码"><a href="#5-3-2-代码" class="headerlink" title="5.3.2 代码"></a>5.3.2 代码</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;“注册”按钮的单击事件</span><br><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">    string connStr &#x3D; &quot;Data Source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">    &#x2F;&#x2F;创建 SqlConnection的实例</span><br><span class="line">    SqlConnection conn &#x3D; null;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">        &#x2F;&#x2F;打开数据库连接</span><br><span class="line">        conn.Open();</span><br><span class="line">        &#x2F;&#x2F;判断用户名是否重复</span><br><span class="line">        string checkNameSql &#x3D; &quot;select count(*) from userinfo where name&#x3D;&#39;&#123;0&#125;&#39;&quot;;</span><br><span class="line">        checkNameSql &#x3D; string.Format(checkNameSql, textBox1.Text);</span><br><span class="line">        &#x2F;&#x2F;创建SqlCommand对象</span><br><span class="line">        SqlCommand cmdCheckName &#x3D; new SqlCommand(checkNameSql, conn);</span><br><span class="line">        &#x2F;&#x2F;执行SQL语句</span><br><span class="line">        int isRepeatName &#x3D; (int)cmdCheckName.ExecuteScalar();</span><br><span class="line">        if (isRepeatName !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;用户名重复，则不执行注册操作</span><br><span class="line">            MessageBox.Show(&quot;用户名已存在！&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        string sql &#x3D; &quot;insert into userinfo(name,password) values(&#39;&#123;0&#125;&#39;,&#39;&#123;1&#125;&#39;)&quot;;</span><br><span class="line">        &#x2F;&#x2F;填充SQL语句</span><br><span class="line">        sql &#x3D; string.Format(sql, textBox1.Text, textBox2.Text);</span><br><span class="line">        &#x2F;&#x2F;创建SqlCommand对象</span><br><span class="line">        SqlCommand cmd &#x3D; new SqlCommand(sql, conn);</span><br><span class="line">        &#x2F;&#x2F;执行SQL语句</span><br><span class="line">        int returnvalue &#x3D; cmd.ExecuteNonQuery();</span><br><span class="line">        &#x2F;&#x2F;判断SQL语句是否执行成功</span><br><span class="line">        if(returnvalue !&#x3D; -1)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;注册成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;注册失败！&quot;+ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        if (conn !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭数据库连接</span><br><span class="line">            conn.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-实例四-创建一个存储过程实现用户注册功能，并使用-SqlCommand-类调用存储过程"><a href="#5-4-实例四-创建一个存储过程实现用户注册功能，并使用-SqlCommand-类调用存储过程" class="headerlink" title="5.4 实例四  创建一个存储过程实现用户注册功能，并使用 SqlCommand 类调用存储过程"></a>5.4 实例四  创建一个存储过程实现用户注册功能，并使用 SqlCommand 类调用存储过程</h3><h4 id="5-4-1-功能分析"><a href="#5-4-1-功能分析" class="headerlink" title="5.4.1 功能分析"></a>5.4.1 功能分析</h4><p> 用户注册功能的存储过程比较简单，只需要写一个带参数的存储过程将用户名和密码传递给存储过程，并使用 insert 语句将用户名和密码添加到用户信息表中 </p><h4 id="5-4-2-创建存储过程的语句"><a href="#5-4-2-创建存储过程的语句" class="headerlink" title="5.4.2  创建存储过程的语句"></a>5.4.2  创建存储过程的语句</h4><p>数据库的<code>存储过程</code>上单击右键<code>添加存储过程</code>，在dbo.Procedure.sql，填入存储过程语句，并更新</p><p><img src="https://images.pgzxc.com/csharp-sql-store-progress-command.png" alt=""></p><h4 id="5-4-3-代码"><a href="#5-4-3-代码" class="headerlink" title="5.4.3 代码"></a>5.4.3 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;编写数据库连接串</span><br><span class="line">string connStr &#x3D; &quot;Data Source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">&#x2F;&#x2F;创建 SqlConnection的实例</span><br><span class="line">SqlConnection conn &#x3D; null;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">    &#x2F;&#x2F;打开数据库连接</span><br><span class="line">    conn.Open();</span><br><span class="line">    &#x2F;&#x2F;创建SqlCommand对象</span><br><span class="line">    SqlCommand cmd &#x3D; new SqlCommand(&quot;AddUser&quot;, conn);</span><br><span class="line">    &#x2F;&#x2F;设置SQLCommand对象的命令类型（CommandType）是存储过程</span><br><span class="line">    cmd.CommandType &#x3D; CommandType.StoredProcedure;</span><br><span class="line">    &#x2F;&#x2F;设置存储过程需要的参数</span><br><span class="line">    cmd.Parameters.AddWithValue(&quot;name&quot;, textBox1.Text);</span><br><span class="line">    cmd.Parameters.AddWithValue(&quot;password&quot;, textBox2.Text);</span><br><span class="line">    &#x2F;&#x2F;执行存储过程</span><br><span class="line">    int returnvalue &#x3D; cmd.ExecuteNonQuery();</span><br><span class="line">    Console.WriteLine(returnvalue);</span><br><span class="line">    &#x2F;&#x2F;判断SQL语句是否执行成功</span><br><span class="line">    if(returnvalue !&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;注册成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(&quot;注册失败！&quot;+ex.Message);</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    if (conn !&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;关闭数据库连接</span><br><span class="line">        conn.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-4-说明"><a href="#5-4-4-说明" class="headerlink" title="5.4.4 说明"></a>5.4.4 说明</h4><p> 运行该窗体，效果与实例 1 一致。从上面的代码可以看出，调用存储过程并不复杂，只需要在 SqlCommand 对象中将 CommandType 属性的值改成 StoredProcedure，并添加存储过程中所需要的参数即可 </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在上一节 C# Connection中我们讲解了 C#语言连接数据库的方法，在与数据库建立连接之后即可开始操作数据库中的对象。&lt;/li&gt;
&lt;li&gt;操作数据库需则要用到 Command 类中提供的属性和方法。下面来介绍一下如何使用 Command 类来操作数据表中的数据 &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——创建表和字段(15.5)</title>
    <link href="http://pgzxc.github.io/posts/88238754.html"/>
    <id>http://pgzxc.github.io/posts/88238754.html</id>
    <published>2020-08-17T13:54:30.000Z</published>
    <updated>2020-08-17T13:55:52.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一  概述"></a>一  概述</h2><p>本文介绍C#下创建表和字段，分以下两种情况：</p><ul><li>Microsoft SQL Server Management Studio(输入)</li><li>Visual Studio 2019(命令行)</li></ul><a id="more"></a><h2 id="二-表格创建要求"><a href="#二-表格创建要求" class="headerlink" title="二 表格创建要求"></a>二 表格创建要求</h2><ul><li>表名：userinfo</li><li>字段：id(int类型)、name(varchar(20))、password(varchar(20))</li></ul><h2 id="三-创建方式"><a href="#三-创建方式" class="headerlink" title="三  创建方式"></a>三  创建方式</h2><h3 id="3-1-Microsoft-SQL-Server-Management-Studio"><a href="#3-1-Microsoft-SQL-Server-Management-Studio" class="headerlink" title="3.1 Microsoft SQL Server Management Studio"></a>3.1 Microsoft SQL Server Management Studio</h3><ul><li><p>登录到Management Studio后，右键数据库，新建test数据库</p><p><img src="https://images.pgzxc.com/csharp-management-studio-create-test.png" alt=""></p></li><li><p>在表上右键，选择新建表，分别填写列名，数据类型和是否允许Null值，保存时填写表名为userinfo</p><p><img src="https://images.pgzxc.com/csharp-management-studio-table-crate.png" alt=""></p></li></ul><h3 id="3-2-Visual-Studio-2019"><a href="#3-2-Visual-Studio-2019" class="headerlink" title="3.2 Visual Studio 2019"></a>3.2 Visual Studio 2019</h3><ul><li><p>通过服务器资源管理器，依次打开：数据库连接—&gt;添加连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器名：.(本地的服务器)</span><br><span class="line">身份验证：SQL Server 身份验证</span><br><span class="line">   用户名：su</span><br><span class="line">   密码：root</span><br><span class="line">选择或输入数据库名称：test(列表中选择)   </span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/csharp-visula-studio-sql-connected.png" alt=""></p></li><li><p>选择连接好的数据库，右键新建表</p><p><img src="https://images.pgzxc.com/csharp-visual-studio-create-table.png" alt=""></p></li><li><p>在T-SQL中输入创建表格的指令，点击上方的更新</p><p><img src="https://images.pgzxc.com/csharp-visual-studio-command-update.png" alt=""></p></li><li><p>在弹出的窗口中选择更新数据库</p><p><img src="https://images.pgzxc.com/csharp-visual-studio-update-script.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一  概述&quot;&gt;&lt;/a&gt;一  概述&lt;/h2&gt;&lt;p&gt;本文介绍C#下创建表和字段，分以下两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft SQL Server Management Studio(输入)&lt;/li&gt;
&lt;li&gt;Visual Studio 2019(命令行)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——Coding Pages 申请 SSL 证书错误</title>
    <link href="http://pgzxc.github.io/posts/73040432.html"/>
    <id>http://pgzxc.github.io/posts/73040432.html</id>
    <published>2020-08-15T10:37:30.000Z</published>
    <updated>2020-08-15T10:38:43.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-现象"><a href="#一-现象" class="headerlink" title="一 现象"></a>一 现象</h2><p>Hexo博客在进行Coding Pages绑定域名时显示如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme:error:unauthorized: During secondary validation: Invalid response from http:&#x2F;&#x2F;pgzxc.com&#x2F;.well-known&#x2F;acme-challenge&#x2F;u0F-eNkNn958JbxhnH0lyhGxS6d_FMLHWmIiiwF8P5k [185.199.108.153]: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n &lt;head&gt;\n &lt;meta http-equiv&#x3D;\&quot;Content-type\&quot; content&#x3D;\&quot;text&#x2F;html; charset&#x3D;utf-8\&quot;&gt;\n &lt;meta http-equiv&#x3D;\&quot;Co&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://images.pgzxc.com/coding-bang-error.png" alt=""></p><h2 id="二-原因分析"><a href="#二-原因分析" class="headerlink" title="二 原因分析"></a>二 原因分析</h2><p> 这种错误一般是 hexo 博客双线部署到 GitHub Pages 和 Coding Pages 过程中出现的，并且已经在域名 DNS 配置好了 GitHub 的域名解析，这种情况下，在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败 </p><h2 id="三-解决办法"><a href="#三-解决办法" class="headerlink" title="三 解决办法"></a>三 解决办法</h2><p> 先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，等待申请成功再恢复 GitHub 的解析 </p><p><img src="https://images.pgzxc.com/coding-github-pause.png" alt=""></p><p><img src="https://images.pgzxc.com/coding-yuming-bang-success.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-现象&quot;&gt;&lt;a href=&quot;#一-现象&quot; class=&quot;headerlink&quot; title=&quot;一 现象&quot;&gt;&lt;/a&gt;一 现象&lt;/h2&gt;&lt;p&gt;Hexo博客在进行Coding Pages绑定域名时显示如下错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;acme:error:unauthorized: During secondary validation: Invalid response from http:&amp;#x2F;&amp;#x2F;pgzxc.com&amp;#x2F;.well-known&amp;#x2F;acme-challenge&amp;#x2F;u0F-eNkNn958JbxhnH0lyhGxS6d_FMLHWmIiiwF8P5k [185.199.108.153]: &amp;quot;&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html&amp;gt;\n &amp;lt;head&amp;gt;\n &amp;lt;meta http-equiv&amp;#x3D;\&amp;quot;Content-type\&amp;quot; content&amp;#x3D;\&amp;quot;text&amp;#x2F;html; charset&amp;#x3D;utf-8\&amp;quot;&amp;gt;\n &amp;lt;meta http-equiv&amp;#x3D;\&amp;quot;Co&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——部署到Coding上</title>
    <link href="http://pgzxc.github.io/posts/7871b3a7.html"/>
    <id>http://pgzxc.github.io/posts/7871b3a7.html</id>
    <published>2020-08-15T10:34:59.000Z</published>
    <updated>2020-08-15T10:38:43.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>之前将博客部署到了Github上，但是由于网络的原因导致网站有时候无法访问，这时候的解决办法是将博客部署到两个服务器上，国外访问时使用Github上的项目，国内访问时使用本文介绍的Coding上</p><a id="more"></a><h2 id="二-列表"><a href="#二-列表" class="headerlink" title="二 列表"></a>二 列表</h2><ul><li>hexo博客代码</li><li><a href="https://coding.net/">coding</a></li></ul><h2 id="三-配置SSH"><a href="#三-配置SSH" class="headerlink" title="三 配置SSH"></a>三 配置SSH</h2><ul><li><p>查看<code>C:\Users\用户名\</code>下有没有.ssh文件夹(如果有，id_rsa.pub是要设置的)</p></li><li><p>如果没有，执行下面的指令生成SSH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot; </span><br></pre></td></tr></table></figure></li><li><p>接下来几步中系统会要你输入密码 ( <strong>注：不设置密码的可以直接按三次回车</strong> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):&lt;输入密码&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入密码&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://images.pgzxc.com/coding-ras-setting.png" alt=""></p><h2 id="四-配置Coding"><a href="#四-配置Coding" class="headerlink" title="四 配置Coding"></a>四 配置Coding</h2><h3 id="4-1-实名认证-没有实名认证，无法设置静态博客"><a href="#4-1-实名认证-没有实名认证，无法设置静态博客" class="headerlink" title="4.1 实名认证(没有实名认证，无法设置静态博客)"></a>4.1 实名认证(没有实名认证，无法设置静态博客)</h3><ul><li><p><a href="https://coding.net/">Cdoing官网</a>登录后，点击右上角下拉列表中的团队管理 </p><p><img src="https://images.pgzxc.com/coding-auth-disable.png" alt=""></p></li><li><p>绑定了手机号后，可以进行实名认证了</p><p><img src="https://images.pgzxc.com/coding-auth-set-phone-after.png" alt=""></p></li><li><p>点击进行实名认证，输入姓名和身份证号</p><p><img src="https://images.pgzxc.com/coding-auth-success.png" alt=""></p></li></ul><h3 id="4-2-配置SSH"><a href="#4-2-配置SSH" class="headerlink" title="4.2 配置SSH"></a>4.2 配置SSH</h3><ul><li><p>点击右上角下拉列表中的<code>个人账户设置</code>，在左侧找到SSH公钥</p><p><img src="https://images.pgzxc.com/coding-ssh-list.png" alt=""></p></li><li><p>点击右上角的<code>新增公钥</code>，将id_rsa.pub中的内容全部copy到<code>公钥内容</code>中，公钥名称自定义，并设置期限为<code>永久有效</code><br><img src="https://images.pgzxc.com/coding-ssh-setting.png" alt=""></p></li></ul><h3 id="4-3-新建项目"><a href="#4-3-新建项目" class="headerlink" title="4.3 新建项目"></a>4.3 新建项目</h3><ul><li><p>点击<code>创建项目</code>时，弹出项目模板选择页面(选择DevOps项目)</p><p><img src="https://images.pgzxc.com/coding-create-project-devops.png" alt=""></p></li><li><p>填写项目创建信息</p><p><img src="https://images.pgzxc.com/coding-devops-info.png" alt=""></p></li><li><p>进入刚刚创建的项目，找到仓库设置，copy SSH下路径(hexo博客设置会用到)</p><p><img src="https://images.pgzxc.com/coding-ssh-gitcopy.png" alt=""></p></li></ul><h2 id="五-配置hexo博客-config-yml"><a href="#五-配置hexo博客-config-yml" class="headerlink" title="五 配置hexo博客( _config.yml )"></a>五 配置hexo博客( _config.yml )</h2><h3 id="5-1-配置-config-yml"><a href="#5-1-配置-config-yml" class="headerlink" title="5.1 配置_config.yml"></a>5.1 配置_config.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:                                         #部署部分的设置</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">     github: git@github.com:PGzxc&#x2F;PGzxc.github.io.git(换成你自己的)</span><br><span class="line">     coding: git@e.coding.net:pgzxc&#x2F;pgzxc&#x2F;pgzxc.git(换成你自己的)</span><br></pre></td></tr></table></figure><h3 id="5-2-执行hexo-指令"><a href="#5-2-执行hexo-指令" class="headerlink" title="5.2 执行hexo 指令"></a>5.2 执行hexo 指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/coding-deploy-coding.png" alt=""></p><h2 id="六-Coding部署"><a href="#六-Coding部署" class="headerlink" title="六 Coding部署"></a>六 Coding部署</h2><ul><li><p>步骤五执行后，项目下会有部署的代码文件</p><p><img src="https://images.pgzxc.com/coding-code-property-view.png" alt=""></p></li><li><p>点击下方的<code>持续部署</code>，从列表中找到静态网站(此时的访问地址是无法访问的)</p><p><img src="https://images.pgzxc.com/coding-static-webview-list.png" alt=""></p></li><li><p>点击<code>立即部署</code>按钮，再次点击访问地址就可以正常访问了</p><p><img src="https://images.pgzxc.com/coding-static-webview-deply-quick.png" alt=""></p></li></ul><h2 id="七-自定义域名（有域名者—阿里云域名解析）"><a href="#七-自定义域名（有域名者—阿里云域名解析）" class="headerlink" title="七 自定义域名（有域名者—阿里云域名解析）"></a>七 自定义域名（有域名者—阿里云域名解析）</h2><ul><li><p>将在coding上的网站添加到域名解析列表中(最好先将github解析暂停，否则会出现解析失败的情况)</p><p><img src="https://images.pgzxc.com/coding-aliyun-jiexi.png" alt=""></p></li><li><p>在Coding静态网站—&gt;自定义域名，输入要绑定的域名，添加绑定，并强制开启https访问</p><p><img src="https://images.pgzxc.com/coding-yuming-bang-success.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;之前将博客部署到了Github上，但是由于网络的原因导致网站有时候无法访问，这时候的解决办法是将博客部署到两个服务器上，国外访问时使用Github上的项目，国内访问时使用本文介绍的Coding上&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——连接数据库(15.4)</title>
    <link href="http://pgzxc.github.io/posts/ba501380.html"/>
    <id>http://pgzxc.github.io/posts/ba501380.html</id>
    <published>2020-08-14T14:26:06.000Z</published>
    <updated>2020-08-14T14:28:03.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>C#语言中Connection类是ADO.NET组件连接数据库时第一个要使用的类，也是通过编程访问数据库的第一步。接下也来我们来了解一下Connection类中的常用属性和方法，以及如何连接SQL Server数据库</p><a id="more"></a><h2 id="二-Connection类概述"><a href="#二-Connection类概述" class="headerlink" title="二 Connection类概述"></a>二 Connection类概述</h2><p>Connection类根据要访问的数据和访问方式不同，使用的命名空间也不同，类名也稍有区别，SqlConnection类中提供的常用属性和方法如下</p><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">SqlConnection()</td><td align="center">无参构造方法</td></tr><tr><td align="center">SqlConnection(string connectionstring)</td><td align="center">带参数的构造方法，数据库连接字符串作为参数</td></tr><tr><td align="center">Connectionstring</td><td align="center">属性，获取或设置数据库的连接串</td></tr><tr><td align="center">State</td><td align="center">属性，获取当前数据库的状态，由枚举类型 Connectionstate 为其提供值</td></tr><tr><td align="center">ConnectionTimeout</td><td align="center">属性，获取在尝试连接时终止尝试并生成错误之前所等待的时间</td></tr><tr><td align="center">DataSource</td><td align="center">属性，获取要连接的 SQL Server 的实例名</td></tr><tr><td align="center">Open()</td><td align="center">方法，打开一个数据库连接</td></tr><tr><td align="center">Close()</td><td align="center">方法，关闭数据库连接</td></tr><tr><td align="center">BeginTransaction()</td><td align="center">方法，开始一个数据库事务</td></tr></tbody></table><h2 id="三-使用-Connection-类连接数据库"><a href="#三-使用-Connection-类连接数据库" class="headerlink" title="三 使用 Connection 类连接数据库"></a>三 使用 Connection 类连接数据库</h2><p> 数据库连接串的书写方法有很多，这里介绍两种常用的方法 </p><h3 id="3-1-第1种方式"><a href="#3-1-第1种方式" class="headerlink" title="3.1 第1种方式"></a>3.1 第1种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server &#x3D; 服务器名称 &#x2F; 数据库的实例名 ; uid &#x3D; 登录名 ; pwd &#x3D; 密码 ; database &#x3D; 数据库名称</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>server：用于指定要访问数据库的数据库实例名，服务器名称可以换成IP地址或者数据库所在的计算机名称，如果访问的是本机数据库，则可以使用”.”来代替。例如连接的是本机的默认数据库，则可以写成”server=.”</li><li>uid：登录到指定SQL Server数据库实例的用户名，相当于以SQL Server身份验证方式登录数据库时使用的用户名，例如sa用户</li><li>pwd：与uid用户对应的密码</li><li>database：要访问数据库实例下的数据库名</li></ul><h3 id="3-2-第2种方式"><a href="#3-2-第2种方式" class="headerlink" title="3.2 第2种方式"></a>3.2 第2种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data Source &#x3D; 服务器名称 \ 数据库实例名 ; Initial Catalog &#x3D; 数据库名称 ; User ID &#x3D; 用户名 ; Password &#x3D; 密码</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Data Source：与第1种连接串写法中的database属性的写法一样，用于指定数据库所在的服务器名称和数据库实例名，如果连接的是本机的默认数据库实例，则写成”Data Source=.”的形式</li><li>Initial Catalog：与第1种连接串写法中的database属性的写法一样，用于指定在Data Source中数据库实例下的数据库名</li><li>User ID：与第1种连接串写法中的uid属性的写法一样，用于指定登录数据库的用户名</li><li>Password：与第 1 种连接串写法中的 pwd 属性的写法一样，用于指定 User ID 用户名所对应的密码。</li></ul><h2 id="四-连接相关操作"><a href="#四-连接相关操作" class="headerlink" title="四 连接相关操作"></a>四 连接相关操作</h2><p> 在完成了数据库连接串的编写后即可使用 SqlConnection 类与数据库连接，分以下 3 步完成 </p><h3 id="4-1-创建-SqlConnection-类的实例"><a href="#4-1-创建-SqlConnection-类的实例" class="headerlink" title="4.1  创建 SqlConnection 类的实例"></a>4.1  创建 SqlConnection 类的实例</h3><p> 对于 SqlConnection 类来说，上表中提供了两个构造方法，通常是使用带一个字符串参数的构造方法来设置数据库的连接串创建其实例，语句形式如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlConnection 连接对象名 &#x3D; new SqlConnection( 数据库连接串 );</span><br></pre></td></tr></table></figure><h3 id="4-2-打开数据库连接"><a href="#4-2-打开数据库连接" class="headerlink" title="4.2 打开数据库连接"></a>4.2 打开数据库连接</h3><p> 在创建 SqlConnection 连接类的实例后并没有连接上数据库，需要使用连接类的 Open 方法打开数据库的连接。</p><p>在使用 Open 方法打开数据库连接时，如果数据库的连接串不正确或者数据库的服务处于关闭状态，会出现打开数据库失败的相关异常，因此需要通过异常处理来处理异常。</p><p>打开数据库连接的语句形式如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接对象名.Open();</span><br></pre></td></tr></table></figure><h3 id="4-3-关闭数据库连接"><a href="#4-3-关闭数据库连接" class="headerlink" title="4.3 关闭数据库连接"></a>4.3 关闭数据库连接</h3><p>在对数据库的操作结束后要将数据库的连接断开，以节省数据库连接的资源。</p><p>关闭数据库连接的语句形式如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接对象名.Close();</span><br></pre></td></tr></table></figure><p> 如果在打开数据库连接时使用了异常处理，则将关闭数据库连接的语句放到异常处理的 finally 语句中，这样能保证无论是否发生了异常都将数据库连接断开，以释放资源 </p><p> 除了使用异常处理的方式释放资源外，还可以使用 using 的方式释放资源 。具体的语句如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using(SqlConnection 连接对象名 &#x3D; new SQLConnection( 数据库连接串 ))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;打开数据库连接</span><br><span class="line">    &#x2F;&#x2F;对数据库先关操作的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> using 关键字的用法主要有两个，一个是引用命名空间，一个是创建非托管资源对象。</p><p>在 .NET 平台上资源分为托管资源和非托管资源，托管资源是由 .NET 框架直接提供对其资源在内存中的管理，例如声明的变量；非托管资源则不能直接由 .NET 框架对其管理，需要使用代码来释放资源，例如数据库资源、操作系统资源等。 </p><h2 id="五-实例"><a href="#五-实例" class="headerlink" title="五 实例"></a>五 实例</h2><h3 id="5-1-实例一-创建与本机-SQL-Server-数据库的连接，并使用异常处理"><a href="#5-1-实例一-创建与本机-SQL-Server-数据库的连接，并使用异常处理" class="headerlink" title="5.1 实例一  创建与本机 SQL Server 数据库的连接，并使用异常处理"></a>5.1 实例一  创建与本机 SQL Server 数据库的连接，并使用异常处理</h3><h4 id="5-1-1-分析"><a href="#5-1-1-分析" class="headerlink" title="5.1.1 分析"></a>5.1.1 分析</h4><p> 连接 SQL Server 数据库时使用的用户名为 sa、密码为 pwdpwd，连接的数据库为test </p><h4 id="5-1-2-创建数据库test"><a href="#5-1-2-创建数据库test" class="headerlink" title="5.1.2 创建数据库test"></a>5.1.2 创建数据库test</h4><p>打开Microsoft SQL Server Management Studio，登录后，在数据库上右键，新建数据库并输入创建的数据库名称</p><p><img src="https://images.pgzxc.com/csharp-sql-server-create-tabe.gif" alt=""></p><h4 id="5-1-3-代码"><a href="#5-1-3-代码" class="headerlink" title="5.1.3 代码"></a>5.1.3 代码</h4><p> 创建 Windows 窗体应用程序，并在窗体上放置一个按钮 ，在按钮的单击事件中加入以下代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line"> &#123;</span><br><span class="line">   &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">   &#x2F;&#x2F;string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">   string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;Integrate Security &#x3D; True&quot;;</span><br><span class="line">   &#x2F;&#x2F;var connStr &#x3D; &quot;server&#x3D;.;uid&#x3D;sa;pwd&#x3D;root;database&#x3D;test&quot;;</span><br><span class="line">   &#x2F;&#x2F;创建SqlConnection的实例</span><br><span class="line">    SqlConnection conn &#x3D; null;</span><br><span class="line">    try</span><br><span class="line">      &#123;</span><br><span class="line">         conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">         conn.Open();</span><br><span class="line">         MessageBox.Show(&quot;数据库连接成功！&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">      catch (Exception ex)</span><br><span class="line">      &#123;</span><br><span class="line">           MessageBox.Show(&quot;数据库连接失败！&quot; + ex.Message);</span><br><span class="line">      &#125;</span><br><span class="line">      finally</span><br><span class="line">      &#123;</span><br><span class="line">         if (conn !&#x3D; null)</span><br><span class="line">         &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭数据库</span><br><span class="line">            conn.Close();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-4-效果图"><a href="#5-1-4-效果图" class="headerlink" title="5.1.4 效果图"></a>5.1.4 效果图</h4><p><img src="https://images.pgzxc.com/csharp-sql-server-connection-scucess.gif" alt=""></p><h3 id="5-2-实例二-在上一实例的基础上使用-using-关键字释放资源。"><a href="#5-2-实例二-在上一实例的基础上使用-using-关键字释放资源。" class="headerlink" title="5.2 实例二 在上一实例的基础上使用 using 关键字释放资源。"></a>5.2 实例二 在上一实例的基础上使用 using 关键字释放资源。</h3><h4 id="5-2-1-代码"><a href="#5-2-1-代码" class="headerlink" title="5.2.1 代码"></a>5.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">   &#x2F;&#x2F;string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">   &#x2F;&#x2F;string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;Integrate Security &#x3D; True&quot;;</span><br><span class="line">   var connStr &#x3D; &quot;server&#x3D;.;uid&#x3D;sa;pwd&#x3D;root;database&#x3D;test&quot;;</span><br><span class="line">   &#x2F;&#x2F;创建SqlConnection的实例</span><br><span class="line">          </span><br><span class="line">   try</span><br><span class="line">      &#123;</span><br><span class="line">         using (SqlConnection conn&#x3D;new SqlConnection(connStr))</span><br><span class="line">         conn.Open();</span><br><span class="line">         MessageBox.Show(&quot;数据库连接成功！&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception ex)</span><br><span class="line">       &#123;</span><br><span class="line">          MessageBox.Show(&quot;数据库连接失败！&quot; + ex.Message);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;C#语言中Connection类是ADO.NET组件连接数据库时第一个要使用的类，也是通过编程访问数据库的第一步。接下也来我们来了解一下Connection类中的常用属性和方法，以及如何连接SQL Server数据库&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——V7.1.1升级到V7.8.0</title>
    <link href="http://pgzxc.github.io/posts/6cce2103.html"/>
    <id>http://pgzxc.github.io/posts/6cce2103.html</id>
    <published>2020-08-12T13:52:31.000Z</published>
    <updated>2020-08-12T14:07:39.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>旧版本存在博客数量过多编译时间过长现象，且可能因为文件过多存在编译时出现<code>JavaScript heap out of memory</code>问题，故本次升级到最新稳定版(V7.8.0)</p><ul><li>cole主题</li><li>安装npm依赖最新检测工具</li><li>修改项目下的_config.yml(与v7.1.1相比)</li><li>修改themes/next下的主题</li></ul><a id="more"></a><h2 id="二-cole主题"><a href="#二-cole主题" class="headerlink" title="二 cole主题"></a>二 cole主题</h2><h2 id="一-cole主题"><a href="#一-cole主题" class="headerlink" title="一  cole主题"></a>一  cole主题</h2><ul><li><p>打开<a href="https://images.pgzxc.com/hexo-git-clone-v780.png">hexo-theme-next</a>网址，查看说明向导</p></li><li><p>打开博客目录，执行git clone指令<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p><p><img src="https://images.pgzxc.com/hexo-git-clone-v780.png" alt=""></p></li></ul><h2 id="三-安装npm依赖最新检测工具"><a href="#三-安装npm依赖最新检测工具" class="headerlink" title="三 安装npm依赖最新检测工具"></a>三 安装npm依赖最新检测工具</h2><ul><li><p>安装依赖工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure></li><li><p>查看最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu  </span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-ncu.png" alt=""></p></li><li><p>执行ncu -u进行升级，然后删除现有的node-modules，执行npm install安装新的依赖(由于hexo-renderer-marked 3.0.0版本有bug，使用2.0.0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-ncu-u.png" alt=""></p></li></ul><h2 id="四-修改项目下的-config-yml-与v7-1-1相比"><a href="#四-修改项目下的-config-yml-与v7-1-1相比" class="headerlink" title="四 修改项目下的_config.yml(与v7.1.1相比)"></a>四 修改项目下的_config.yml(与v7.1.1相比)</h2><h3 id="4-1-permalink-defaults"><a href="#4-1-permalink-defaults" class="headerlink" title="4.1 permalink_defaults"></a>4.1 permalink_defaults</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#add v7.8.0</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true </span><br><span class="line">  trailing_html: true </span><br></pre></td></tr></table></figure><h3 id="4-2-external-link"><a href="#4-2-external-link" class="headerlink" title="4.2 external_link"></a>4.2 external_link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#add v7.8.0</span><br><span class="line">external_link: </span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="4-3-hightlight、prismjs"><a href="#4-3-hightlight、prismjs" class="headerlink" title="4.3 hightlight、prismjs"></a>4.3 hightlight、prismjs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># add v7.8.0</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#39;&#39; </span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line">prismjs:  </span><br><span class="line">  enable: false</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="4-4-meta-generator"><a href="#4-4-meta-generator" class="headerlink" title="4.4 meta_generator"></a>4.4 meta_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta_generator: true  </span><br></pre></td></tr></table></figure><h3 id="4-5-updated-option"><a href="#4-5-updated-option" class="headerlink" title="4.5 updated_option"></a>4.5 updated_option</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updated_option: &#39;mtime&#39; </span><br></pre></td></tr></table></figure><h3 id="4-6-v7-1-1升级到v7-8-0后的默认效果"><a href="#4-6-v7-1-1升级到v7-8-0后的默认效果" class="headerlink" title="4.6 v7.1.1升级到v7.8.0后的默认效果"></a>4.6 v7.1.1升级到v7.8.0后的默认效果</h3><p><img src="https://images.pgzxc.com/hexo-update-v78-default.png" alt=""></p><h2 id="五-修改themes-next下的主题"><a href="#五-修改themes-next下的主题" class="headerlink" title="五 修改themes/next下的主题"></a>五 修改themes/next下的主题</h2><h3 id="5-1-config-yml"><a href="#5-1-config-yml" class="headerlink" title="5.1 _config.yml"></a>5.1 _config.yml</h3><h4 id="5-1-1-修改footer"><a href="#5-1-1-修改footer" class="headerlink" title="5.1.1 修改footer"></a>5.1.1 修改footer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  since: 2017 </span><br><span class="line">  icon:</span><br><span class="line">    name: heart </span><br><span class="line">    animated: false</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br><span class="line">  copyright: pgzxc   </span><br><span class="line">  powered: false</span><br></pre></td></tr></table></figure><h4 id="5-1-2-修改beian"><a href="#5-1-2-修改beian" class="headerlink" title="5.1.2 修改beian"></a>5.1.2 修改beian</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beian: </span><br><span class="line">    enable: true</span><br><span class="line">    icp: 京ICP备xxx</span><br><span class="line">    gongan_id:</span><br><span class="line">    gongan_num:</span><br><span class="line">    gongan_icon_url:</span><br></pre></td></tr></table></figure><h4 id="5-1-3-Schemes"><a href="#5-1-3-Schemes" class="headerlink" title="5.1.3 Schemes"></a>5.1.3 Schemes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><h4 id="5-1-4-menu"><a href="#5-1-4-menu" class="headerlink" title="5.1.4 menu"></a>5.1.4 menu</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu: </span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  comments: &#x2F;comments&#x2F; || fa fa-comments </span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true #modify 2020-08-12</span><br></pre></td></tr></table></figure><h4 id="5-1-5-avatar"><a href="#5-1-5-avatar" class="headerlink" title="5.1.5 avatar"></a>5.1.5 avatar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avatar: </span><br><span class="line">  url: &#x2F;https:&#x2F;&#x2F;images.pgzxc.com&#x2F;avatar.jpg</span><br><span class="line">  rounded: true</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure><h4 id="5-1-6-social"><a href="#5-1-6-social" class="headerlink" title="5.1.6 social"></a>5.1.6 social</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;PGzxc || fab fa-github</span><br><span class="line">  CSDN: http:&#x2F;&#x2F;blog.csdn.net&#x2F;calvin_zhou || fab fa-book</span><br><span class="line">  微博: http:&#x2F;&#x2F;weibo.com&#x2F;5582039920 || fab fa-weibo</span><br><span class="line">  简书: http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;c5cdcb4dc52b || fab fa-heartbeat</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure><h4 id="5-1-7-link"><a href="#5-1-7-link" class="headerlink" title="5.1.7 link"></a>5.1.7 link</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: 友情链接</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: inline</span><br><span class="line"></span><br><span class="line">links:</span><br><span class="line">  鸿洋: https:&#x2F;&#x2F;wanandroid.com&#x2F;</span><br></pre></td></tr></table></figure><h4 id="5-1-8-comment"><a href="#5-1-8-comment" class="headerlink" title="5.1.8 comment"></a>5.1.8 comment</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">livere_uid: MTAyMC8zMjQ1OC85Msxxx</span><br></pre></td></tr></table></figure><h4 id="5-1-9-leancloud-visitors"><a href="#5-1-9-leancloud-visitors" class="headerlink" title="5.1.9 leancloud_visitors"></a>5.1.9 leancloud_visitors</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors: </span><br><span class="line">  enable: false</span><br><span class="line">  app_id: xoStNXjq2xNoDRjTltoOztdq-gzGzoHsz</span><br><span class="line">  app_key: 6g89MPFNvTH2YHnKMAK1n1V8</span><br></pre></td></tr></table></figure><h4 id="5-1-10-busuanzi-count"><a href="#5-1-10-busuanzi-count" class="headerlink" title="5.1.10 busuanzi_count"></a>5.1.10 busuanzi_count</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure><h4 id="5-1-11-local-search"><a href="#5-1-11-local-search" class="headerlink" title="5.1.11 local_search"></a>5.1.11 local_search</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local_search: </span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  unescape: false</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure><h3 id="5-2-language-zh-CN-yml"><a href="#5-2-language-zh-CN-yml" class="headerlink" title="5.2 language/zh-CN.yml"></a>5.2 language/zh-CN.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:  </span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  comments: 留言板 #add 2020-08-12</span><br><span class="line">  schedule: 日程表</span><br><span class="line">  sitemap: 站点地图</span><br><span class="line">  commonweal: 公益 404</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;旧版本存在博客数量过多编译时间过长现象，且可能因为文件过多存在编译时出现&lt;code&gt;JavaScript heap out of memory&lt;/code&gt;问题，故本次升级到最新稳定版(V7.8.0)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cole主题&lt;/li&gt;
&lt;li&gt;安装npm依赖最新检测工具&lt;/li&gt;
&lt;li&gt;修改项目下的_config.yml(与v7.1.1相比)&lt;/li&gt;
&lt;li&gt;修改themes/next下的主题&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="http://pgzxc.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——SQL Server 2008无法连接错误(15.3)</title>
    <link href="http://pgzxc.github.io/posts/7264436a.html"/>
    <id>http://pgzxc.github.io/posts/7264436a.html</id>
    <published>2020-08-10T13:35:14.000Z</published>
    <updated>2020-08-10T13:36:27.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-现象"><a href="#一-现象" class="headerlink" title="一 现象"></a>一 现象</h2><p>打开Microsoft SQL Server Management Studio，连接服务器时，用户名和密码都正确，却显示连接服务器错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error:40-无法打开到SQL Server的连接(Microsoft SQL Server,错误2)</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://images.pgzxc.com/csharp-sql-server-login-error.png" alt=""></p><h2 id="二-解决办法"><a href="#二-解决办法" class="headerlink" title="二 解决办法"></a>二 解决办法</h2><h3 id="2-1-解决办法一"><a href="#2-1-解决办法一" class="headerlink" title="2.1 解决办法一"></a>2.1 解决办法一</h3><ul><li><p>右键计算机——&gt;管理，打开<code>计算机管理</code>，选择服务，找到<code>MSSQLSERVER</code>项</p><p><img src="https://images.pgzxc.com/csharp-sql-server-state-view.png" alt=""></p></li><li><p>双击<code>MSSQLSERVER</code>，设置启动类型为自动，并启动此选项</p><p><img src="https://images.pgzxc.com/csharp-sql-server-delegate-start-auto.png" alt=""></p></li></ul><h3 id="2-2-解决办法二"><a href="#2-2-解决办法二" class="headerlink" title="2.2 解决办法二"></a>2.2 解决办法二</h3><ul><li><p>在计算机程序中，找到<code>SQL Server配置管理器</code>，双击打开</p><p><img src="https://images.pgzxc.com/sql-server-config-manager.png" alt=""></p></li><li><p>找到SQL Server服务下的 SQL Server(MSSQLSERVEr)，将其启动</p><p><img src="https://images.pgzxc.com/sql-server-mssqlserver-start.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-现象&quot;&gt;&lt;a href=&quot;#一-现象&quot; class=&quot;headerlink&quot; title=&quot;一 现象&quot;&gt;&lt;/a&gt;一 现象&lt;/h2&gt;&lt;p&gt;打开Microsoft SQL Server Management Studio，连接服务器时，用户名和密码都正确，却显示连接服务器错误&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;error:40-无法打开到SQL Server的连接(Microsoft SQL Server,错误2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——SQL Server 2008R2 安装(15.2)</title>
    <link href="http://pgzxc.github.io/posts/483c6ba2.html"/>
    <id>http://pgzxc.github.io/posts/483c6ba2.html</id>
    <published>2020-08-10T13:32:34.000Z</published>
    <updated>2020-08-10T13:36:27.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>由于目前使用的电脑系统为windows 7 64位，官网提供的最新版本无法安装，故采用旧版本SQL Server进行安装，并演示以下内容</p><ul><li>软件的下载</li><li>软件的安装</li><li>软件的使用</li></ul><a id="more"></a><h2 id="二-软件下载"><a href="#二-软件下载" class="headerlink" title="二 软件下载"></a>二 软件下载</h2><ul><li><p>打开<a href="https://www.microsoft.com/en-us/download/details.aspx?id=30438">Microsoft® SQL Server® 2008 R2 SP2</a>官网地址，查看版本列表<br><img src="https://images.pgzxc.com/csharp-sql-server-2008-r2-webpage.png" alt=""></p></li><li><p>点击下载，从下载列中选择系统应的文件进行下载</p><p><img src="https://images.pgzxc.com/csharp-sql-server-x64-download.png" alt=""></p></li></ul><h2 id="三-软件安装"><a href="#三-软件安装" class="headerlink" title="三 软件安装"></a>三 软件安装</h2><ul><li><p>双击运行软件，弹出如图所示的安装界面<br><img src="https://images.pgzxc.com/csharp-sql-server-click-open.png" alt=""></p></li><li><p>选择<code>安装</code>选项卡对应的<code>全新安装或向现有安装添加功能</code><br><img src="https://images.pgzxc.com/csharp-sql-server-install-new.png" alt=""></p></li><li><p>在安装许可条例中，选择接受条款协议，点击下一步</p><p><img src="https://images.pgzxc.com/csharp-sql-server-install-agree.png" alt=""></p></li><li><p>安装程序支持文件<br><img src="https://images.pgzxc.com/csharp-sql-server-installing-support.png" alt=""></p></li><li><p>在功能选择页面，选择安装的功能组件和功能(默认全部)和安装位置，确认后，点击下一步<br> <img src="https://images.pgzxc.com/csharp-sql-server-install-position.png" alt=""></p></li><li><p>实例配置页面确认无需修改后，点击下一步</p><p><img src="https://images.pgzxc.com/csharp-sql-server-sql-config-default.png" alt=""></p></li><li><p>服务器配置页面检查服务器名称和启动类型</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-start-config.png" alt=""></p></li><li><p>数据库引擎配置(身份验证选择混合模式)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：sa</span><br><span class="line">密码：root</span><br></pre></td></tr></table></figure><p> <img src="https://images.pgzxc.com/csharp-sql-server-database-password.png" alt=""></p></li><li><p>Reporting Services配置，选择<code>安装本机模式默认配置</code></p><p> <img src="https://images.pgzxc.com/csharp-sql-server-reporting-service-config.png" alt=""></p></li><li><p>错误报告页面，根据需要选择是否发送错误报告</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-error-report.png" alt=""></p></li><li><p>显示安装进度</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-install-progress.png" alt=""></p></li><li><p>安装过程可能需要10-20分钟左右，出现 如图界面，安装完成</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-install-finished.png" alt=""></p></li></ul><h2 id="三-软件使用"><a href="#三-软件使用" class="headerlink" title="三 软件使用"></a>三 软件使用</h2><ul><li><p>在Windows启动栏中找到<code>SQL Server Management Studio</code>点击启动</p><p><img src="https://images.pgzxc.com/sql-server-management-studio-open.png" alt=""></p></li><li><p>在弹出的<code>连接到服务器窗口</code>中，选择身份验证方式，输入用户名和密码，点击<code>连接</code></p><p><img src="https://images.pgzxc.com/sql-server-connect-server-username-password.png" alt=""></p></li><li><p>连接成功后的视图</p><p><img src="https://images.pgzxc.com/sql-server-connected-success-view.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;由于目前使用的电脑系统为windows 7 64位，官网提供的最新版本无法安装，故采用旧版本SQL Server进行安装，并演示以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件的下载&lt;/li&gt;
&lt;li&gt;软件的安装&lt;/li&gt;
&lt;li&gt;软件的使用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——ADO.NET数据库操作及常用类概述(15.1)</title>
    <link href="http://pgzxc.github.io/posts/8f74b968.html"/>
    <id>http://pgzxc.github.io/posts/8f74b968.html</id>
    <published>2020-08-10T13:29:21.000Z</published>
    <updated>2020-08-10T13:36:27.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中ADO.NET是在ADO的基础上发展起来的，ADO(Active Data Object)是一个COM组件类库，用于访问数据库，而ADO.NET是在.NET平台上访问数据库的组件。</li><li>ADO.NET是以ODBC(Open Database Connectivity)技术的方式来访问数据库的一种技术</li></ul><a id="more"></a><h2 id="二-ADO-NET-中的常用命名空间"><a href="#二-ADO-NET-中的常用命名空间" class="headerlink" title="二  ADO.NET 中的常用命名空间"></a>二  ADO.NET 中的常用命名空间</h2><table><thead><tr><th align="center">命名空间</th><th align="center">数据库提供程序</th></tr></thead><tbody><tr><td align="center">System.Data.SqlClient</td><td align="center">Microsoft SQL Server</td></tr><tr><td align="center">System.Data.Odbc</td><td align="center">ODBC</td></tr><tr><td align="center">System.Data.OracleClient</td><td align="center">Oracle</td></tr><tr><td align="center">System.Data.OleDB</td><td align="center">OLE DB</td></tr></tbody></table><h2 id="三-数据库操作中常用的类"><a href="#三-数据库操作中常用的类" class="headerlink" title="三 数据库操作中常用的类"></a>三 数据库操作中常用的类</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul><li>在使用ADO.NET进行数据库操作时通常会用到5个类，分别是Connection类、Command类、DataReader类、DataAdapter类、DataSet类</li><li>在接下来的讲解中我们将以连接SQL Server为例介绍ADO.NET中的对象，引用的命名空间为System.Data.SqlClient</li><li>除了DataSet类以外，其他兑现的前面都加上Sql，即SqlConnection、SqlCommand、SqlDataReader、SqlDataAdapter</li></ul><h3 id="3-2-常用类介绍"><a href="#3-2-常用类介绍" class="headerlink" title="3.2  常用类介绍"></a>3.2  常用类介绍</h3><h4 id="3-2-1-Connection类"><a href="#3-2-1-Connection类" class="headerlink" title="3.2.1 Connection类"></a>3.2.1 Connection类</h4><ul><li>该类主要用于数据库中建议连接和断开连接的操作，并且能通过该类取当前数据库连接的状态</li><li>使用Connection类根据数据库的链接串能连接任意数据库，例如SQLServer、Oracle、MySQL等</li><li>但是在.NET平台下，由于提供了一个SQL Server数据库，并额外提供了一些操作菜单便于操作 ，所以推荐使用SQL Server数据库</li></ul><h4 id="3-2-2-Command类"><a href="#3-2-2-Command类" class="headerlink" title="3.2.2 Command类"></a>3.2.2 Command类</h4><ul><li>该类主要对数据库执行增加、删除、修改以及查询的操作</li><li>通过在Command类的对象中传入不同的SQL语句，并调用相应的方法来执行SQL语句</li></ul><h4 id="3-2-3-DataReader类"><a href="#3-2-3-DataReader类" class="headerlink" title="3.2.3 DataReader类"></a>3.2.3 DataReader类</h4><ul><li>该类用于读取从数据库中查询出来的数据，但在读取数据时能向前读不能向后读，并且不能修改该类对象中的值</li><li>在与数据库的链接中断时，该类对象中的值也随之被清除</li></ul><h4 id="3-2-4-DataAdapter类"><a href="#3-2-4-DataAdapter类" class="headerlink" title="3.2.4 DataAdapter类"></a>3.2.4 DataAdapter类</h4><ul><li>该类与DataSet联用，它主要用于将数据库的结果运送到DataSet中保存</li><li>DataAdapter可以看做是数控与DataSet的一个桥梁，不仅可以将数据库中的操作结果运送到DataSet中，也能将更改后的DataSet保存到数据库中</li></ul><h4 id="3-2-5-DataSet类"><a href="#3-2-5-DataSet类" class="headerlink" title="3.2.5 DataSet类"></a>3.2.5 DataSet类</h4><ul><li>该类与DataReader类似，都用于存放对数据库查询的结果</li><li>不同的是，DataSet类中的值不仅可以重复多次读取，还可以通过更改DataSet中的值更改数据库中的值</li><li>此外，DataSet类中的值在数据库断开连接的情况下依然可以保留原来的值</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中ADO.NET是在ADO的基础上发展起来的，ADO(Active Data Object)是一个COM组件类库，用于访问数据库，而ADO.NET是在.NET平台上访问数据库的组件。&lt;/li&gt;
&lt;li&gt;ADO.NET是以ODBC(Open Database Connectivity)技术的方式来访问数据库的一种技术&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——JavaScript heap out of memory</title>
    <link href="http://pgzxc.github.io/posts/3df1bea.html"/>
    <id>http://pgzxc.github.io/posts/3df1bea.html</id>
    <published>2020-08-06T13:34:42.000Z</published>
    <updated>2020-08-06T13:37:45.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>最近在写博客时，编译时经常出现错误，出现的错误提示信息为<code>JavaScript head out of memory</code>，刚开始认为是缓存过大引起的(博客占用空间已超过4G)，使用<code>hexo clean</code>指令和清除git缓存文件，问题依然存在</p><a id="more"></a><h2 id="二-现象"><a href="#二-现象" class="headerlink" title="二 现象"></a>二 现象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory</span><br><span class="line"> 1: 000000013FE1F04A v8::internal::GCIdleTimeHandler::GCIdleTimeHandler+5114</span><br><span class="line"> 2: 000000013FDFA0C6 node::MakeCallback+4518</span><br><span class="line"> 3: 000000013FDFAA30 node_module_register+2032</span><br><span class="line"> 4: 00000001400820EE v8::internal::FatalProcessOutOfMemory+846</span><br><span class="line"> 5: 000000014008201F v8::internal::FatalProcessOutOfMemory+639</span><br><span class="line"> 6: 00000001405A2BC4 v8::internal::Heap::MaxHeapGrowingFactor+9556</span><br><span class="line"> 7: 0000000140599C46 v8::internal::ScavengeJob::operator&#x3D;+24310</span><br><span class="line"> 8: 000000014059829C v8::internal::ScavengeJob::operator&#x3D;+17740</span><br><span class="line"> 9: 00000001405A0F87 v8::internal::Heap::MaxHeapGrowingFactor+2327</span><br><span class="line">10: 00000001405A1006 v8::internal::Heap::MaxHeapGrowingFactor+2454</span><br><span class="line">11: 000000014015CDB7 v8::internal::Factory::NewFillerObject+55</span><br><span class="line">12: 00000001401F2CC6 v8::internal::WasmJs::Install+29414</span><br><span class="line">13: 000001BEAF5DC5C1</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-error-heap-outof-memory.png" alt=""></p><h2 id="三-解决办法"><a href="#三-解决办法" class="headerlink" title="三 解决办法"></a>三 解决办法</h2><p> 在package.json文件的scripts中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;node --max_old_space_size&#x3D;4096 build&#x2F;dev-server.js&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;node --max_old_space_size&#x3D;4096 build&#x2F;build.js&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-script-space-size.png" alt=""></p><h2 id="四-结果"><a href="#四-结果" class="headerlink" title="四 结果"></a>四 结果</h2><p>执行<code>hexo g</code>编译项目，没有出现上述错误，执行<code>hexo s</code>运行项目，查看项目运行结果</p><p><img src="https://images.pgzxc.com/hexo-error-hexo-s.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;最近在写博客时，编译时经常出现错误，出现的错误提示信息为&lt;code&gt;JavaScript head out of memory&lt;/code&gt;，刚开始认为是缓存过大引起的(博客占用空间已超过4G)，使用&lt;code&gt;hexo clean&lt;/code&gt;指令和清除git缓存文件，问题依然存在&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Mutex(14.8)</title>
    <link href="http://pgzxc.github.io/posts/4999b511.html"/>
    <id>http://pgzxc.github.io/posts/4999b511.html</id>
    <published>2020-08-05T21:59:56.000Z</published>
    <updated>2020-08-05T22:00:50.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>C#中Mutex类也是用于线程同步操作的类，例如，当多个线程同时访问一个资源时保证一次只能有一个线程访问资源</li><li>在Mutex类中，WaitOne()方法用于等待资源被释放，ReleaseMutex()方法用于释放资源</li><li>WaitOne()方法在等待ReleaseMutex()方法执行结束后才会结束</li></ul><a id="more"></a><h2 id="二-实例-使用线程互斥实现每个车位每次只能停一辆车的功能"><a href="#二-实例-使用线程互斥实现每个车位每次只能停一辆车的功能" class="headerlink" title="二 实例    使用线程互斥实现每个车位每次只能停一辆车的功能 "></a>二 实例   <font size=5> 使用线程互斥实现每个车位每次只能停一辆车的功能 </font></h2><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a>2.1 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    private static Mutex mutex &#x3D; new Mutex();</span><br><span class="line">    public static void PakingSpace(object num)</span><br><span class="line">    &#123;</span><br><span class="line">        if (mutex.WaitOne())</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;车牌号&#123;0&#125;的车驶入！&quot;, num);</span><br><span class="line">                Thread.Sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;车牌号&#123;0&#125;的车离开！&quot;, num);</span><br><span class="line">                mutex.ReleaseMutex();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ParameterizedThreadStart ts &#x3D; new ParameterizedThreadStart(PakingSpace);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts);</span><br><span class="line">        t1.Start(&quot;冀A12345&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts);</span><br><span class="line">        t2.Start(&quot;京A00000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-结果"><a href="#2-2-结果" class="headerlink" title="2.2 结果"></a>2.2 结果</h3><p><img src="https://images.pgzxc.com/csharp-thread-mutex-console.png" alt=""></p><h3 id="2-3-说明"><a href="#2-3-说明" class="headerlink" title="2.3 说明"></a>2.3 说明</h3><p> 从上面的运行效果可以看出，每辆车驶入并离开后其他车才能占用停车位，即当一个线程占用资源时，其他线程是不使用该资源的 </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;C#中Mutex类也是用于线程同步操作的类，例如，当多个线程同时访问一个资源时保证一次只能有一个线程访问资源&lt;/li&gt;
&lt;li&gt;在Mutex类中，WaitOne()方法用于等待资源被释放，ReleaseMutex()方法用于释放资源&lt;/li&gt;
&lt;li&gt;WaitOne()方法在等待ReleaseMutex()方法执行结束后才会结束&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Monitor(14.7)</title>
    <link href="http://pgzxc.github.io/posts/a24642fb.html"/>
    <id>http://pgzxc.github.io/posts/a24642fb.html</id>
    <published>2020-08-05T21:58:16.000Z</published>
    <updated>2020-08-05T22:00:50.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在C#中Monitor类的命名空间是System.Threading，它的用法比lock的用法要复杂一些，但本质是一样的</p><a id="more"></a><h2 id="二-语法形式"><a href="#二-语法形式" class="headerlink" title="二 语法形式"></a>二 语法形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Monitor.Enter(object);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;临界区代码</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Exit(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这里，object的值与lock的值是一样的</li><li>简而言之，lock的写法是Monitor的一种简写</li></ul><h2 id="三-实例-将上一节C-lock实例中的-lock-关键字替换成-Monitor-类"><a href="#三-实例-将上一节C-lock实例中的-lock-关键字替换成-Monitor-类" class="headerlink" title="三  实例  将上一节C# lock实例中的 lock 关键字替换成 Monitor 类 "></a>三  实例 <font size=4> 将上一节C# lock实例中的 lock 关键字替换成 Monitor 类 </font></h2><h3 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        Monitor.Enter(this);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            Monitor.Exit(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void PrintOdd()</span><br><span class="line">    &#123;</span><br><span class="line">        Monitor.Enter(this);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 1; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            Monitor.Exit(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Program program &#x3D; new Program();</span><br><span class="line">        ThreadStart ts1 &#x3D; new ThreadStart(program.PrintOdd);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts1);</span><br><span class="line">        t1.Name &#x3D; &quot;打印奇数的线程&quot;;</span><br><span class="line">        t1.Start();</span><br><span class="line">        ThreadStart ts2 &#x3D; new ThreadStart(program.PrintEven);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts2);</span><br><span class="line">        t2.Name &#x3D; &quot;打印偶数的线程&quot;;</span><br><span class="line">        t2.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-效果"><a href="#3-2-效果" class="headerlink" title="3.2 效果"></a>3.2 效果</h3><p><img src="https://images.pgzxc.com/csharp-thread-monitor-console.png" alt=""></p><h3 id="3-3-说明"><a href="#3-3-说明" class="headerlink" title="3.3 说明"></a>3.3 说明</h3><ul><li><p>Monitor类的用法虽然比lock关键字复杂，但其能添加等待获得锁定的超时值，这样就不会无限期等待获得对象锁</p></li><li><p>使用TryEnter()方法可以给它传送一个超时值，决定等待获得对象锁的最常时间</p></li><li><p>使用TryEnter()方法设置获得对象锁的时间的代码如下， 该方法能在指定的毫秒数内结束线程，这样能避免线程之间的死锁现象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Monitor.TryEnter(object, 毫秒数 );</span><br></pre></td></tr></table></figure></li><li><p>此外，还能使用 Monitor 类中的 Wait() 方法让线程等待一定的时间，使用 Pulse() 方法通知处于等待状态的线程 </p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;在C#中Monitor类的命名空间是System.Threading，它的用法比lock的用法要复杂一些，但本质是一样的&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——lock(14.6)</title>
    <link href="http://pgzxc.github.io/posts/ef125cbc.html"/>
    <id>http://pgzxc.github.io/posts/ef125cbc.html</id>
    <published>2020-08-05T21:56:30.000Z</published>
    <updated>2020-08-05T22:00:50.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>虽然Sleep方法能控制线程的暂停时间，从而改变多个线程之间的先后顺序，但每次调用线程的结果是随机的</li><li>线程同步的方法是将线程资源共享，允许控制每次执行一个线程，并交替执行每个线程</li><li>在C#语言中实现线程同步可以使用lock关键字和Monitor类、Mutex类来解决</li><li>对于线程同步操作最简单的一种方式就是使用lock关键字，通过lock关键字能保证加锁的线程只有在执行完成后才能执行其他线程</li></ul><a id="more"></a><h2 id="二-lock语法形式"><a href="#二-lock语法形式" class="headerlink" title="二 lock语法形式"></a>二 lock语法形式</h2><h3 id="2-1-语法形式"><a href="#2-1-语法形式" class="headerlink" title="2.1 语法形式"></a>2.1 语法形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock(object)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;临界区代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-说明"><a href="#2-2-说明" class="headerlink" title="2.2 说明"></a>2.2 说明</h3><ul><li><p>这里lock后面通常是一个Object类型的值，也可以使用this关键字来表示</p></li><li><p>最好是在lock中使用私有的非静态或负变量或私有的静态成员变量，即使用private或private static修饰的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Object obj &#x3D; new Object();</span><br><span class="line">lock (obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;临界区代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-实例-创建控制台应用程序，使用-lock-关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程"><a href="#三-实例-创建控制台应用程序，使用-lock-关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程" class="headerlink" title="三 实例  创建控制台应用程序，使用 lock 关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程 "></a>三 实例 <font size=5> 创建控制台应用程序，使用 lock 关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程 </font></h2><h3 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        lock (this)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void PrintOdd()</span><br><span class="line">    &#123;</span><br><span class="line">        lock (this)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 1; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Program program &#x3D; new Program();</span><br><span class="line">        ThreadStart ts1 &#x3D; new ThreadStart(program.PrintOdd);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts1);</span><br><span class="line">        t1.Name &#x3D; &quot;打印奇数的线程&quot;;</span><br><span class="line">        t1.Start();</span><br><span class="line">        ThreadStart ts2 &#x3D; new ThreadStart(program.PrintEven);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts2);</span><br><span class="line">        t2.Name &#x3D; &quot;打印偶数的线程&quot;;</span><br><span class="line">        t2.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-效果"><a href="#3-2-效果" class="headerlink" title="3.2 效果"></a>3.2 效果</h3><p><img src="https://images.pgzxc.com/csharp-thread-print-lock.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虽然Sleep方法能控制线程的暂停时间，从而改变多个线程之间的先后顺序，但每次调用线程的结果是随机的&lt;/li&gt;
&lt;li&gt;线程同步的方法是将线程资源共享，允许控制每次执行一个线程，并交替执行每个线程&lt;/li&gt;
&lt;li&gt;在C#语言中实现线程同步可以使用lock关键字和Monitor类、Mutex类来解决&lt;/li&gt;
&lt;li&gt;对于线程同步操作最简单的一种方式就是使用lock关键字，通过lock关键字能保证加锁的线程只有在执行完成后才能执行其他线程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——ParameterizedThreadStart(14.4)</title>
    <link href="http://pgzxc.github.io/posts/ffc97c6c.html"/>
    <id>http://pgzxc.github.io/posts/ffc97c6c.html</id>
    <published>2020-08-05T21:54:59.000Z</published>
    <updated>2020-08-05T22:00:50.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在C#语言中使用ParameterizedThreadStart创建进程，首先需要创建ParameterizedThreadStart委托的实例，然后再创建Thread类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParameterizedThreadStart pts&#x3D;new ParameterizedThreadStart( 方法名 );</span><br><span class="line">Thread t&#x3D;new Thread(pts);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二-实例"><a href="#二-实例" class="headerlink" title="二 实例"></a>二 实例</h2><h3 id="2-1-实例一-创建一个方法输出0〜n的所有偶数，使用-ParameterizedThreadStart-委托调用该方法，并启动打印偶数的线程"><a href="#2-1-实例一-创建一个方法输出0〜n的所有偶数，使用-ParameterizedThreadStart-委托调用该方法，并启动打印偶数的线程" class="headerlink" title="2.1 实例一  创建一个方法输出0〜n的所有偶数，使用 ParameterizedThreadStart 委托调用该方法，并启动打印偶数的线程 "></a>2.1 实例一 <font size=5> 创建一个方法输出0〜n的所有偶数，使用 ParameterizedThreadStart 委托调用该方法，并启动打印偶数的线程 </font></h3><h4 id="2-1-1-代码"><a href="#2-1-1-代码" class="headerlink" title="2.1.1 代码"></a>2.1.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ParameterizedThreadStart pts &#x3D; new ParameterizedThreadStart(PrintEven);</span><br><span class="line">        Thread t &#x3D; new Thread(pts);</span><br><span class="line">        t.Start(10);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;打印0~n中的偶数</span><br><span class="line">    private static void PrintEven(Object n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;&#x3D;(int)n; i &#x3D; i + 2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-效果图"><a href="#2-1-2-效果图" class="headerlink" title="2.1.2 效果图"></a>2.1.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-parameterized-threadstart-even.png" alt=""></p><h4 id="2-1-3-说明"><a href="#2-1-3-说明" class="headerlink" title="2.1.3 说明"></a>2.1.3 说明</h4><ul><li>在使用ParameterizedThreadStart委托调用带参数的方法时，方法中的参数只能是object类型并且只能含有一个参数</li><li>在启动线程时要在线程的Start()方法中为委托的方法传递参数</li><li>如果需要通过ParameterizedThreadStart委托引用多个参数的方法，由于委托方法中的参数是object类型的，传递多个参数可以通过类的实例来实现</li></ul><h3 id="2-2-实例二-创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法"><a href="#2-2-实例二-创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法" class="headerlink" title="2.2 实例二  创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法 "></a>2.2 实例二 <font size=4> 创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法 </font></h3><h4 id="2-2-1-代码"><a href="#2-2-1-代码" class="headerlink" title="2.2.1 代码"></a>2.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ParameterizedThreadStart pts &#x3D; new ParameterizedThreadStart(PrintEven);</span><br><span class="line">        ParameterTest pt &#x3D; new ParameterTest(1, 10);</span><br><span class="line">        Thread t &#x3D; new Thread(pts);</span><br><span class="line">        t.Start(pt);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void PrintEven(Object n)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;判断n是否为ParameterTest 类的对象</span><br><span class="line">        if(n is ParameterTest)</span><br><span class="line">        &#123;</span><br><span class="line">            int beginNum &#x3D; ((ParameterTest)n).beginNum;</span><br><span class="line">            int endNum &#x3D; ((ParameterTest)n).endNum;</span><br><span class="line">            for(int i &#x3D; beginNum; i &lt;&#x3D; endNum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (i % 2 &#x3D;&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ParameterTest</span><br><span class="line">&#123;</span><br><span class="line">    public int beginNum;</span><br><span class="line">    public int endNum;</span><br><span class="line">    public ParameterTest(int a,int b)</span><br><span class="line">    &#123;</span><br><span class="line">        this.beginNum &#x3D; a;</span><br><span class="line">        this.endNum &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-效果图"><a href="#2-2-2-效果图" class="headerlink" title="2.2.2 效果图"></a>2.2.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-parameterized-threadstart-more-param.png" alt=""></p><h4 id="2-2-3-说明"><a href="#2-2-3-说明" class="headerlink" title="2.2.3 说明"></a>2.2.3 说明</h4><ul><li>运行该程序，在控制台上将输出 1〜10 的偶数，即2、4、6、8、10 </li><li>从代码可以看出，通过为 ParameterTest 类中的字段赋值，并将其通过线程的 Start 方法传递给委托引用的方法 PrintEven，即可实现在委托引用的方法中传递多个参数的操作 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;在C#语言中使用ParameterizedThreadStart创建进程，首先需要创建ParameterizedThreadStart委托的实例，然后再创建Thread类的实例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ParameterizedThreadStart pts&amp;#x3D;new ParameterizedThreadStart( 方法名 );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Thread t&amp;#x3D;new Thread(pts);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——ThreadStart(14.3)</title>
    <link href="http://pgzxc.github.io/posts/426c51be.html"/>
    <id>http://pgzxc.github.io/posts/426c51be.html</id>
    <published>2020-08-05T21:53:05.000Z</published>
    <updated>2020-08-05T22:00:50.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中使用线程时首先要创建线程，在使用Thread类的构造方法创建其实例时，需要用到ThreadStart委托或者ParameterizedThreadStart委托创建Thread类的实例</li><li>ThreadStart委托只能用于无返回值、无参数的方法，ParameterizedThreadStart委托则可以用于带参数的方法</li></ul><a id="more"></a><h2 id="二-创建过程"><a href="#二-创建过程" class="headerlink" title="二 创建过程"></a>二 创建过程</h2><p>使用ThreadStart创建线程首先需要创建ThreadStart委托的实例，然后再创建Thread类的实例。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadStart ts &#x3D; new ThreadStart( 方法名 );</span><br><span class="line">Thread t &#x3D; new Thread(ts);</span><br></pre></td></tr></table></figure><h2 id="三-实例"><a href="#三-实例" class="headerlink" title="三 实例"></a>三 实例</h2><h3 id="3-1-实例一-使用-ThreadStart-委托创建线程，并定义一个方法输出-0〜10-中所有的偶数"><a href="#3-1-实例一-使用-ThreadStart-委托创建线程，并定义一个方法输出-0〜10-中所有的偶数" class="headerlink" title="3.1 实例一  使用 ThreadStart 委托创建线程，并定义一个方法输出 0〜10 中所有的偶数 "></a>3.1 实例一 <font size=4> 使用 ThreadStart 委托创建线程，并定义一个方法输出 0〜10 中所有的偶数 </font></h3><h4 id="3-1-1-代码"><a href="#3-1-1-代码" class="headerlink" title="3.1.1 代码"></a>3.1.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadStart ts &#x3D; new ThreadStart(PrintEven);</span><br><span class="line">        Thread t &#x3D; new Thread(ts);</span><br><span class="line">        t.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义打印0~10中的偶数的方法</span><br><span class="line">    private static void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 10; i&#x3D;i+2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-效果"><a href="#3-1-2-效果" class="headerlink" title="3.1.2 效果"></a>3.1.2 效果</h4><p><img src="https://images.pgzxc.com/csharp-thread-start-evenum.png" alt=""></p><h4 id="3-1-3-说明"><a href="#3-1-3-说明" class="headerlink" title="3.1.3 说明"></a>3.1.3 说明</h4><p>从上面的运行效果可以看出，使用ThreadStart委托为PrintEvent方法创建了线程，通过线程的Start方法启动线程并调用了PrintEvent方法</p><h3 id="3-2-实例二-在上一实例的基础上添加一个打印-1〜10-中的奇数的方法，再分别使用两个-Thread-类的实例启动打印奇数和偶数的方法"><a href="#3-2-实例二-在上一实例的基础上添加一个打印-1〜10-中的奇数的方法，再分别使用两个-Thread-类的实例启动打印奇数和偶数的方法" class="headerlink" title="3.2 实例二  在上一实例的基础上添加一个打印 1〜10 中的奇数的方法，再分别使用两个 Thread 类的实例启动打印奇数和偶数的方法 "></a>3.2 实例二 <font size=5> 在上一实例的基础上添加一个打印 1〜10 中的奇数的方法，再分别使用两个 Thread 类的实例启动打印奇数和偶数的方法 </font></h3><h4 id="3-2-1-代码"><a href="#3-2-1-代码" class="headerlink" title="3.2.1 代码"></a>3.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadStart ts1 &#x3D; new ThreadStart(PrintEven);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts1);</span><br><span class="line">        ThreadStart ts2 &#x3D; new ThreadStart(PrintOdd);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts2);</span><br><span class="line">        t1.Start();</span><br><span class="line">        t2.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义打印0~10中的偶数的方法</span><br><span class="line">    private static void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 10; i&#x3D;i+2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义打印1~10 中的奇数的方法</span><br><span class="line">    public static void PrintOdd()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">        &#123;</span><br><span class="line">           Console.Write(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-效果"><a href="#3-2-2-效果" class="headerlink" title="3.2.2 效果"></a>3.2.2 效果</h4><p><img src="https://images.pgzxc.com/csharp-thread-print-eveandodd.png" alt=""></p><h4 id="3-2-3-说明"><a href="#3-2-3-说明" class="headerlink" title="3.2.3 说明"></a>3.2.3 说明</h4><ul><li>从上面的运行效果可以看出，两个线程分别打印了 1〜10 中的奇数和 0〜10 中的偶数，但并不是按照线程的调用顺序先打印出所有的偶数再打印奇数 </li><li>需要注意的是，由于没有对线程的执行顺序和操作做控制，所以运行该程序每次打印的值的顺序是不一样的 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中使用线程时首先要创建线程，在使用Thread类的构造方法创建其实例时，需要用到ThreadStart委托或者ParameterizedThreadStart委托创建Thread类的实例&lt;/li&gt;
&lt;li&gt;ThreadStart委托只能用于无返回值、无参数的方法，ParameterizedThreadStart委托则可以用于带参数的方法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Thread(14.2)</title>
    <link href="http://pgzxc.github.io/posts/81dbaacd.html"/>
    <id>http://pgzxc.github.io/posts/81dbaacd.html</id>
    <published>2020-08-05T21:51:44.000Z</published>
    <updated>2020-08-05T22:00:50.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中线程(Thread)是包含在进程中的，它位于System.Threading命名空间中</li><li>与线程有关的类同样也都在System.Threading命名空间中</li></ul><a id="more"></a><h2 id="二-主要的类"><a href="#二-主要的类" class="headerlink" title="二 主要的类"></a>二 主要的类</h2><table><thead><tr><th align="center">类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Thread</td><td align="center">在初始的应用程序中创建其他的线程</td></tr><tr><td align="center">ThreadState</td><td align="center">指定Thread的执行状态，包括开始、运行、挂起等</td></tr><tr><td align="center">ThreadPrioity</td><td align="center">线程在调度时的优先级枚举值，包括Highest、AboveNormal、BelowNormal、Lowest</td></tr><tr><td align="center">ThreadPool</td><td align="center">提供一个线程池，用于执行任务、发送工作项、处理异步I/O等操作</td></tr><tr><td align="center">Monitor</td><td align="center">提供同步访问对象的机制</td></tr><tr><td align="center">Mutex</td><td align="center">用于线程间同步的操作</td></tr><tr><td align="center">ThreadAbortException</td><td align="center">调用Thread类中的Abort方法时出现的异常</td></tr><tr><td align="center">ThreadStateException</td><td align="center">Thread处于对方法调用无效的ThreadState时出现的异常</td></tr></tbody></table><h2 id="三-属性和方法"><a href="#三-属性和方法" class="headerlink" title="三 属性和方法"></a>三 属性和方法</h2><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">Name</td><td align="center">属性，获取或设置线程的名称</td></tr><tr><td align="center">Priority</td><td align="center">属性，获取或设置线程的优先级</td></tr><tr><td align="center">ThreadState</td><td align="center">属性，获取线程当前的状态</td></tr><tr><td align="center">IsAlive</td><td align="center">属性，获取当前线程是否处于启动状态</td></tr><tr><td align="center">IsBackground</td><td align="center">属性，获取或设置值，表示该线程是否为后台线程</td></tr><tr><td align="center">CurrentThread</td><td align="center">属性，获取当前正在运行的线程</td></tr><tr><td align="center">Start()</td><td align="center">方法，启动线程</td></tr><tr><td align="center">Sleep(int millisecondsTImeout)</td><td align="center">方法，将当前线程暂停指定的毫秒数</td></tr><tr><td align="center">Suspend()</td><td align="center">方法，挂起当前线程(已经被弃用)</td></tr><tr><td align="center">Join()</td><td align="center">方法，阻塞调用线程，直到某个线程终止为止</td></tr><tr><td align="center">Interrupt()</td><td align="center">方法，中断当前线程</td></tr><tr><td align="center">Resume()</td><td align="center">方法，继续已经挂起的线程(已经被弃用)</td></tr><tr><td align="center">Abort()</td><td align="center">方法，终止线程</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中线程(Thread)是包含在进程中的，它位于System.Threading命名空间中&lt;/li&gt;
&lt;li&gt;与线程有关的类同样也都在System.Threading命名空间中&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Process(14.1)</title>
    <link href="http://pgzxc.github.io/posts/75f4f920.html"/>
    <id>http://pgzxc.github.io/posts/75f4f920.html</id>
    <published>2020-08-05T21:49:45.000Z</published>
    <updated>2020-08-05T22:00:50.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中进程类是指Process类，该类所在的命名空间是System.Diagnostics</li><li>Process类主要提供对本地和远程进程的访问，并提供对本地进程的启动、停止等操作</li></ul><a id="more"></a><h2 id="二-常用属性和方法"><a href="#二-常用属性和方法" class="headerlink" title="二 常用属性和方法"></a>二 常用属性和方法</h2><table><thead><tr><th align="center">属性或方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">MachineName</td><td align="center">属性，获取关联进程正在其上运行的计算机的名称</td></tr><tr><td align="center">Id</td><td align="center">属性，获取关联进程的唯一标识符</td></tr><tr><td align="center">ExitTime</td><td align="center">属性，获取该进程退出的时间</td></tr><tr><td align="center">ProcessName</td><td align="center">属性，获取该进程的名称</td></tr><tr><td align="center">StartTime</td><td align="center">属性，获取关联进程启动的时间</td></tr><tr><td align="center">Threads</td><td align="center">属性，获取在关联进程中运行的一组线程</td></tr><tr><td align="center">TotalProcessorTime</td><td align="center">属性，获取此进程的总的处理器时间</td></tr><tr><td align="center">UserProcessorTime</td><td align="center">属性，获取此进程的用户处理器时间</td></tr><tr><td align="center">Close()</td><td align="center">方法，释放与此组件关联的所有资源</td></tr><tr><td align="center">CloseMainWindow()</td><td align="center">方法，通过向进程的主窗口发送关闭消息来关闭拥有用户界面的进程</td></tr><tr><td align="center">Dispose()</td><td align="center">方法，释放由Component使用的所有资源</td></tr><tr><td align="center">GetCurrentProcess()</td><td align="center">方法，获取新的Process组件，并将其与当前活动的进程关联</td></tr><tr><td align="center">GetProcess()</td><td align="center">方法，为本地计算机上的每个进程创建一个新的Process组件</td></tr><tr><td align="center">GetProcess(String)</td><td align="center">方法，为指定计算机上的每个进程资源创建一个新的Process组件</td></tr><tr><td align="center">GetProcessesByName(String)</td><td align="center">方法，创建新的Process组件的数组，并将它们与本地计算机上 共享指定的进程名称的所有进程资源关联</td></tr><tr><td align="center">Kill()</td><td align="center">方法，立即停止关联的进程</td></tr><tr><td align="center">Start()</td><td align="center">方法，启动(或重用)此Process组件的Startinfo属性指定的进程资源，并将其余该组件关联</td></tr><tr><td align="center">Start(String)</td><td align="center">方法，通过指定文档或应用程序文件的名称来启动进程资源，并将资源与新的Process组件关联</td></tr></tbody></table><h2 id="三-操作进程"><a href="#三-操作进程" class="headerlink" title="三 操作进程"></a>三 操作进程</h2><ul><li>在实际应用中经常会用到获取本地的进程、启动进程、关闭进程等操作，下面分别以实际形式介绍其具体的操作方法</li><li>在获取当前操作系统中运行的进程时，如果要获取所有运行的进程的信息，可以使用表中的GetProcess()方法，如果要获取指定名称的进程可以使用GetProcessByName(String)方法</li></ul><h2 id="四-实例"><a href="#四-实例" class="headerlink" title="四 实例"></a>四 实例</h2><h3 id="4-1-实例一-创建-Windows-应用程序，在-RichTextBox-控件中显示所有当前系统中正在运行的进程"><a href="#4-1-实例一-创建-Windows-应用程序，在-RichTextBox-控件中显示所有当前系统中正在运行的进程" class="headerlink" title="4.1 实例一  创建 Windows 应用程序，在 RichTextBox 控件中显示所有当前系统中正在运行的进程 "></a>4.1 实例一 <font size=4> 创建 Windows 应用程序，在 RichTextBox 控件中显示所有当前系统中正在运行的进程 </font></h3><h4 id="4-1-1-代码"><a href="#4-1-1-代码" class="headerlink" title="4.1.1 代码"></a>4.1.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public partial class GetProcessesForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public GetProcessesForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;“查看所有进程”按钮的单击事件</span><br><span class="line">    private void btnOk_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Process[] processes &#x3D; Process.GetProcesses();</span><br><span class="line">        foreach(Process p in processes)</span><br><span class="line">        &#123;</span><br><span class="line">            richTextBox1.Text &#x3D; richTextBox1.Text + p.ProcessName + &quot;\r\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-效果"><a href="#4-1-2-效果" class="headerlink" title="4.1.2 效果"></a>4.1.2 效果</h4><p><img src="https://images.pgzxc.com/csharp-process-all-process.png" alt=""></p><h4 id="4-1-3-说明"><a href="#4-1-3-说明" class="headerlink" title="4.1.3 说明"></a>4.1.3 说明</h4><p>从上面的运行效果可以看出，已经将系统中运行的进程名称显示在RichTextBox中，由于在当前系统中运行的进程较多，所以需要滑动RichTextBox控件中的滚动条来查看， 我们可以观察当前任务管理器中的进程是否与下图中的进程相同 </p><h3 id="4-2-实例二-创建-Windows-应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程"><a href="#4-2-实例二-创建-Windows-应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程" class="headerlink" title="4.2 实例二  创建 Windows 应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程 "></a>4.2 实例二 <font size=5> 创建 Windows 应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程 </font></h3><h4 id="4-2-1-代码"><a href="#4-2-1-代码" class="headerlink" title="4.2.1 代码"></a>4.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public partial class ProcessForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public ProcessForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;“启动进程”按钮的单击事件</span><br><span class="line">    private void button1_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取进程名称</span><br><span class="line">        string ProcessName &#x3D; textBox1.Text;</span><br><span class="line">        &#x2F;&#x2F;创建Process 类的对象</span><br><span class="line">        Process p &#x3D; new Process();</span><br><span class="line">        &#x2F;&#x2F;设置进程名称</span><br><span class="line">        p.StartInfo.FileName &#x3D; ProcessName;</span><br><span class="line">        &#x2F;&#x2F;启动进程</span><br><span class="line">        p.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-效果图"><a href="#4-2-2-效果图" class="headerlink" title="4.2.2 效果图"></a>4.2.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-process-start-process-mspaint.png" alt=""></p><h4 id="4-2-3-说明"><a href="#4-2-3-说明" class="headerlink" title="4.2.3 说明"></a>4.2.3 说明</h4><p> 从上面的运行效果可以看出，在文本框中输入“画图”的进程名称，单击“启动进程” 按钮即可显示出画图进程的界面 </p><h3 id="4-3-创建-Windows-应用程序，在-ListBox-控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭"><a href="#4-3-创建-Windows-应用程序，在-ListBox-控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭" class="headerlink" title="4.3  创建 Windows 应用程序，在 ListBox 控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭 "></a>4.3 <font size=4> 创建 Windows 应用程序，在 ListBox 控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭 </font></h3><h4 id="4-3-1-代码"><a href="#4-3-1-代码" class="headerlink" title="4.3.1 代码"></a>4.3.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public partial class ListBoxForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public ListBoxForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;窗体加载事件</span><br><span class="line">    private void ListBoxForm_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取所有进程信息</span><br><span class="line">        Process[] processes &#x3D; Process.GetProcesses();</span><br><span class="line">        foreach(Process p in processes)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;将进程添加到ListBox中</span><br><span class="line">            lbProcess.Items.Add(p.ProcessName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&quot;停止进程&quot;命令的单击事件</span><br><span class="line">    private void 停止进程ToolStripMenuItem_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取进程名称</span><br><span class="line">        string ProcessName &#x3D; lbProcess.SelectedItem.ToString();</span><br><span class="line">        &#x2F;&#x2F;根据进程名称获取进程</span><br><span class="line">        Process[] processes &#x3D; Process.GetProcessesByName(ProcessName);</span><br><span class="line">        &#x2F;&#x2F;判断是否存在指定进程名称的进程</span><br><span class="line">        if (processes.Length &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                foreach(Process p in processes)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;判断进程是否处于运行状态</span><br><span class="line">                    if (!p.HasExited)</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#x2F;&#x2F;关闭进程</span><br><span class="line">                        p.Kill();</span><br><span class="line">                        MessageBox.Show(p.ProcessName + &quot;已关闭！&quot;);</span><br><span class="line">                        &#x2F;&#x2F;获取所有进程信息</span><br><span class="line">                        processes &#x3D; Process.GetProcesses();</span><br><span class="line">                        &#x2F;&#x2F;清空ListBox中的项</span><br><span class="line">                        lbProcess.Items.Clear();</span><br><span class="line">                        foreach(Process p1 in processes)</span><br><span class="line">                        &#123;</span><br><span class="line">                            &#x2F;&#x2F;将进程添加到ListBox中</span><br><span class="line">                            lbProcess.Items.Add(p1.ProcessName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(&quot;该进程无法关闭！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-效果图"><a href="#4-3-2-效果图" class="headerlink" title="4.3.2 效果图"></a>4.3.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-process-kill-notepad.png" alt=""></p><h4 id="4-3-3-说明"><a href="#4-3-3-说明" class="headerlink" title="4.3.3 说明"></a>4.3.3 说明</h4><ul><li>运行该程序，则记事本程序被关闭 </li><li>需要注意的是，一些进程由于权限不够是无法关闭的，因此在关闭进程的代码中要做异常处理 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中进程类是指Process类，该类所在的命名空间是System.Diagnostics&lt;/li&gt;
&lt;li&gt;Process类主要提供对本地和远程进程的访问，并提供对本地进程的启动、停止等操作&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——程序调试(13.5)</title>
    <link href="http://pgzxc.github.io/posts/28c6dd.html"/>
    <id>http://pgzxc.github.io/posts/28c6dd.html</id>
    <published>2020-08-03T12:49:42.000Z</published>
    <updated>2020-08-03T12:51:03.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p> 在 C#语言中程序调试主要指在 Visual Studio 2019 中调试程序，包括设置断点、监视断点，以及逐语句、逐过程、使用一些辅助窗口来调试程序 </p><a id="more"></a><h2 id="二-常用功能"><a href="#二-常用功能" class="headerlink" title="二 常用功能"></a>二 常用功能</h2><h3 id="2-1-设置断点"><a href="#2-1-设置断点" class="headerlink" title="2.1 设置断点"></a>2.1 设置断点</h3><h4 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1 概念"></a>2.1.1 概念</h4><ul><li>所谓断点是程序自动进入中断模式的标记，即当程序运行到此处时自动中断。</li><li>在断点所在行的前面用红色的圆圈标记，设置标记时直接用鼠标单击需要设置断点的行前面的灰色区域即可，或者直接按键盘上的 F9 键 </li></ul><h4 id="2-1-2-操作"><a href="#2-1-2-操作" class="headerlink" title="2.1.2 操作"></a>2.1.2 操作</h4><ul><li><p>例如在程序中设置断点，效果如下图 </p><p><img src="https://images.pgzxc.com/csharp-break-point-set.png" alt=""></p></li><li><p>在设置断点时单击齿轮图标进入断点设置界面，如下图所示( 在该界面中允许为断点设置条件或操作，条件是指在满足指定条件时才会命中该断点 )</p><p><img src="https://images.pgzxc.com/csharp-break-point-set-view.png" alt=""></p></li><li><p>此外，每个断点也允许设置多个条件，每个条件之间的关系是“与”的关系。界面如下图所示<br>在设置条件时可以设置条件表达式、命中次数以及筛选器 , 其中： </p><ul><li>条件表达式是指一个布尔类型的表达式，如果满足条件则触发断点 </li><li>命中次数若满足指定次数，则触发断点 </li><li>筛选器用于限制只在某些进程和线程中设置断点 </li></ul><p><img src="https://images.pgzxc.com/csharp-break-point-set-or-relate.png" alt=""></p></li><li><p>在上图所示的界面中还可以为断点设置操作，用于指定在命中断点时打印追踪信息，界面如下图所示</p><p><img src="https://images.pgzxc.com/csharp-break-point-view-track.png" alt=""></p></li><li><p>在该界面中，如果在“将消息记录到输出窗口”文本框中输出断点“string[] str = new string<a href="https://images.pgzxc.com/csharp-break-point-str-right-key.png">5</a>;”处，其中 str 的值，则可以写成“str={str}”的形式，在调试输出窗口中会发现“str=Null”的信息输出。此外，右击断点，弹出的右键菜单如下图所示</p><p><img src="https://images.pgzxc.com/csharp-break-point-str-right-key.png" alt=""></p></li><li><p>在该菜单中选择“条件”或“操作”命令也可以完成对断点的上述设置</p></li></ul><h3 id="2-2-管理断点"><a href="#2-2-管理断点" class="headerlink" title="2.2 管理断点"></a>2.2 管理断点</h3><p> 在断点设置完成后，还可以在上图所示的菜单中选择进行“删除断点”“禁用断点”“编辑标签”“导出”的操作 , 其中： </p><ul><li>“删除断点”操作是取消当前断点，也可以再次单击断点的红点取消 </li><li>禁用断点”操作是指暂时跳过该断点，将断点设置为禁用状态后，断点的右键菜单中的“禁用断点”选项更改为“启用断点”，在需要该断点时还可以选择“启用断点”恢复断点； </li><li>“编辑标签” 操作是为断点设置名称；</li><li>“导出”操作是将断点信息导出到一个 XML 文件中存放 </li></ul><h3 id="2-3-程序的调试过程"><a href="#2-3-程序的调试过程" class="headerlink" title="2.3 程序的调试过程"></a>2.3 程序的调试过程</h3><ul><li><p>在设置好断点后，调试程序可以直接按 F5 键，或者直接在菜单栏中选择“调试”→“开始调试”命令 </p></li><li><p>在调试程序的过程中，可以直接使用工具栏上的调试快捷键，如下图所示，或者直接在菜单栏中选择所需的调试命令 </p><p><img src="https://images.pgzxc.com/csharp-debug-f5-progress.png" alt=""></p></li><li><p>下面介绍常用的调试命令</p><ul><li>逐语句（<img src="http://c.biancheng.net/uploads/allimg/190403/4-1Z403101S5T9.gif" alt="逐语句">）：按 F11 键也可以，用于逐条语句运行 </li><li>逐过程（<img src="http://c.biancheng.net/uploads/allimg/190403/4-1Z403101ZK27.gif" alt="逐过程">）：按 F10 键也可以，过程是指可以将方法作为一个整体去执行，不会跳进方法中执行。</li><li>跳出（<img src="http://c.biancheng.net/uploads/allimg/190403/4-1Z403101944544.gif" alt="跳出">）：按 Shift+F11 组合键也可以，跳出是将程序的调试状态结束，并结束整个程序 </li></ul></li><li><p>此外，在调试过程中右击，会出现如下图所示的右键菜单</p><p><img src="https://images.pgzxc.com/csharp-debug-right-keyboard.png" alt=""></p><h3 id="2-4-监视器"><a href="#2-4-监视器" class="headerlink" title="2.4 监视器"></a>2.4 监视器</h3></li><li><p>在调试程序的过程中经常需要知道某些变量的值在运行过程发生的变化，以便发现其在何时发生错误 </p></li><li><p>将程序中的变量或某个表达式放入监视器中即可监视其变化状态 </p></li><li><p>假设将 for 循环中的循环变量 i 加入监视器，在程序中右击变量 i，在弹出的如上图所示的菜单中选择“添加监视”命令，效果如下图所示 </p><p><img src="https://images.pgzxc.com/csharp-debug-monitor-i.png" alt=""></p></li><li><p>从上图中可以看出，在监视器界面的“名称”列中是变量名、“值”列中是当前变量 i 的值，“类型”列中是当前变量的数据类型</p></li><li><p>在一个监视器中可以设置多个需要监视的变量或表达式</p></li><li><p>对于监视器中不需要再监视的变量，可以右击该变量，在弹出的右键菜单中选择“删除监视”命令，如下图所示</p><p><img src="https://images.pgzxc.com/csharp-debug-monitor-delete-monotor.png" alt=""></p><h3 id="2-5-快速监视"><a href="#2-5-快速监视" class="headerlink" title="2.5 快速监视"></a>2.5 快速监视</h3></li><li><p>在调试程序时，如果需要监视变量或表达式的值也可以使用快速监视 </p></li><li><p>例如仍然要监视变量 i 的值，右击变量 i，在弹出的右键菜单中选择“快速监视”命令，弹出如下图所示的对话框</p><p><img src="https://images.pgzxc.com/csharp-monitor-quiclly.png" alt=""> </p></li><li><p>通常，快速监视用于查看变量当前值的状态，与直接加入监视不同的是快速监视一次只能监视一个变量</p></li><li><p>此外，在“快速监视”对话框处于打开状态时程序是无法继续调试的，如果需要继续监视“快速监视”对话框中的变量，可以单击“添加监视”按钮将当前监视的变量加入到监视器界面中 </p></li></ul><h3 id="2-6-即时窗口"><a href="#2-6-即时窗口" class="headerlink" title="2.6 即时窗口"></a>2.6 即时窗口</h3><ul><li><p>在调试程序时，如果需要对变量或表达式做相关运算，在即时窗口中都可以实现，并显示当前状态下变量或表达式的值 </p></li><li><p>在调试时可以使用“调试”菜单中“窗口”下的命令，在“调试”菜单中单击“窗口”出现如下图所示的子菜单<br><img src="https://images.pgzxc.com/csharp-debug-im-windows-right.png" alt=""></p></li><li><p>在其中选择“即时”命令即可出现即时窗口， 如下图所<br><img src="https://images.pgzxc.com/csharp-debug-im-windows.png" alt=""></p></li><li><p>在即时窗口中输入变量 i 的值并按回车键，即出现当前 i 在程序运行到此时的值</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt; 在 C#语言中程序调试主要指在 Visual Studio 2019 中调试程序，包括设置断点、监视断点，以及逐语句、逐过程、使用一些辅助窗口来调试程序 &lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
</feed>
