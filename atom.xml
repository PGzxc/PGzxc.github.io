<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PGzxc</title>
  
  <subtitle>纸上得来终觉浅 绝知此事要躬行</subtitle>
  <link href="https://pgzxc.github.io/atom.xml" rel="self"/>
  
  <link href="https://pgzxc.github.io/"/>
  <updated>2025-11-01T01:39:34.114Z</updated>
  <id>https://pgzxc.github.io/</id>
  
  <author>
    <name>PGzxc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMake开发之——导出与导入目标(6.5)</title>
    <link href="https://pgzxc.github.io/posts/72eff338.html"/>
    <id>https://pgzxc.github.io/posts/72eff338.html</id>
    <published>2025-11-01T01:18:23.000Z</published>
    <updated>2025-11-01T01:39:34.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文介绍：目标导出(export)与导入(import)机制，理解如何将库和目标在不同项目或包之间复用</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-概念"><a href="#二-概念" class="headerlink" title="二 概念"></a>二 概念</h2><h3 id="2-1-目标导出与导入的概念"><a href="#2-1-目标导出与导入的概念" class="headerlink" title="2.1 目标导出与导入的概念"></a>2.1 目标导出与导入的概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导出(export)：将当前项目的构建目标信息(包括编译选项、链接库等)导出到一个文件中，供其他项目使用。</span><br><span class="line"></span><br><span class="line">导入(import)：在另一个项目中通过导入文件，引用已导出的目标，实现复用。</span><br></pre></td></tr></table></figure><h3 id="2-2-为什么要导出-导入目标？"><a href="#2-2-为什么要导出-导入目标？" class="headerlink" title="2.2 为什么要导出&#x2F;导入目标？"></a>2.2 为什么要导出&#x2F;导入目标？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简化大型项目或多个项目间的依赖管理。</span><br><span class="line">方便通过 find_package() 找到并使用某个库。</span><br><span class="line">保持目标的编译属性一致。</span><br></pre></td></tr></table></figure><h2 id="三-基本用法示例"><a href="#三-基本用法示例" class="headerlink" title="三 基本用法示例"></a>三 基本用法示例</h2><h3 id="3-1-导出目标"><a href="#3-1-导出目标" class="headerlink" title="3.1 导出目标"></a>3.1 导出目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1、假设你的库项目 MyLib</span><br><span class="line">add_library(MyLib SHARED src/mylib.cpp)</span><br><span class="line"></span><br><span class="line"># 安装库和头文件</span><br><span class="line">install(TARGETS MyLib</span><br><span class="line">    EXPORT MyLibTargets           # 导出目标到 MyLibTargets</span><br><span class="line">    LIBRARY DESTINATION lib</span><br><span class="line">    ARCHIVE DESTINATION lib</span><br><span class="line">    RUNTIME DESTINATION bin</span><br><span class="line">    INCLUDES DESTINATION include</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(DIRECTORY include/ DESTINATION include)</span><br><span class="line"></span><br><span class="line"># 导出 targets 到文件</span><br><span class="line">install(EXPORT MyLibTargets</span><br><span class="line">    FILE MyLibTargets.cmake</span><br><span class="line">    NAMESPACE MyLib::</span><br><span class="line">    DESTINATION lib/cmake/MyLib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 生成配置文件方便 find_package 使用（简化示例）</span><br><span class="line">include(CMakePackageConfigHelpers)</span><br><span class="line">write_basic_package_version_file(</span><br><span class="line">    &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyLibConfigVersion.cmake&quot;</span><br><span class="line">    VERSION $&#123;PROJECT_VERSION&#125;</span><br><span class="line">    COMPATIBILITY AnyNewerVersion</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">configure_package_config_file(</span><br><span class="line">    &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake/MyLibConfig.cmake.in&quot;</span><br><span class="line">    &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyLibConfig.cmake&quot;</span><br><span class="line">    INSTALL_DESTINATION lib/cmake/MyLib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(FILES</span><br><span class="line">    &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyLibConfig.cmake&quot;</span><br><span class="line">    &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyLibConfigVersion.cmake&quot;</span><br><span class="line">    DESTINATION lib/cmake/MyLib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">2、说明</span><br><span class="line"> install(TARGETS ... EXPORT ...)：指定导出的目标集名称。</span><br><span class="line"> install(EXPORT ...)：将目标集导出成 .cmake 文件。</span><br><span class="line"> 配置 MyLibConfig.cmake 文件，供 find_package 使用</span><br></pre></td></tr></table></figure><h3 id="3-2-导入目标-在另一个项目中使用"><a href="#3-2-导入目标-在另一个项目中使用" class="headerlink" title="3.2 导入目标(在另一个项目中使用)"></a>3.2 导入目标(在另一个项目中使用)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、示例</span><br><span class="line">find_package(MyLib REQUIRED)</span><br><span class="line"></span><br><span class="line">add_executable(MyApp src/main.cpp)</span><br><span class="line">target_link_libraries(MyApp PRIVATE MyLib::MyLib)</span><br><span class="line"></span><br><span class="line">2、说明</span><br><span class="line">find_package 会找到导出的配置文件和目标。</span><br><span class="line">通过 MyLib::MyLib 使用导入的目标。</span><br></pre></td></tr></table></figure><h2 id="四-直接导入导出目标示例-简单用法"><a href="#四-直接导入导出目标示例-简单用法" class="headerlink" title="四 直接导入导出目标示例(简单用法)"></a>四 直接导入导出目标示例(简单用法)</h2><h3 id="4-1-导出-ProjectA"><a href="#4-1-导出-ProjectA" class="headerlink" title="4.1 导出(ProjectA)"></a>4.1 导出(ProjectA)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add_library(foo foo.cpp)</span><br><span class="line"></span><br><span class="line">install(TARGETS foo</span><br><span class="line">    EXPORT fooTargets</span><br><span class="line">    DESTINATION lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(EXPORT fooTargets</span><br><span class="line">    FILE fooTargets.cmake</span><br><span class="line">    DESTINATION lib/cmake/foo</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="4-2-导入-ProjectB"><a href="#4-2-导入-ProjectB" class="headerlink" title="4.2 导入(ProjectB)"></a>4.2 导入(ProjectB)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(path/to/ProjectA)</span><br><span class="line"></span><br><span class="line"># 或者导入导出文件</span><br><span class="line">include(path/to/ProjectA/lib/cmake/foo/fooTargets.cmake)</span><br><span class="line"></span><br><span class="line">add_executable(app main.cpp)</span><br><span class="line">target_link_libraries(app PRIVATE foo)</span><br></pre></td></tr></table></figure><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><table><thead><tr><th align="center">操作</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">install(TARGETS ... EXPORT ...)</td><td align="center">导出构建目标</td></tr><tr><td align="center">install(EXPORT ...)</td><td align="center">导出目标集到 <code>.cmake</code> 文件</td></tr><tr><td align="center">find_package()</td><td align="center">查找导出目标集</td></tr><tr><td align="center">target_link_libraries(... MyLib::MyLib)</td><td align="center">使用导入的目标</td></tr></tbody></table><h2 id="六-目标导出与导入流程图"><a href="#六-目标导出与导入流程图" class="headerlink" title="六 目标导出与导入流程图"></a>六 目标导出与导入流程图</h2><h3 id="6-1-流程图"><a href="#6-1-流程图" class="headerlink" title="6.1 流程图"></a>6.1 流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────┐</span><br><span class="line">│         项目 A (库项目)         │</span><br><span class="line">│ ┌───────────────────────────┐ │</span><br><span class="line">│ │ 1. 定义库目标 add_library() │ │</span><br><span class="line">│ └───────────────┬───────────┘ │</span><br><span class="line">│                 │             │</span><br><span class="line">│ ┌───────────────▼───────────┐ │</span><br><span class="line">│ │ 2. 安装库及头文件          │ │</span><br><span class="line">│ │ install(TARGETS ... EXPORT)│ │</span><br><span class="line">│ └───────────────┬───────────┘ │</span><br><span class="line">│                 │             │</span><br><span class="line">│ ┌───────────────▼───────────┐ │</span><br><span class="line">│ │ 3. 导出目标集 install(EXPORT)││</span><br><span class="line">│ └───────────────┬───────────┘ │</span><br><span class="line">│                 │             │</span><br><span class="line">│ ┌───────────────▼───────────┐ │</span><br><span class="line">│ │ 4. 生成配置文件 MyLibConfig│ │</span><br><span class="line">│ │    方便 find_package 使用  │ │</span><br><span class="line">│ └───────────────────────────┘ │</span><br><span class="line">└───────────────┬───────────────┘</span><br><span class="line">                │</span><br><span class="line">                │ 安装 / 共享 导出文件</span><br><span class="line">                ▼</span><br><span class="line">┌───────────────────────────────┐</span><br><span class="line">│         项目 B (使用项目)       │</span><br><span class="line">│ ┌───────────────────────────┐ │</span><br><span class="line">│ │ 1. find_package(MyLib)     │ │</span><br><span class="line">│ └───────────────┬───────────┘ │</span><br><span class="line">│                 │             │</span><br><span class="line">│ ┌───────────────▼───────────┐ │</span><br><span class="line">│ │ 2. 引入导入目标 MyLib::MyLib││</span><br><span class="line">│ │ target_link_libraries()    │ │</span><br><span class="line">│ └───────────────┬───────────┘ │</span><br><span class="line">│                 │             │</span><br><span class="line">│ ┌───────────────▼───────────┐ │</span><br><span class="line">│ │ 3. 编译链接应用程序         │ │</span><br><span class="line">│ └───────────────────────────┘ │</span><br><span class="line">└───────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="6-2-说明"><a href="#6-2-说明" class="headerlink" title="6.2 说明"></a>6.2 说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">项目 A 负责定义和导出库目标，并生成对应的配置文件。</span><br><span class="line">项目 B 通过 find_package 找到导出文件，导入目标，链接使用。</span><br><span class="line">这样保证库的属性和依赖能完整传递。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍：目标导出(export)与导入(import)机制，理解如何将库和目标在不同项目或包之间复用&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="T-构建" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/"/>
    
    <category term="Cmake" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/Cmake/"/>
    
    <category term="学习路线" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/Cmake/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
    <category term="Cmake" scheme="https://pgzxc.github.io/tags/Cmake/"/>
    
  </entry>
  
  <entry>
    <title>CMake开发之——配置头文件生成(6.4)</title>
    <link href="https://pgzxc.github.io/posts/b19247ca.html"/>
    <id>https://pgzxc.github.io/posts/b19247ca.html</id>
    <published>2025-10-31T01:15:05.000Z</published>
    <updated>2025-11-01T01:39:34.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文介绍：CMake 中配置头文件生成(configure_file)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-什么是configure-file？"><a href="#二-什么是configure-file？" class="headerlink" title="二 什么是configure_file？"></a>二 什么是configure_file？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configure_file() 是 CMake 提供的一个命令，</span><br><span class="line">用于将一个模板文件（通常是配置文件或头文件）复制到构建目录，并在复制过程中替换其中的变量。</span><br><span class="line"></span><br><span class="line">典型用途是根据 CMake 配置的变量生成对应的头文件，方便程序里引用配置参数</span><br></pre></td></tr></table></figure><h2 id="三-基本用法"><a href="#三-基本用法" class="headerlink" title="三 基本用法"></a>三 基本用法</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、假设你有一个模板头文件 config.h.in，内容示例</span><br><span class="line">#define PROJECT_NAME &quot;@PROJECT_NAME@&quot;</span><br><span class="line">#define PROJECT_VERSION &quot;@PROJECT_VERSION@&quot;</span><br><span class="line"></span><br><span class="line">2、在 CMakeLists.txt 中配置</span><br><span class="line">set(PROJECT_NAME &quot;MyProject&quot;)</span><br><span class="line">set(PROJECT_VERSION &quot;1.0.0&quot;)</span><br><span class="line"></span><br><span class="line">configure_file(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/config.h.in</span><br><span class="line">    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h</span><br><span class="line">    @ONLY</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">3、说明</span><br><span class="line">第一个参数是模板文件路径。</span><br><span class="line">第二个参数是输出文件路径（通常在构建目录）。</span><br><span class="line">@ONLY 表示只替换 @VAR@ 格式变量，不会替换 $&#123;VAR&#125;。</span><br></pre></td></tr></table></figure><h3 id="3-2-使用方式"><a href="#3-2-使用方式" class="headerlink" title="3.2 使用方式"></a>3.2 使用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、在代码中包含生成的头文件：</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">2、需要确保编译器的头文件搜索路径包含 $&#123;CMAKE_CURRENT_BINARY_DIR&#125;，</span><br><span class="line">通常在 CMakeLists.txt 里添加</span><br><span class="line"></span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_BINARY_DIR&#125;)</span><br><span class="line"></span><br><span class="line">3、或者（现代写法）</span><br><span class="line">target_include_directories(myapp PRIVATE $&#123;CMAKE_CURRENT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure><h2 id="四-示例"><a href="#四-示例" class="headerlink" title="四 示例"></a>四 示例</h2><h3 id="4-1-源代码"><a href="#4-1-源代码" class="headerlink" title="4.1 源代码"></a>4.1 源代码</h3><p>1、<code>config.h.in</code> 模板文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// config.h.in</span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#define PROJECT_NAME &quot;@PROJECT_NAME@&quot;</span><br><span class="line">#define PROJECT_VERSION &quot;@PROJECT_VERSION@&quot;</span><br></pre></td></tr></table></figure><p>2、<code>CMakeLists.txt</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line">project(MyProject VERSION 1.0.0)</span><br><span class="line"></span><br><span class="line"># 定义变量（也可以用 project 定义的变量）</span><br><span class="line">set(PROJECT_NAME &quot;MyProject&quot;)</span><br><span class="line">set(PROJECT_VERSION &quot;1.0.0&quot;)</span><br><span class="line"></span><br><span class="line"># 生成配置头文件</span><br><span class="line">configure_file(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/config.h.in</span><br><span class="line">    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/config.h</span><br><span class="line">    @ONLY</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 添加可执行文件</span><br><span class="line">add_executable(myapp main.cpp)</span><br><span class="line"></span><br><span class="line"># 指定包含路径为构建目录（生成的 config.h 所在）</span><br><span class="line">target_include_directories(myapp PRIVATE $&#123;CMAKE_CURRENT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure><p>3、<code>main.cpp</code> 示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Project Name: &quot; &lt;&lt; PROJECT_NAME &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Version: &quot; &lt;&lt; PROJECT_VERSION &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-构建和运行"><a href="#4-2-构建和运行" class="headerlink" title="4.2 构建和运行"></a>4.2 构建和运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br><span class="line">./myapp</span><br></pre></td></tr></table></figure><h3 id="4-3-运行结果"><a href="#4-3-运行结果" class="headerlink" title="4.3 运行结果"></a>4.3 运行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Project Name: MyProject</span><br><span class="line">Version: 1.0.0</span><br></pre></td></tr></table></figure><h2 id="五-注意事项"><a href="#五-注意事项" class="headerlink" title="五 注意事项"></a>五 注意事项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">模板文件里的变量必须用 @VAR@ 格式。</span><br><span class="line">使用 @ONLY 可以避免误替换。</span><br><span class="line">生成文件一般放在构建目录，避免污染源码目录。</span><br><span class="line">配合版本号、路径等配置信息自动生成头文件，方便代码读取。</span><br></pre></td></tr></table></figure><h2 id="六-工作流程图"><a href="#六-工作流程图" class="headerlink" title="六 工作流程图"></a>六 工作流程图</h2><h3 id="6-1-流程图"><a href="#6-1-流程图" class="headerlink" title="6.1 流程图"></a>6.1 流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────┐</span><br><span class="line">│       CMake 配置阶段         │</span><br><span class="line">│ - 读取 CMakeLists.txt        │</span><br><span class="line">│ - 识别 configure_file 命令  │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│   读取模板文件 config.h.in   │</span><br><span class="line">│ - 包含占位符变量 @VAR@       │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│ 替换模板中变量为当前值       │</span><br><span class="line">│ - 如 @PROJECT_NAME@ → MyProject│</span><br><span class="line">│ - 如 @PROJECT_VERSION@ → 1.0.0 │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│ 生成配置头文件 config.h       │</span><br><span class="line">│ - 输出到构建目录              │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│ 编译阶段                    │</span><br><span class="line">│ - 编译器查找包含目录         │</span><br><span class="line">│ - 代码中包含 config.h        │</span><br><span class="line">│ - 编译链接生成目标           │</span><br><span class="line">└─────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="6-2-简要说明"><a href="#6-2-简要说明" class="headerlink" title="6.2 简要说明"></a>6.2 简要说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure_file 在配置阶段执行，读取模板文件，替换变量，生成真正的配置头文件。</span><br><span class="line">生成的文件放在构建目录，避免污染源码。</span><br><span class="line">代码通过包含生成的头文件获得配置信息。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍：CMake 中配置头文件生成(configure_file)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="T-构建" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/"/>
    
    <category term="Cmake" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/Cmake/"/>
    
    <category term="学习路线" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/Cmake/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
    <category term="Cmake" scheme="https://pgzxc.github.io/tags/Cmake/"/>
    
  </entry>
  
  <entry>
    <title>CMake开发之——CPack打包(6.3)</title>
    <link href="https://pgzxc.github.io/posts/fc277fc0.html"/>
    <id>https://pgzxc.github.io/posts/fc277fc0.html</id>
    <published>2025-10-30T01:22:26.000Z</published>
    <updated>2025-11-01T01:39:34.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文介绍： CPack 打包工具的系统介绍，</span><br><span class="line">包括基本概念、配置方法、常用打包格式和示例，帮助你快速上手 CMake 内置的打包功能</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-什么是-CPack？"><a href="#二-什么是-CPack？" class="headerlink" title="二 什么是 CPack？"></a>二 什么是 CPack？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPack 是 CMake 附带的跨平台打包工具。</span><br><span class="line">它用于将编译出来的程序、资源等打包成安装包（Installer）、压缩包、RPM、DEB 等格式。</span><br><span class="line">支持 Windows MSI、NSIS、macOS pkg、Linux DEB/RPM、TGZ、ZIP 等多种格式。</span><br></pre></td></tr></table></figure><h2 id="三-启用-CPack"><a href="#三-启用-CPack" class="headerlink" title="三 启用 CPack"></a>三 启用 CPack</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、在 CMakeLists.txt 文件中添加</span><br><span class="line">include(CPack)</span><br><span class="line"></span><br><span class="line">2、通常放在项目末尾</span><br></pre></td></tr></table></figure><h2 id="四-基本配置示例"><a href="#四-基本配置示例" class="headerlink" title="四 基本配置示例"></a>四 基本配置示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set(CPACK_PACKAGE_NAME &quot;MyApp&quot;)</span><br><span class="line">set(CPACK_PACKAGE_VERSION &quot;1.0.0&quot;)</span><br><span class="line">set(CPACK_PACKAGE_VENDOR &quot;MyCompany&quot;)</span><br><span class="line">set(CPACK_PACKAGE_DESCRIPTION_SUMMARY &quot;My application description&quot;)</span><br><span class="line">set(CPACK_PACKAGE_CONTACT &quot;support@mycompany.com&quot;)</span><br><span class="line"></span><br><span class="line"># 安装目录（默认安装路径）</span><br><span class="line">set(CPACK_PACKAGE_INSTALL_DIRECTORY &quot;MyApp&quot;)</span><br><span class="line"></span><br><span class="line"># 指定生成的安装包类型（Windows 可用 NSIS/MSI，Linux 可用 TGZ/DEB/RPM 等）</span><br><span class="line">set(CPACK_GENERATOR &quot;ZIP;TGZ&quot;)</span><br><span class="line"></span><br><span class="line">include(CPack)</span><br></pre></td></tr></table></figure><h2 id="五-安装规则-安装目录结构"><a href="#五-安装规则-安装目录结构" class="headerlink" title="五 安装规则(安装目录结构)"></a>五 安装规则(安装目录结构)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、说明</span><br><span class="line">CPack 打包的是你通过 CMake 的 install() 指令定义好的内容，所以需要配合 install() 指令使用</span><br><span class="line"></span><br><span class="line">2、示例</span><br><span class="line">install(TARGETS myapp</span><br><span class="line">        RUNTIME DESTINATION bin)</span><br><span class="line"></span><br><span class="line">install(FILES README.md LICENSE</span><br><span class="line">        DESTINATION share/doc/myapp)</span><br></pre></td></tr></table></figure><h2 id="六-常用打包格式"><a href="#六-常用打包格式" class="headerlink" title="六 常用打包格式"></a>六 常用打包格式</h2><table><thead><tr><th align="center">平台</th><th align="center">格式示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Windows</td><td align="center">NSIS, MSI</td><td align="center">常用安装程序</td></tr><tr><td align="center">Linux</td><td align="center">DEB, RPM, TGZ</td><td align="center">Debian&#x2F;RedHat 包，压缩包</td></tr><tr><td align="center">macOS</td><td align="center">PKG, DragNDrop</td><td align="center">安装包或拖拽安装</td></tr><tr><td align="center">跨平台</td><td align="center">ZIP, TGZ</td><td align="center">普通压缩包</td></tr></tbody></table><h2 id="七-执行打包命令"><a href="#七-执行打包命令" class="headerlink" title="七 执行打包命令"></a>七 执行打包命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、指令</span><br><span class="line">cmake --build build --target package</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">make package</span><br><span class="line"></span><br><span class="line">2、结果</span><br><span class="line">会生成配置好的安装包</span><br></pre></td></tr></table></figure><h2 id="八-进阶示例-Windows-NSIS-打包"><a href="#八-进阶示例-Windows-NSIS-打包" class="headerlink" title="八 进阶示例(Windows NSIS 打包)"></a>八 进阶示例(Windows NSIS 打包)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(CPACK_GENERATOR &quot;NSIS&quot;)</span><br><span class="line">set(CPACK_NSIS_DISPLAY_NAME &quot;MyApp Installer&quot;)</span><br><span class="line">set(CPACK_NSIS_PACKAGE_NAME &quot;MyApp&quot;)</span><br><span class="line">set(CPACK_NSIS_CONTACT &quot;support@mycompany.com&quot;)</span><br><span class="line">set(CPACK_NSIS_URL_INFO_ABOUT &quot;https://mycompany.com&quot;)</span><br><span class="line"></span><br><span class="line">include(CPack)</span><br></pre></td></tr></table></figure><h2 id="九-小结"><a href="#九-小结" class="headerlink" title="九 小结"></a>九 小结</h2><table><thead><tr><th align="center">指令&#x2F;变量</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">install()</td><td align="center">定义打包要包含的文件或目标</td></tr><tr><td align="center">set(CPACK_XXX)</td><td align="center">配置包名、版本、作者、格式等</td></tr><tr><td align="center">include(CPack)</td><td align="center">启用 CPack</td></tr><tr><td align="center">cmake --build --target package</td><td align="center">生成安装包</td></tr></tbody></table><h2 id="十-打包流程图"><a href="#十-打包流程图" class="headerlink" title="十 打包流程图"></a>十 打包流程图</h2><h3 id="10-1-流程图"><a href="#10-1-流程图" class="headerlink" title="10.1 流程图"></a>10.1 流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────┐</span><br><span class="line">│         编写 CMakeLists.txt   │</span><br><span class="line">│  - 定义 install() 安装规则    │</span><br><span class="line">│  - 配置 CPACK_* 变量          │</span><br><span class="line">│  - include(CPack)             │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│       使用 CMake 编译项目      │</span><br><span class="line">│  - 生成构建文件               │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│        执行打包命令           │</span><br><span class="line">│  cmake --build . --target package │</span><br><span class="line">│  或 make package             │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│      CPack 根据配置生成安装包  │</span><br><span class="line">│  - ZIP, TGZ, NSIS, MSI, DEB等│</span><br><span class="line">│  - 包含 install() 指定内容    │</span><br><span class="line">└───────────────┬─────────────┘</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│        生成安装包文件         │</span><br><span class="line">│  - 位于构建目录              │</span><br><span class="line">│  - 可直接分发使用            │</span><br><span class="line">└─────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="10-2-流程说明"><a href="#10-2-流程说明" class="headerlink" title="10.2 流程说明"></a>10.2 流程说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编写 CMakeLists.txt：先定义好需要安装的文件和目标，配置好打包信息。</span><br><span class="line">编译项目：CMake 生成构建系统。</span><br><span class="line">执行打包命令：触发 CPack 执行打包流程。</span><br><span class="line">CPack 生成安装包：根据配置和安装规则制作对应格式的安装包。</span><br><span class="line">产物输出：安装包生成在构建目录下，方便后续分发。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍： CPack 打包工具的系统介绍，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;包括基本概念、配置方法、常用打包格式和示例，帮助你快速上手 CMake 内置的打包功能&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="T-构建" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/"/>
    
    <category term="Cmake" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/Cmake/"/>
    
    <category term="学习路线" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/T-%E6%9E%84%E5%BB%BA/Cmake/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
    <category term="Cmake" scheme="https://pgzxc.github.io/tags/Cmake/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——前沿与扩展(12)</title>
    <link href="https://pgzxc.github.io/posts/4858406c.html"/>
    <id>https://pgzxc.github.io/posts/4858406c.html</id>
    <published>2025-10-29T01:46:43.000Z</published>
    <updated>2025-11-01T01:39:34.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.微前端：qiankun(基于路由的微前端框架)、Module Federation(Webpack的模块联邦机制)</span><br><span class="line">2.React Server Components(RSC)</span><br><span class="line">3.WebAssembly 应用</span><br><span class="line">4.WebGPU 与 Three.js 可视化</span><br><span class="line">5.Edge Functions(边缘计算)</span><br><span class="line">6.AI 与前端结合：Chat UI、AI SDK 调用</span><br><span class="line">7.低代码平台：原理与实现</span><br><span class="line">8.跨端技术：React Native、Flutter、Taro、uni-app、Tauri、Electron</span><br><span class="line">9.发展趋势：大屏可视化、数据交互、Web3、AI 驱动前端</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-微前端"><a href="#3-1-微前端" class="headerlink" title="3.1 微前端"></a>3.1 微前端</h3><p>1、什么是微前端？解决了什么问题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">微前端将大型单体前端应用拆分为多个独立开发、部署、运行的子应用。</span><br><span class="line"></span><br><span class="line">2、解决的问题：</span><br><span class="line">-巨石应用痛点：代码维护复杂、协作效率低、技术栈升级困难。</span><br><span class="line">-团队自治：支持独立开发与部署，技术栈自由。</span><br><span class="line">-示例：蚂蚁金服的 Qiankun 支持 2000+ 应用集成。</span><br></pre></td></tr></table></figure><p>2、Qiankun 的核心原理与沙箱隔离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、原理：</span><br><span class="line">基于 single-spa，通过 HTML Entry 动态加载子应用，管理生命周期（bootstrap、mount、unmount）。</span><br><span class="line"></span><br><span class="line">2、沙箱隔离：</span><br><span class="line"> -JS 隔离：快照沙箱（复制全局状态，适合老应用）或 Proxy 沙箱（ES6 Proxy 劫持，隔离 window）。</span><br><span class="line"> -样式隔离：Scoped CSS 或 Shadow DOM 限制样式作用域。</span><br><span class="line">3、通信：全局状态（如 Redux）、postMessage 或自定义 EventBus。</span><br><span class="line">4、判断环境：子应用通过 window.__POWERED_BY_QIANKUN__ 检测运行环境。</span><br></pre></td></tr></table></figure><p>3、Module Federation 的作用与配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、定义：Webpack 5 的动态模块共享机制，支持运行时加载和复用模块。</span><br><span class="line"></span><br><span class="line">2、配置：</span><br><span class="line"></span><br><span class="line">// webpack.config.js</span><br><span class="line">const ModuleFederationPlugin = require(&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new ModuleFederationPlugin(&#123;</span><br><span class="line">      name: &#x27;app1&#x27;,</span><br><span class="line">      exposes: &#123; &#x27;./Button&#x27;: &#x27;./src/Button&#x27; &#125;,</span><br><span class="line">      remotes: &#123; app2: &#x27;app2@http://localhost:3001/remoteEntry.js&#x27; &#125;,</span><br><span class="line">      shared: &#123; react: &#123; singleton: true &#125; &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、优势：避免重复打包，共享依赖（如 React 单例）。</span><br><span class="line">4、问题解决：版本冲突通过 shared 配置统一依赖。</span><br></pre></td></tr></table></figure><p>4、Qiankun vs Module Federation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Qiankun：应用级集成，适合遗留系统，需改造子应用生命周期，跨技术栈兼容性强。</span><br><span class="line">Module Federation：模块级共享，运行时性能优，适合现代 JS 生态，技术栈需较统一。</span><br></pre></td></tr></table></figure><h3 id="3-2-RSC"><a href="#3-2-RSC" class="headerlink" title="3.2 RSC"></a>3.2 RSC</h3><p>1、RSC 是什么？与 SSR 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RSC：React 18+ 的服务器端组件，仅在服务端渲染，不发送到客户端，零 JS 开销，支持直接访问数据库或文件。</span><br><span class="line">SSR：服务端渲染完整 HTML，客户端需 Hydration 重渲染。</span><br></pre></td></tr></table></figure><p>2、与 SSR 的区别？</p><table><thead><tr><th align="center">特性</th><th align="center">RSC</th><th align="center">SSR</th></tr></thead><tbody><tr><td align="center">渲染位置</td><td align="center">服务端 + 客户端混合</td><td align="center">服务端渲染 HTML</td></tr><tr><td align="center">状态管理</td><td align="center">React 内置流式协议</td><td align="center">通常需要 Hydration</td></tr><tr><td align="center">JS 体积</td><td align="center">减少</td><td align="center">全量</td></tr></tbody></table><p>3、RSC 的实现与协作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现：文件名后缀 .server.js 标记 Server Component，.client.js 或 &#x27;use client&#x27; 标记 Client Component。</span><br><span class="line"></span><br><span class="line">// server.js</span><br><span class="line">async function ServerComp() &#123;</span><br><span class="line">  const data = await db.query();</span><br><span class="line">  return &lt;ClientComp data=&#123;data&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">协作：RSC 作为父组件通过 props 传递数据给 Client Component，Client Component 不可直接导入 RSC。</span><br><span class="line">优势：减少客户端 Bundle、支持流式渲染（Suspense）、SEO 友好。</span><br><span class="line">限制：无交互（useState/useEffect）、需异步、数据需序列化。</span><br></pre></td></tr></table></figure><h3 id="3-3-WebAssembly-应用"><a href="#3-3-WebAssembly-应用" class="headerlink" title="3.3 WebAssembly 应用"></a>3.3 WebAssembly 应用</h3><p>1、Wasm 是什么？优势与场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：低级字节码，编译自 C++/Rust，接近原生性能。</span><br><span class="line">优势：高性能（JIT 编译）、小体积（二进制）、安全（沙箱）。</span><br><span class="line">场景：游戏（Unity）、图像/视频处理（FFmpeg.wasm）、科学计算、AI 推理（ONNX Runtime Web）。</span><br></pre></td></tr></table></figure><p>2、Wasm如何与JS集成？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、加载：</span><br><span class="line">const wasm = await WebAssembly.instantiateStreaming(fetch(&#x27;module.wasm&#x27;), importObject);</span><br><span class="line">wasm.instance.exports.run();</span><br><span class="line"></span><br><span class="line">2、内存共享：通过 WebAssembly.Memory 实现 JS 与 Wasm 数据交互。</span><br><span class="line">3、关系：Wasm 专注计算密集任务，JS 负责 UI 和交互。</span><br></pre></td></tr></table></figure><h3 id="3-4-可视化"><a href="#3-4-可视化" class="headerlink" title="3.4 可视化"></a>3.4 可视化</h3><p>1、WebGPU是什么？与WebGL区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebGPU：新一代 GPU API，支持计算/图形管线，性能更高，接近 Vulkan/Metal。</span><br><span class="line">WebGL：基于 OpenGL ES，性能较低，管线灵活性差。</span><br><span class="line">优势：WebGPU 支持多线程、Compute Shader，调试更友好。</span><br></pre></td></tr></table></figure><p>2、如何用Three.js实现WebGPU可视化？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、实现：</span><br><span class="line"></span><br><span class="line">import * as THREE from &#x27;three/webgpu&#x27;;</span><br><span class="line">const renderer = new THREE.WebGPURenderer();</span><br><span class="line">renderer.render(scene, camera);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、优化：使用 Compute Shaders 处理粒子/纹理，HMR 支持，兼容 WebGL 回退。</span><br><span class="line">3、场景：3D 可视化、AR、游戏。</span><br></pre></td></tr></table></figure><p>3、大规模数据可视化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、优化：</span><br><span class="line">-Instancing 批量渲染。</span><br><span class="line">-Shader 在 GPU 执行复杂逻辑。</span><br><span class="line">-LOD（细节层次）动态加载模型。</span><br><span class="line">-内存管理：及时释放几何体/纹理。</span><br><span class="line"></span><br><span class="line">2、工具：ECharts GL、Deck.gl、Babylon.js。</span><br></pre></td></tr></table></figure><h3 id="3-5-边缘计算"><a href="#3-5-边缘计算" class="headerlink" title="3.5 边缘计算"></a>3.5 边缘计算</h3><p>1、Edge Functions是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：在 CDN 边缘节点（如 Vercel Edge Runtime）运行的无服务器函数，靠近用户。</span><br><span class="line">优势：低延迟（10-50ms）、全球分布、自动伸缩。</span><br><span class="line">场景：实时数据处理（IoT）、A/B 测试、个性化渲染。</span><br></pre></td></tr></table></figure><p>2、实现与限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、实现：</span><br><span class="line"></span><br><span class="line">// Next.js Edge Function</span><br><span class="line">export const runtime = &#x27;edge&#x27;;</span><br><span class="line">export async function GET(req) &#123;</span><br><span class="line">  return new Response(&#x27;Hello Edge&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、限制：无 Node.js API（如 fs）、资源有限（CPU/内存）、无持久状态。</span><br></pre></td></tr></table></figure><h3 id="3-7-AI-与前端结合"><a href="#3-7-AI-与前端结合" class="headerlink" title="3.7 AI 与前端结合"></a>3.7 AI 与前端结合</h3><p>1、AI Chat UI 实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、技术：Vercel AI SDK 的 useChat Hook，流式渲染（streamText）。</span><br><span class="line"></span><br><span class="line">import &#123; useChat &#125; from &#x27;ai/react&#x27;;</span><br><span class="line">const &#123; messages, input, handleInputChange, handleSubmit &#125; = useChat();</span><br><span class="line"></span><br><span class="line">2、持久化：通过 onFinish 回调保存消息到数据库，initialMessages 恢复。</span><br></pre></td></tr></table></figure><p>2、安全调用 AI SDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：API Key 需放在后端或 Edge Functions，前端通过接口间接调用。</span><br><span class="line">流式响应：使用 SSE/WebSocket + TextDecoder 实现“打字机”效果。</span><br></pre></td></tr></table></figure><p>3、应用方向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AI Copilot（代码生成、Figma 插件）。</span><br><span class="line">智能表单（自然语言生成 UI）。</span><br><span class="line">语音/图像交互（Web Speech、Vision API）。</span><br></pre></td></tr></table></figure><h3 id="3-7-低代码平台"><a href="#3-7-低代码平台" class="headerlink" title="3.7 低代码平台"></a>3.7 低代码平台</h3><p>1、核心原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、组成：</span><br><span class="line">-可视化编辑器：拖拽式组件树管理。</span><br><span class="line">-DSL（JSON Schema）：描述 UI 和逻辑。</span><br><span class="line">-渲染引擎：解析 Schema 动态生成 DOM。</span><br><span class="line">-插件机制：支持组件扩展。</span><br><span class="line"></span><br><span class="line">2、实现：</span><br><span class="line">如 amis，通过 Schema 递归渲染，事件绑定实现联动。</span><br></pre></td></tr></table></figure><p>2、优势与限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优势：快速开发、非码用户友好。</span><br><span class="line">限制：复杂逻辑需自定义 JS，递归渲染性能有限。</span><br><span class="line">跨框架：JSON Schema + 适配层（如 Vue createApp、React createElement）。</span><br></pre></td></tr></table></figure><h3 id="3-8-跨端技术"><a href="#3-8-跨端技术" class="headerlink" title="3.8 跨端技术"></a>3.8 跨端技术</h3><p>1、跨端技术对比</p><table><thead><tr><th align="center">技术</th><th align="center">原理</th><th align="center">优点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">React Native</td><td align="center">JS Bridge + 原生组件</td><td align="center">生态丰富、热重载</td><td align="center">移动端</td></tr><tr><td align="center">Flutter</td><td align="center">Dart + Skia 自绘</td><td align="center">高性能、一致性强</td><td align="center">跨平台</td></tr><tr><td align="center">Taro&#x2F;uni-app</td><td align="center">编译为小程序&#x2F;H5</td><td align="center">一套代码多端</td><td align="center">小程序</td></tr><tr><td align="center">Tauri</td><td align="center">Rust + WebView</td><td align="center">轻量、安全</td><td align="center">桌面端</td></tr><tr><td align="center">Electron</td><td align="center">Node.js + Chromium</td><td align="center">功能强大</td><td align="center">重桌面应用</td></tr></tbody></table><p>2、核心原理与挑战</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Taro/uni-app：DSL 编译为多端代码（如 WXML/AXML），条件编译适配平台差异。</span><br><span class="line">挑战：API 差异、桥接性能开销，需原生模块或条件编译解决。</span><br></pre></td></tr></table></figure><h3 id="3-9-发展趋势"><a href="#3-9-发展趋势" class="headerlink" title="3.9 发展趋势"></a>3.9 发展趋势</h3><p>1、大屏可视化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">技术：Three.js、ECharts GL、WebGPU、Cesium。</span><br><span class="line">优化：实时数据（WebSocket/SSE）、GPU 加速、响应式布局（vw/rem）。</span><br></pre></td></tr></table></figure><p>2、数据交互</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">趋势：从 REST 到 GraphQL/WebSocket，PWA 支持离线。</span><br><span class="line">BFF 模式：如 GraphQL、tRPC 优化后端接口。</span><br></pre></td></tr></table></figure><p>3、Web3前端集成？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">技术：ethers.js、Wagmi（钱包/合约交互）、IPFS（去中心化存储）。</span><br><span class="line">挑战：Gas 费用、签名复杂性。</span><br></pre></td></tr></table></figure><p>4、AI驱动前端？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、方向：</span><br><span class="line">-代码生成（Copilot）。</span><br><span class="line">-图稿转代码（设计稿生成组件）。</span><br><span class="line">-智能测试与 AIGC（内容生成）。</span><br><span class="line"></span><br><span class="line">2、趋势：</span><br><span class="line">RSC + AI 数据获取，自动化前端开发流程。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——性能与优化(11)</title>
    <link href="https://pgzxc.github.io/posts/466f4097.html"/>
    <id>https://pgzxc.github.io/posts/466f4097.html</id>
    <published>2025-10-29T01:06:33.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.首屏优化：SSR、预渲染、骨架屏、BigPipe</span><br><span class="line">2.图片优化：懒加载、WebP、雪碧图、CDN</span><br><span class="line">3.长列表优化：虚拟滚动</span><br><span class="line">4.Bundle 优化：Tree-shaking、Code splitting、按需加载</span><br><span class="line">5.指标监控：Web Vitals（LCP、FID、CLS）、Lighthouse</span><br><span class="line">6.内存优化：泄漏排查、闭包管理</span><br><span class="line">7.JS 优化：事件委托、节流防抖</span><br><span class="line">8.移动端优化：viewport、手势优化、多屏幕适配</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-首屏优化"><a href="#3-1-首屏优化" class="headerlink" title="3.1 首屏优化"></a>3.1 首屏优化</h3><h4 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h4><table><thead><tr><th align="center">技术</th><th align="center">定义</th><th align="center">优势</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">SSR</td><td align="center">服务端生成完整 HTML</td><td align="center">首屏快、SEO 友好</td><td align="center">服务器压力大</td><td align="center">动态内容页面</td></tr><tr><td align="center">预渲染</td><td align="center">构建时生成静态 HTML</td><td align="center">兼顾 SEO 和加载速度</td><td align="center">数据非实时</td><td align="center">静态页面(如营销页)</td></tr><tr><td align="center">骨架屏</td><td align="center">加载前展示占位 UI</td><td align="center">提升用户感知体验</td><td align="center">需额外开发</td><td align="center">内容加载慢的页面</td></tr><tr><td align="center">BigPipe</td><td align="center">分块传输和渲染页面</td><td align="center">优先渲染关键内容</td><td align="center">实现复杂</td><td align="center">复杂页面</td></tr></tbody></table><h4 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、SSR、预渲染、骨架屏、BigPipe 如何提升首屏性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SSR：服务端渲染 HTML，减少客户端 JS 解析时间，适合动态内容。</span><br><span class="line">预渲染：构建时生成静态 HTML，兼顾 SEO 和速度，适合固定内容。</span><br><span class="line">骨架屏：用占位 UI（如 CSS 动画或组件）减少等待焦虑，适合长加载页面。</span><br><span class="line">BigPipe：分块渲染，优先展示核心内容，降低 TTFB，适合复杂页面。</span><br><span class="line">总结：结合 SSR 和骨架屏可显著提升首屏体验，需配合缓存优化服务器压力。</span><br></pre></td></tr></table></figure><p>2、如何优化前端首屏加载速度？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 SSR（如 Next.js/Nuxt.js）或 预渲染（如 prerender-spa-plugin）加速首屏。</span><br><span class="line">引入 骨架屏（如 Ant Design Skeleton）提升感知体验。</span><br><span class="line">结合 BigPipe 分块加载和 CDN 加速静态资源。</span><br><span class="line">示例：Next.js 的 SSR + CDN 可将首屏时间缩短 30%-50%。</span><br></pre></td></tr></table></figure><h3 id="3-2-图片优化"><a href="#3-2-图片优化" class="headerlink" title="3.2 图片优化"></a>3.2 图片优化</h3><h4 id="技术对比-1"><a href="#技术对比-1" class="headerlink" title="技术对比"></a>技术对比</h4><table><thead><tr><th align="center">技术</th><th align="center">定义</th><th align="center">优势</th><th align="center">缺点</th><th align="center">实现方式</th></tr></thead><tbody><tr><td align="center">懒加载</td><td align="center">视口内加载图片</td><td align="center">减少首屏请求</td><td align="center">需兼容性处理</td><td align="center">loading&#x3D;&quot;lazy&quot; 或 IntersectionObserver</td></tr><tr><td align="center">WebP</td><td align="center">高压缩比图片格式</td><td align="center">体积小 20%-50%、支持透明</td><td align="center">需回退格式</td><td align="center">picture+ ImageMagick</td></tr><tr><td align="center">雪碧图</td><td align="center">合并小图为一张大图</td><td align="center">减少 HTTP 请求</td><td align="center">维护成本高</td><td align="center">CSS background-position</td></tr><tr><td align="center">CDN</td><td align="center">分布式服务器加速资源加载</td><td align="center">降低延迟、减轻服务器压力</td><td align="center">配置成本</td><td align="center">阿里云 OSS、AWS S3</td></tr></tbody></table><h4 id="高频面试题-1"><a href="#高频面试题-1" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、如何优化前端图片加载性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">懒加载：用 loading=&quot;lazy&quot; 或 IntersectionObserver 延迟非视口图片加载。</span><br><span class="line">WebP：转换图片为 WebP 格式，体积减小 20%-50%，用 &lt;picture&gt; 提供回退。</span><br><span class="line">雪碧图：合并小图标减少 HTTP 请求，现代可替换为 Icon Font/SVG。</span><br><span class="line">CDN：通过分布式服务器加速图片分发。</span><br><span class="line">示例：结合 WebP 和懒加载，图片加载时间可降低 30%-50%。</span><br></pre></td></tr></table></figure><p>2、懒加载、WebP、雪碧图、CDN 的具体实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">懒加载：&lt;img loading=&quot;lazy&quot;&gt; 或 IntersectionObserver 检测视口。</span><br><span class="line">WebP：用 ImageMagick 转换，&lt;picture&gt;&lt;source type=&quot;image/webp&quot;&gt; 兼容。</span><br><span class="line">雪碧图：用 Sprite Generator 合并，CSS 设置 background-position。</span><br><span class="line">CDN：托管到阿里云 OSS，配置域名加速。</span><br><span class="line">总结：HTTP/2 减弱雪碧图作用，WebP 和 CDN 是现代首选。</span><br></pre></td></tr></table></figure><h3 id="3-3-长列表优化"><a href="#3-3-长列表优化" class="headerlink" title="3.3 长列表优化"></a>3.3 长列表优化</h3><p>1、如何优化长列表渲染性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 虚拟滚动，仅渲染视口内列表项，动态加载/卸载 DOM，降低内存和渲染开销。结合节流优化滚动事件。</span><br><span class="line"></span><br><span class="line">实现：react-window、vue-virtual-scroll-list 或 IntersectionObserver 手动实现。</span><br><span class="line">示例：渲染万级数据时，虚拟滚动可将 DOM 节点数从数千降至几十，提升性能数倍。</span><br></pre></td></tr></table></figure><p>2、虚拟滚动的原理和实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理：监听滚动事件，计算视口范围，动态更新 DOM 节点，复用现有节点。</span><br><span class="line">实现：用 react-virtualized 或手动通过 IntersectionObserver + 动态 DOM 操作。</span><br><span class="line">优势：减少 DOM 数量，降低 Layout/Paint 开销，适合大数据列表。</span><br></pre></td></tr></table></figure><h3 id="3-4-Bundle-优化"><a href="#3-4-Bundle-优化" class="headerlink" title="3.4 Bundle 优化"></a>3.4 Bundle 优化</h3><h4 id="技术对比-2"><a href="#技术对比-2" class="headerlink" title="技术对比"></a>技术对比</h4><table><thead><tr><th align="center">技术</th><th align="center">定义</th><th align="center">优势</th><th align="center">实现方式</th></tr></thead><tbody><tr><td align="center">Tree-shaking</td><td align="center">移除未使用代码</td><td align="center">减小 Bundle 体积</td><td align="center">ESM + Webpack&#x2F;Rollup (mode: production)</td></tr><tr><td align="center">Code Splitting</td><td align="center">拆分代码为多个小块，按需加载</td><td align="center">减少首屏加载时间</td><td align="center">import() 或 SplitChunksPlugin</td></tr><tr><td align="center">按需加载</td><td align="center">仅加载当前页面所需模块</td><td align="center">避免加载冗余代码</td><td align="center">babel-plugin-import（如 AntD）</td></tr></tbody></table><h4 id="高频面试题-2"><a href="#高频面试题-2" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、如何减少前端代码包体积？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tree-shaking：用 ESM 移除死代码，配置 Webpack mode: production。</span><br><span class="line">Code Splitting：通过 import() 或 SplitChunksPlugin 实现动态加载。</span><br><span class="line">按需加载：用 babel-plugin-import 加载 Ant Design 等库的特定模块。</span><br><span class="line">示例：动态导入 + 按需加载可将 Bundle 体积减少 20%-40%。</span><br></pre></td></tr></table></figure><p>2、Tree-shaking、Code Splitting、按需加载的原理？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tree-shaking：基于 ESM 静态分析，移除未引用代码，需避免副作用代码。</span><br><span class="line">Code Splitting：拆分 Chunk，路由或动态 import() 按需加载。</span><br><span class="line">按需加载：仅导入所需模块（如 AntD Button），减少冗余代码。</span><br><span class="line">总结：结合使用可优化 TTI（交互时间）和首屏加载。</span><br></pre></td></tr></table></figure><h3 id="3-5-指标监控"><a href="#3-5-指标监控" class="headerlink" title="3.5 指标监控"></a>3.5 指标监控</h3><h4 id="核心指标对比"><a href="#核心指标对比" class="headerlink" title="核心指标对比"></a>核心指标对比</h4><table><thead><tr><th align="center">指标</th><th align="center">定义</th><th align="center">理想值</th><th align="center">改进方法</th></tr></thead><tbody><tr><td align="center">LCP</td><td align="center">最大内容绘制时间</td><td align="center">&lt; 2.5s</td><td align="center">SSR、CDN、优化资源加载</td></tr><tr><td align="center">FID</td><td align="center">首次输入延迟</td><td align="center">&lt; 100ms</td><td align="center">减少主线程阻塞、事件委托</td></tr><tr><td align="center">CLS</td><td align="center">累积布局偏移</td><td align="center">&lt; 0.1</td><td align="center">固定图片&#x2F;广告宽高</td></tr></tbody></table><h4 id="高频面试题-3"><a href="#高频面试题-3" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、如何监控和优化前端性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">监控：用 Web Vitals（LCP/FID/CLS）通过 web-vitals 包采集，Lighthouse 审计性能/SEO/可访问性。</span><br><span class="line">优化：SSR 加速 LCP，节流/防抖优化 FID，固定尺寸防 CLS，结合 CDN 和代码分割。</span><br><span class="line">示例：用 Lighthouse 检测后优化 LCP，可将加载时间降至 2s 内。</span><br></pre></td></tr></table></figure><p>2、Web Vitals 和 Lighthouse 的核心指标及改进？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、Web Vitals：</span><br><span class="line"> -LCP：优化服务器响应、CSS/JS 加载、CDN。</span><br><span class="line"> -FID：减少 JS 执行时间，用事件委托/节流。</span><br><span class="line"> -CLS：为图片/广告设固定宽高，避免异步偏移。</span><br><span class="line"></span><br><span class="line">2、Lighthouse：评估性能/SEO/可访问性，优化 TTI/TBT，关注 Web Vitals 评分。</span><br><span class="line">总结：结合 Chrome Performance API 和 Lighthouse 报告，针对性优化。</span><br></pre></td></tr></table></figure><h3 id="3-6-内存优化"><a href="#3-6-内存优化" class="headerlink" title="3.6 内存优化"></a>3.6 内存优化</h3><p>1、如何排查前端内存泄漏？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排查：用Chrome DevTools Memory面板，记录Heap Snapshot，分析对象引用；Performance 面板检查内存增长。</span><br><span class="line">常见原因：未移除事件监听器、定时器、DOM 引用、闭包长期持有变量。</span><br><span class="line">解决：用 removeEventListener 清理监听，clearInterval 清除定时器，React 中用 useEffect 清理函数。</span><br><span class="line">示例：检查未释放的 DOM 引用可定位内存泄漏。</span><br></pre></td></tr></table></figure><p>2、闭包如何影响内存及管理？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">影响：闭包保留外部变量引用，可能导致内存未释放。</span><br><span class="line">优化：避免不必要闭包，组件销毁时置空引用（如 variable = null 或 useEffect 清理）。</span><br><span class="line">示例：React useEffect 返回清理函数释放闭包引用，防止泄漏。</span><br></pre></td></tr></table></figure><h3 id="3-7-JS-优化"><a href="#3-7-JS-优化" class="headerlink" title="3.7 JS 优化"></a>3.7 JS 优化</h3><h4 id="技术对比-3"><a href="#技术对比-3" class="headerlink" title="技术对比"></a>技术对比</h4><table><thead><tr><th align="center">技术</th><th align="center">定义</th><th align="center">应用场景</th><th align="center">实现方式</th></tr></thead><tbody><tr><td align="center">事件委托</td><td align="center">父元素监听子元素事件</td><td align="center">动态列表、大量子元素</td><td align="center">addEventListener + event.target</td></tr><tr><td align="center">节流</td><td align="center">固定时间间隔执行一次</td><td align="center">滚动、resize</td><td align="center">时间戳或定时器</td></tr><tr><td align="center">防抖</td><td align="center">延迟执行，重复触发重新计时</td><td align="center">搜索输入、表单验证</td><td align="center">setTimeout + clearTimeout</td></tr></tbody></table><h4 id="高频面试题-4"><a href="#高频面试题-4" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、如何优化 JavaScript 性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事件委托：减少监听器，适合动态 DOM。</span><br><span class="line">节流：限制高频事件（如滚动）执行频率。</span><br><span class="line">防抖：合并多次触发（如搜索输入）为一次。</span><br><span class="line">示例：长列表滚动用事件委托 + 节流，性能提升显著。</span><br></pre></td></tr></table></figure><p>2、事件委托、节流、防抖的原理及场景？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事件委托：利用事件冒泡，父元素监听子元素事件，减少内存占用，适合动态列表。</span><br><span class="line">节流：每隔固定时间（如 100ms）执行一次，适合滚动/resize。</span><br><span class="line">防抖：延迟执行（如 300ms），适合搜索输入/表单验证。</span><br><span class="line">实现：委托用 event.target 判断，节流用时间戳，防抖用 setTimeout。</span><br></pre></td></tr></table></figure><h3 id="3-8-移动端优化"><a href="#3-8-移动端优化" class="headerlink" title="3.8 移动端优化"></a>3.8 移动端优化</h3><p>1、如何优化移动端前端性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Viewport：设置 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 确保正确缩放。</span><br><span class="line">手势优化：用 touchstart/touchmove + passive: true 提升滑动流畅度，移除 300ms 点击延迟（FastClick 或 user-scalable=no）。</span><br><span class="line">多屏适配：用 rem/vw + 媒体查询，结合 Tailwind CSS 实现响应式。</span><br><span class="line">示例：Hammer.js 优化滑动，Tailwind CSS 适配多屏。</span><br></pre></td></tr></table></figure><p>2、Viewport、手势优化、多屏幕适配的实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Viewport：&lt;meta name=&quot;viewport&quot;&gt; 控制缩放/布局。</span><br><span class="line">手势优化：用 touch 事件 + Hammer.js，passive: true 防阻塞，禁用缩放（user-scalable=no）。</span><br><span class="line">多屏适配：rem/vw 单位，@media 查询，srcset 自适应图片。</span><br><span class="line">总结：结合 Tailwind 和 srcset 实现高效适配。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——计算机基础与网络(10)</title>
    <link href="https://pgzxc.github.io/posts/e409c956.html"/>
    <id>https://pgzxc.github.io/posts/e409c956.html</id>
    <published>2025-10-28T01:50:22.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.协议：TCP vs UDP、三次握手/四次挥手</span><br><span class="line">2.DNS 解析流程</span><br><span class="line">3.CDN 原理与作用</span><br><span class="line">4.负载均衡：轮询、哈希、一致性哈希</span><br><span class="line">5.OSI 七层 vs TCP/IP 四层模型</span><br><span class="line">6.从输入 URL 到页面展示全过程</span><br><span class="line">7.API 设计：RESTful vs GraphQL</span><br><span class="line">8.实时通信：WebSocket</span><br><span class="line">9.HTTP：HTTP1.1/2/3 区别，HTTPS 原理(对称+非对称加密结合)</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-网络协议-TCP-vs-UDP"><a href="#3-1-网络协议-TCP-vs-UDP" class="headerlink" title="3.1 网络协议(TCP vs UDP)"></a>3.1 网络协议(TCP vs UDP)</h3><p>1、核心区别</p><table><thead><tr><th align="center">对比项</th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">连接性</td><td align="center">面向连接(需三次握手)</td><td align="center">无连接</td></tr><tr><td align="center">可靠性</td><td align="center">可靠(确认应答、超时重传、拥塞控制)</td><td align="center">不可靠(无确认、无序)</td></tr><tr><td align="center">速度</td><td align="center">较慢(因可靠性机制)</td><td align="center">较快(开销小)</td></tr><tr><td align="center">场景</td><td align="center">文件传输、HTTP、邮件</td><td align="center">视频通话、直播、DNS 查询</td></tr></tbody></table><p>2、TCP 三次握手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、SYN：客户端发送 SYN=1 请求建立连接。</span><br><span class="line">2、SYN+ACK：服务端响应确认并发回 SYN=1、ACK=1。</span><br><span class="line">3、ACK：客户端发送 ACK=1 确认，连接建立。</span><br><span class="line"></span><br><span class="line">目的：确保客户端与服务端的收发能力都可用。</span><br></pre></td></tr></table></figure><p>3、TCP 四次挥手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、客户端发送 FIN=1 表示不再发送数据。</span><br><span class="line">2、服务端 ACK=1 确认接收。</span><br><span class="line">3、服务端 FIN=1 表示服务端也要断开连接。</span><br><span class="line">4、客户端 ACK=1 确认断开。</span><br><span class="line"></span><br><span class="line">目的：确保双方完成数据传输并安全断开。</span><br></pre></td></tr></table></figure><h3 id="3-2-DNS-解析流程"><a href="#3-2-DNS-解析流程" class="headerlink" title="3.2 DNS 解析流程"></a>3.2 DNS 解析流程</h3><p>1、DNS 解析的完整流程是什么?(将域名解析为 IP 地址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、检查缓存：浏览器 → 系统 → 路由器 → ISP 本地 DNS 服务器。</span><br><span class="line">2、递归查询：本地 DNS 服务器向根域名服务器查询。</span><br><span class="line">3、迭代查询：</span><br><span class="line">-根服务器返回顶级域名服务器（.com/.org）地址。</span><br><span class="line">-顶级域名服务器返回权威域名服务器地址。</span><br><span class="line">-权威服务器返回目标 IP。</span><br><span class="line"></span><br><span class="line">4、返回结果：本地 DNS 缓存并返回 IP 给客户端。</span><br><span class="line"></span><br><span class="line">优化方法</span><br><span class="line">-使用 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt; 进行 DNS 预解析。</span><br><span class="line">-CDN 通过 CNAME 指向加速域名，提升解析效率。</span><br></pre></td></tr></table></figure><h3 id="3-3-CDN-原理与作用"><a href="#3-3-CDN-原理与作用" class="headerlink" title="3.3 CDN 原理与作用"></a>3.3 CDN 原理与作用</h3><p>1、CDN 原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过全球边缘节点缓存静态资源（如图片、CSS、JS），动态内容回源获取，DNS 智能路由引导用户至最近节点。</span><br></pre></td></tr></table></figure><p>2、CDN作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加速访问：降低延迟，提升用户体验。</span><br><span class="line">减轻源站压力：边缘节点分担请求。</span><br><span class="line">高可用性：多节点冗余避免单点故障。</span><br><span class="line">安全性：支持 DDoS 防护、HTTPS 加密。</span><br></pre></td></tr></table></figure><p>3、典型场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网站静态资源分发、视频流、软件下载。</span><br></pre></td></tr></table></figure><h3 id="3-4-负载均衡"><a href="#3-4-负载均衡" class="headerlink" title="3.4 负载均衡"></a>3.4 负载均衡</h3><p>1、常见算法</p><table><thead><tr><th align="center">算法</th><th align="center">原理</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">轮询</td><td align="center">按序分配请求</td><td align="center">简单，适合性能均衡服务器</td></tr><tr><td align="center">加权轮询</td><td align="center">按权重分配请求</td><td align="center">动态分配，考虑服务器性能</td></tr><tr><td align="center">IP 哈希</td><td align="center">基于 IP&#x2F;URL 哈希映射到服务器</td><td align="center">支持会话保持，增减服务器影响大</td></tr><tr><td align="center">一致性哈希</td><td align="center">映射到哈希环，顺时针分配</td><td align="center">节点变化影响小，适合分布式缓存</td></tr></tbody></table><p>2、其他算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小连接数：分配到当前连接最少的服务器。</span><br></pre></td></tr></table></figure><p>3、应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nginx upstream 模块实现负载均衡。</span><br><span class="line">Redis Cluster 使用一致性哈希分片。</span><br></pre></td></tr></table></figure><h3 id="3-5-OSI-七层-vs-TCP-IP-四层模型"><a href="#3-5-OSI-七层-vs-TCP-IP-四层模型" class="headerlink" title="3.5 OSI 七层 vs TCP&#x2F;IP 四层模型"></a>3.5 OSI 七层 vs TCP&#x2F;IP 四层模型</h3><p>1、对比</p><table><thead><tr><th align="center">层级</th><th align="center">OSI 七层模型</th><th align="center">TCP&#x2F;IP 四层模型</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">应用层</td><td align="center">应用层</td><td align="center">HTTP、FTP、DNS</td></tr><tr><td align="center">表示层</td><td align="center">表示层</td><td align="center"></td><td align="center">数据加密、压缩</td></tr><tr><td align="center">会话层</td><td align="center">会话层</td><td align="center"></td><td align="center">建立会话</td></tr><tr><td align="center">传输层</td><td align="center">传输层</td><td align="center">传输层</td><td align="center">TCP、UDP</td></tr><tr><td align="center">网络层</td><td align="center">网络层</td><td align="center">网络层</td><td align="center">IP、ICMP</td></tr><tr><td align="center">数据链路层</td><td align="center">数据链路层</td><td align="center">网络接口层</td><td align="center">以太网</td></tr><tr><td align="center">物理层</td><td align="center">物理层</td><td align="center">网络接口层</td><td align="center">光纤、电缆</td></tr></tbody></table><p>2、区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OSI：理论模型，层次细化，强调功能分离，常用于教学。</span><br><span class="line">TCP/IP：实践模型，层次简洁，广泛应用于互联网。</span><br></pre></td></tr></table></figure><h3 id="3-6-从输入-URL-到页面展示全过程"><a href="#3-6-从输入-URL-到页面展示全过程" class="headerlink" title="3.6 从输入 URL 到页面展示全过程"></a>3.6 从输入 URL 到页面展示全过程</h3><p>1、完整流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、URL 解析：提取协议、域名、路径等。</span><br><span class="line">2、DNS 解析：获取目标 IP。</span><br><span class="line">3、TCP 连接：三次握手建立连接。</span><br><span class="line">4、HTTP 请求：发送 GET/POST 请求，包含头、Cookies。</span><br><span class="line">5、服务器处理：处理逻辑，返回响应（HTML、JSON 等）。</span><br><span class="line">6、浏览器解析：</span><br><span class="line"> -解析 HTML 构建 DOM 树。</span><br><span class="line"> -解析 CSS 构建 CSSOM 树。</span><br><span class="line"> -合并生成渲染树（Render Tree）。</span><br><span class="line"></span><br><span class="line">7、页面渲染：</span><br><span class="line"> -布局（Layout）：计算元素位置。</span><br><span class="line"> -绘制（Painting）：生成像素。</span><br><span class="line"> -合成（Compositing）：组合图层显示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8、加载资源：下载图片、JS、CSS，可能触发重排/重绘。</span><br><span class="line">9、执行 JS：操作 DOM/CSSOM，动态更新页面。</span><br></pre></td></tr></table></figure><p>2、优化点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并行加载（预解析、预加载）。</span><br><span class="line">缓存（浏览器、CDN）。</span><br><span class="line">减少重排/重绘（优化 JS 和 CSS）。</span><br></pre></td></tr></table></figure><h3 id="3-7-API-设计"><a href="#3-7-API-设计" class="headerlink" title="3.7 API 设计"></a>3.7 API 设计</h3><p>1、对比项</p><table><thead><tr><th align="center">对比项</th><th align="center">RESTful</th><th align="center">GraphQL</th></tr></thead><tbody><tr><td align="center">请求方式</td><td align="center">GET&#x2F;POST&#x2F;PUT&#x2F;DELETE，多端点</td><td align="center">POST 单一端点(&#x2F;graphql)</td></tr><tr><td align="center">数据返回</td><td align="center">固定结构</td><td align="center">客户端定义字段</td></tr><tr><td align="center">优缺点</td><td align="center">简单、易缓存；易过&#x2F;不足获取</td><td align="center">灵活高效；实现复杂，缓存较难</td></tr><tr><td align="center">典型框架</td><td align="center">Express、NestJS、Spring REST</td><td align="center">Apollo、Hasura</td></tr></tbody></table><p>2、适用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RESTful：简单 CRUD 操作，标准化 API。</span><br><span class="line">GraphQL：复杂数据结构，前端需求多变。</span><br></pre></td></tr></table></figure><h3 id="3-8-实时通信"><a href="#3-8-实时通信" class="headerlink" title="3.8 实时通信"></a>3.8 实时通信</h3><p>1、WebSocket 原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于 TCP，通过 HTTP 握手（Upgrade: websocket）建立全双工连接，支持双向实时通信（ws:// 或 wss://）。</span><br></pre></td></tr></table></figure><p>2、特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低延迟，减少 HTTP 头部开销。</span><br><span class="line">支持文本和二进制数据。</span><br></pre></td></tr></table></figure><p>3、应用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实时聊天、在线游戏、协同编辑、数据推送（如股票行情）。</span><br></pre></td></tr></table></figure><p>4、与 HTTP 轮询对比</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">轮询：高延迟、开销大。</span><br><span class="line">WebSocket：持久连接，低延迟。</span><br></pre></td></tr></table></figure><p>5、替代方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSE（Server-Sent Events）：单向推送，适合简单场景。</span><br><span class="line">WebRTC：P2P 实时通信，适合音视频。</span><br></pre></td></tr></table></figure><h3 id="3-9-HTTP-及-HTTPS"><a href="#3-9-HTTP-及-HTTPS" class="headerlink" title="3.9 HTTP 及 HTTPS"></a>3.9 HTTP 及 HTTPS</h3><p>1、HTTP 版本对比</p><table><thead><tr><th align="center">特性</th><th align="center">HTTP&#x2F;1.1</th><th align="center">HTTP&#x2F;2</th><th align="center">HTTP&#x2F;3(基于 QUIC)</th></tr></thead><tbody><tr><td align="center">多路复用</td><td align="center">X(队头阻塞)</td><td align="center">✓(二进制帧)</td><td align="center">✓(UDP + 多路复用)</td></tr><tr><td align="center">头部压缩</td><td align="center">X</td><td align="center">✓(HPACK)</td><td align="center">✓(QPACK)</td></tr><tr><td align="center">连接复用</td><td align="center">X(需 Keep-Alive)</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">传输层</td><td align="center">TCP</td><td align="center">TCP</td><td align="center">UDP</td></tr></tbody></table><p>2、HTTPS 原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、组成：HTTP + SSL/TLS。</span><br><span class="line"></span><br><span class="line">2、流程：</span><br><span class="line">2-1、SSL/TLS 握手：</span><br><span class="line"> -客户端发送支持的加密算法。</span><br><span class="line"> -服务器返回 CA 签发的数字证书（含公钥）。</span><br><span class="line"> -客户端验证证书，协商对称密钥（AES）。</span><br><span class="line"> </span><br><span class="line">2-2、加密通信：</span><br><span class="line">使用对称加密传输数据，非对称加密（RSA/ECDHE）交换密钥。</span><br><span class="line"></span><br><span class="line">3、作用：</span><br><span class="line">确保数据加密、服务器认证，防止中间人攻击。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——后端与全栈(9)</title>
    <link href="https://pgzxc.github.io/posts/8ca562e0.html"/>
    <id>https://pgzxc.github.io/posts/8ca562e0.html</id>
    <published>2025-10-27T01:05:38.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Node.js 框架：Express、Koa、NestJS、HonoJS</span><br><span class="line">2.SSR/全栈框架：Next.js、Nuxt.js</span><br><span class="line">3.BFF 模式：Backend For Frontend</span><br><span class="line">4.模板引擎：Handlebars、Jade</span><br><span class="line">5.部署与运维：Nginx、CDN、Docker</span><br><span class="line">6.自动化：CI/CD 流程</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-Node-js-框架"><a href="#3-1-Node-js-框架" class="headerlink" title="3.1 .Node.js 框架"></a>3.1 .Node.js 框架</h3><h4 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h4><table><thead><tr><th align="center">框架</th><th align="center">主要特点</th><th align="center">优势</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">Express</td><td align="center">轻量、基于回调、丰富中间件</td><td align="center">生态成熟、上手快</td><td align="center">功能固定、异步处理稍弱</td><td align="center">快速开发、简单 API</td></tr><tr><td align="center">Koa</td><td align="center">模块化、async&#x2F;await、ctx 封装</td><td align="center">异步优雅、灵活性高</td><td align="center">无内置中间件、需手动组合</td><td align="center">现代化开发、复杂逻辑</td></tr><tr><td align="center">NestJS</td><td align="center">TypeScript、模块化、依赖注入</td><td align="center">结构清晰、适合企业级、支持微服务</td><td align="center">学习曲线陡、稍重</td><td align="center">中大型项目、类型安全需求</td></tr><tr><td align="center">HonoJS</td><td align="center">超轻量、边缘计算、跨平台</td><td align="center">高性能、无依赖、适合 Serverless</td><td align="center">生态较新、功能有限</td><td align="center">轻量 API、边缘计算</td></tr></tbody></table><h4 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、Express 和 Koa 的主要区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、Express：</span><br><span class="line">基于回调，内置中间件(如路由、HTTP 工具)，req/res 继承 Node.js 原生对象，生态成熟，适合快速开发。</span><br><span class="line"></span><br><span class="line">2、Koa：</span><br><span class="line">由 Express 团队开发，基于async/await，核心极简，ctx3、封装request/response，异步处理优雅，适合复杂逻辑。</span><br><span class="line"></span><br><span class="line">3、总结：</span><br><span class="line">Express 上手快，Koa 更现代、灵活。</span><br></pre></td></tr></table></figure><p>2、NestJS 的核心概念？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">受 Angular 启发，基于 TypeScript，</span><br><span class="line"></span><br><span class="line">核心包括：</span><br><span class="line">-模块（Module）：划分功能边界。</span><br><span class="line">-控制器（Controller）：处理请求/响应。</span><br><span class="line">-服务（Service）：业务逻辑，可注入。</span><br><span class="line">-其他：Pipe（验证）、Guard（权限）、Interceptor（拦截）。</span><br><span class="line">-适合中大型项目，支持微服务和 GraphQL，结构清晰。</span><br></pre></td></tr></table></figure><p>3、HonoJS 的优势及适用场景？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">超轻量（几十 KB），高性能，支持 Cloudflare Workers/Deno/Bun/Node.js，API 类似 Express/Koa。</span><br><span class="line">适合边缘计算、轻量 BFF 或高性能 API。</span><br></pre></td></tr></table></figure><p>4、Express 中间件与 Koa 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Express：通过 app.use() 按序处理请求（如日志、认证），基于回调。</span><br><span class="line">-Koa：中间件用 async/await，支持更灵活的请求/响应控制和错误处理。</span><br><span class="line">-总结：Koa 组合性更强，Express 简单直观。</span><br></pre></td></tr></table></figure><p>5、何时选择 NestJS 而非 HonoJS？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NestJS：适合复杂、类型安全的企业级应用，内置测试/验证，适合全栈开发。</span><br><span class="line">HonoJS：适合轻量、高性能 API，特别是在 Serverless 或边缘计算场景。</span><br></pre></td></tr></table></figure><h3 id="3-2-SSR-全栈框架"><a href="#3-2-SSR-全栈框架" class="headerlink" title="3.2 SSR&#x2F;全栈框架"></a>3.2 SSR&#x2F;全栈框架</h3><h4 id="渲染模式对比"><a href="#渲染模式对比" class="headerlink" title="渲染模式对比"></a>渲染模式对比</h4><table><thead><tr><th align="center">模式</th><th align="center">渲染时机</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">SSR</td><td align="center">服务器生成 HTML</td><td align="center">首屏快，利 SEO</td><td align="center">服务器压力大</td></tr><tr><td align="center">SSG</td><td align="center">构建时预渲染</td><td align="center">速度快、服务器负担轻</td><td align="center">数据非实时</td></tr><tr><td align="center">CSR</td><td align="center">浏览器加载后渲染</td><td align="center">动态交互强</td><td align="center">首屏慢、不利 SEO</td></tr><tr><td align="center">ISR</td><td align="center">定期增量更新静态页</td><td align="center">兼顾速度与实时性</td><td align="center">配置稍复杂</td></tr></tbody></table><h4 id="高频面试题-1"><a href="#高频面试题-1" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、Next.js 的 SSR 与 SSG 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-SSR：通过 getServerSideProps 动态渲染，适合个性化内容。</span><br><span class="line">-SSG：通过 getStaticProps 构建时预渲染，速度快，适合静态内容。</span><br><span class="line">-其他：getStaticPaths 处理动态路由，Next.js 13+ 的 App Router 使用Server Components减少客户端 JS。</span><br></pre></td></tr></table></figure><p>2、Nuxt.js 与 Next.js 相比如何？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Nuxt.js(Vue 基)：自动路由(基于文件结构)、内置模块(如 @nuxtjs/sitemap)、SSR/SSG 简单配置，适合Vue生态。</span><br><span class="line">-Next.js(React 基)：功能类似，但更灵活，App Router 优化性能，适合 React 开发者。</span><br><span class="line">-总结：Nuxt.js 配置更简单，Next.js 生态更强。</span><br></pre></td></tr></table></figure><p>3、Next.js 的数据获取策略？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-SSG：getStaticProps（构建时）。</span><br><span class="line">-SSR：getServerSideProps（请求时）。</span><br><span class="line">-CSR：useEffect 等 hooks（客户端）。</span><br><span class="line">-ISR：增量静态再生，定期更新。</span><br><span class="line">-App Router 强调 Server Components，提升效率。</span><br></pre></td></tr></table></figure><p>4、如何优化 Next.js&#x2F;Nuxt.js 的 SEO 和性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-SEO：Nuxt.js 自动元标签/站点地图，Next.js 用 &lt;Head&gt; 管理。</span><br><span class="line">-性能：用 ISR、代码分割、图片优化（Next.js Image 组件）、缓存，结合 Lighthouse 监控 SSR 开销。-</span><br></pre></td></tr></table></figure><h3 id="3-3-BFF-模式"><a href="#3-3-BFF-模式" class="headerlink" title="3.3 BFF 模式"></a>3.3 BFF 模式</h3><p>1、什么是 Backend for Frontend（BFF）？为何使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BFF 为每个前端（Web/App）定制后端，聚合微服务数据，适配 UI 需求。</span><br><span class="line"></span><br><span class="line">优势：减少过量数据获取，提升用户体验，解耦前后端。</span><br><span class="line">适用：多客户端（如 iOS/Web）需不同数据结构。</span><br></pre></td></tr></table></figure><p>2、BFF 与 API 网关的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">API 网关：集中路由和安全，服务所有客户端。</span><br><span class="line">BFF：针对特定客户端，处理数据编排/转换。</span><br><span class="line">总结：BFF 定制 UI 逻辑，网关负责共享功能（如认证）。</span><br></pre></td></tr></table></figure><p>3、BFF 的技术栈和实践要点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、技术栈：</span><br><span class="line">Node.js + Express/Koa/NestJS/Hono，GraphQL 或 gRPC/REST 混合。</span><br><span class="line"></span><br><span class="line">2、要点：</span><br><span class="line">-拦截/缓存（Redis）。</span><br><span class="line">-鉴权/安全（JWT/OAuth）。</span><br><span class="line">-接口聚合/防抖优化。</span><br><span class="line">-与前端类型联动（如 TypeScript DTO）。</span><br></pre></td></tr></table></figure><p>4、BFF 的挑战是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多 BFF 导致逻辑重复、维护成本高。</span><br><span class="line">可通过共享库或按体验类型用单一 BFF 缓解</span><br></pre></td></tr></table></figure><h3 id="3-4-模板引擎"><a href="#3-4-模板引擎" class="headerlink" title="3.4 模板引擎"></a>3.4 模板引擎</h3><h4 id="模板引擎对比"><a href="#模板引擎对比" class="headerlink" title="模板引擎对比"></a>模板引擎对比</h4><table><thead><tr><th align="center">引擎</th><th align="center">特点</th><th align="center">优势</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">Handlebars</td><td align="center">Mustache 语法，无逻辑模板</td><td align="center">安全（防 XSS）、易上手</td><td align="center">功能简单</td></tr><tr><td align="center">Pug (Jade)</td><td align="center">缩进语法、支持 mixin&#x2F;条件</td><td align="center">代码简洁、布局灵活</td><td align="center">缩进敏感、学习曲线</td></tr></tbody></table><h4 id="高频面试题-2"><a href="#高频面试题-2" class="headerlink" title="高频面试题"></a>高频面试题</h4><p>1、模板引擎的作用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态生成 HTML，结合数据与模板，常用于 SSR 场景（如 Express 渲染页面）。</span><br></pre></td></tr></table></figure><p>2、Handlebars 如何工作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 &#123;&#123;variable&#125;&#125; 语法，编译为函数插入数据，支持 helpers/partials，适合复用和安全性高的模板。</span><br></pre></td></tr></table></figure><p>3、Pug 与 Handlebars 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pug：缩进语法，代码简洁，支持 mixin/条件，适合复杂布局。</span><br><span class="line">Handlebars：基于标签，防 XSS 强，适合熟悉 HTML 的团队。</span><br><span class="line">总结：Pug 更简洁但缩进敏感，Handlebars 安全易用。</span><br></pre></td></tr></table></figure><p>4、如何在 Express 集成 Pug？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置 app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;)，</span><br><span class="line">用 res.render(&#x27;template&#x27;, &#123;data&#125;) 渲染，Pug 编译 .pug 文件为 HTML。</span><br></pre></td></tr></table></figure><h3 id="3-5-部署与运维"><a href="#3-5-部署与运维" class="headerlink" title="3.5 部署与运维"></a>3.5 部署与运维</h3><p>1、Nginx 如何作为 Node.js 反向代理？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nginx 处理静态文件、负载均衡、SSL，通过 upstream 代理动态请求到 Node.js，提升安全性和性能。</span><br><span class="line">用途：URL 重写、SPA history 模式、HTTPS 配置。</span><br></pre></td></tr></table></figure><p>2、CDN 在 Node.js 部署中的作用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全球缓存静态资源，降低延迟，减轻服务器压力。结合 Cloudflare 等服务，设置缓存头优化。</span><br></pre></td></tr></table></figure><p>3、如何容器化 Node.js 应用（Docker）？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dockerfile：FROM node, 复制代码，RUN npm install，CMD 启动。</span><br><span class="line">优化：多阶段构建减小镜像体积，确保跨环境一致性。</span><br></pre></td></tr></table></figure><p>4、如何用 Docker 和 Nginx 扩展 Node.js 应用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 Docker Compose 容器化，Nginx 实现负载均衡，结合 Kubernetes 自动扩展。</span><br></pre></td></tr></table></figure><h3 id="3-6-自动化"><a href="#3-6-自动化" class="headerlink" title="3.6 自动化"></a>3.6 自动化</h3><p>1、什么是 CI&#x2F;CD 流水线？为何使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CI（持续集成）：自动构建/测试代码。</span><br><span class="line">CD（持续部署/交付）：自动发布到测试/生产环境。</span><br><span class="line">好处：加快发布、减少错误、提高质量。</span><br></pre></td></tr></table></figure><p>2、Node.js 的典型 CI&#x2F;CD 流程？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码推送 → GitHub Actions/Jenkins 运行 lint/测试 → </span><br><span class="line">构建 Docker 镜像 → 通过测试后部署到 staging/production。</span><br><span class="line"></span><br><span class="line">测试用 Jest/Vitest。</span><br></pre></td></tr></table></figure><p>3、如何处理 CI&#x2F;CD 失败？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置通知（Slack/邮件）、回滚脚本、人工审批阶段，结合 Sentry 监控运行时错误。</span><br></pre></td></tr></table></figure><p>4、常用 CI&#x2F;CD 工具？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GitHub Actions：简单，与 GitHub 集成。</span><br><span class="line">Jenkins：高度可定制，适合复杂管道。</span><br><span class="line">CircleCI：速度快，易用。</span><br><span class="line">结合 Docker 实现容器化部署。</span><br></pre></td></tr></table></figure><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><table><thead><tr><th align="center">类别</th><th align="center">技术</th><th align="center">核心考点</th></tr></thead><tbody><tr><td align="center">Node.js 框架</td><td align="center">Express&#x2F;Koa&#x2F;Nest&#x2F;Hono</td><td align="center">中间件、依赖注入、异步模型、性能优化</td></tr><tr><td align="center">SSR 全栈框架</td><td align="center">Next.js &#x2F; Nuxt.js</td><td align="center">SSR&#x2F;SSG&#x2F;ISR、App Router、Nitro 引擎</td></tr><tr><td align="center">BFF</td><td align="center">Backend for Frontend</td><td align="center">数据聚合、多端适配、安全与性能</td></tr><tr><td align="center">模板引擎</td><td align="center">Handlebars &#x2F; Pug</td><td align="center">模板语法、渲染性能、安全性</td></tr><tr><td align="center">部署运维</td><td align="center">Nginx &#x2F; Docker &#x2F; CDN</td><td align="center">反向代理、容器化、缓存加速</td></tr><tr><td align="center">自动化(CI&#x2F;CD)</td><td align="center">GitHub Actions&#x2F;Jenkins</td><td align="center">构建&#x2F;测试&#x2F;部署、回滚与监控</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——工程化与工具链(8)</title>
    <link href="https://pgzxc.github.io/posts/486672a3.html"/>
    <id>https://pgzxc.github.io/posts/486672a3.html</id>
    <published>2025-10-26T01:21:45.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.构建工具：Webpack/Vite/Rollup/Gulp/Grunt/FIS</span><br><span class="line">2.优化手段：分包、代码分割、懒加载、Tree-shaking</span><br><span class="line">3.Monorepo管理：Nx、Lerna、pnpm workspace</span><br><span class="line">4.规范工具：ESLint、Prettier、Zod</span><br><span class="line">5.ORM/Schema：Prisma</span><br><span class="line">6.CI/CD：GitHub Actions、Jenkins、Vercel、Netlify</span><br><span class="line">7.前端监控：Sentry、自研埋点 SDK</span><br><span class="line">8.测试：Jest、Vitest、Cypress、Playwright、E2E 测试</span><br><span class="line">9.接口调试：Postman、Charles、Swagger</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-构建工具"><a href="#3-1-构建工具" class="headerlink" title="3.1 构建工具"></a>3.1 构建工具</h3><p>1、常见构建工具对比（Webpack、Vite、Rollup、Gulp、Grunt、FIS）</p><table><thead><tr><th align="center">工具</th><th align="center">主要功能</th><th align="center">优势</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">Webpack</td><td align="center">模块打包、Loader&#x2F;Plugin</td><td align="center">生态丰富、优化强大</td><td align="center">配置复杂、启动慢</td><td align="center">复杂应用</td></tr><tr><td align="center">Vite</td><td align="center">ESM 即时编译</td><td align="center">启动快、HMR 优秀</td><td align="center">生产依赖 Rollup</td><td align="center">现代开发</td></tr><tr><td align="center">Rollup</td><td align="center">ESM 打包、Tree Shaking</td><td align="center">输出小、简单</td><td align="center">插件少</td><td align="center">库发布</td></tr><tr><td align="center">Gulp</td><td align="center">流式任务自动化</td><td align="center">灵活、基于流</td><td align="center">需手动配置任务</td><td align="center">简单自动化</td></tr><tr><td align="center">Grunt</td><td align="center">任务运行器</td><td align="center">插件多</td><td align="center">配置繁琐、性能差</td><td align="center">早期项目</td></tr><tr><td align="center">FIS</td><td align="center">自动化构建、资源管理</td><td align="center">集成度高</td><td align="center">社区小、更新慢</td><td align="center">特定企业(如百度)</td></tr></tbody></table><p>2、Webpack 与 Grunt&#x2F;Gulp 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Webpack 是模块打包工具，专注于依赖图构建、代码转换和优化(如代码分割、Tree Shaking)；</span><br><span class="line">Grunt 和 Gulp 是任务运行器，用于自动化文件处理（如压缩、监听），不内置模块打包。</span><br><span class="line"></span><br><span class="line">Webpack 适合复杂应用，Grunt/Gulp 更简单，用于早期自动化。</span><br></pre></td></tr></table></figure><p>3、Webpack 的构建流程是怎样的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、Webpack 构建流程包括：</span><br><span class="line">初始化参数（从配置文件读取）、</span><br><span class="line">开始编译（创建 Compiler 对象）、</span><br><span class="line">确定入口（从 entry 开始解析依赖）、</span><br><span class="line">编译模块（使用 Loader 处理文件、Plugin 扩展功能）、</span><br><span class="line">完成编译（生成 Chunk 和 Bundle）、</span><br><span class="line">输出资源（写入文件系统）。</span><br><span class="line"></span><br><span class="line">2、这确保了模块依赖的正确处理。</span><br></pre></td></tr></table></figure><p>4、Vite 与 Webpack 的区别和优势？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vite 使用 ESBuild/Rollup 实现即时 HMR 和快速启动，无需预打包；</span><br><span class="line">Webpack 需要完整打包，启动慢。</span><br><span class="line"></span><br><span class="line">Vite 优势：开发体验更好，适合 ESM 项目；</span><br><span class="line">Webpack 插件生态更丰富，适用于生产优化。</span><br></pre></td></tr></table></figure><p>5、Rollup 适合什么场景，与 Webpack 相比如何？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rollup 专注于 ESM 打包和 Tree Shaking，适合库发布（如 NPM 包），输出更小、更干净；</span><br><span class="line">Webpack 更通用，适合复杂应用。</span><br><span class="line">FIS 类似 Grunt，但社区较小，已少用。</span><br></pre></td></tr></table></figure><h3 id="3-2-优化手段"><a href="#3-2-优化手段" class="headerlink" title="3.2 优化手段"></a>3.2 优化手段</h3><p>1、什么是 Tree Shaking，其原理是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tree Shaking 是移除未使用代码的优化，基于ESM静态分析，通过 AST 解析依赖，标记并删除死代码(如未导入函数)。</span><br><span class="line"></span><br><span class="line">在 Webpack 中，用 production 模式和 sideEffects 配置实现；</span><br><span class="line">依赖编译器（如 Rollup/ESBuild）分析 import/export，注意副作用代码不会被移除。减少打包体积。</span><br></pre></td></tr></table></figure><p>2、代码分割(Code Splitting)如何实现，有什么好处？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Webpack：用 dynamic import() 或 SplitChunksPlugin；</span><br><span class="line">Vite/Rollup：原生支持动态 import()。</span><br><span class="line"></span><br><span class="line">好处：减少初次加载时间、提升性能，尤其在 SPA 中按需加载，避免一次性加载整个应用。</span><br></pre></td></tr></table></figure><p>3、懒加载(Lazy Loading)在前端的应用和优势？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过动态导入（如 React.lazy 或 import(&#x27;./Comp.vue&#x27;)）</span><br><span class="line">延迟加载组件/资源（如图片用 IntersectionObserver 或 loading=&quot;lazy&quot;）。</span><br><span class="line"></span><br><span class="line">优势：减少初始 bundle 大小、加快渲染、优化用户体验，常见于路由或图片。</span><br></pre></td></tr></table></figure><p>4、分包策略有哪些，如何结合其他优化？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">入口分包（多 entry）、公共代码提取（CommonsChunkPlugin）、</span><br><span class="line">动态分包（按功能如登录/首页，或依赖如 vendor/runtime）。</span><br><span class="line"></span><br><span class="line">结合 Tree Shaking 去除无用代码、懒加载按需引入、CDN/压缩，提升缓存利用率和加载速度。</span><br></pre></td></tr></table></figure><p>5、前端性能优化中这些手段的整体应用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先 Tree Shaking 瘦身，再代码分割/懒加载按需加载，分包确保第三方独立更新。适用于项目性能优化。</span><br></pre></td></tr></table></figure><h3 id="3-3-Monorepo管理"><a href="#3-3-Monorepo管理" class="headerlink" title="3.3 Monorepo管理"></a>3.3 Monorepo管理</h3><p>1、常见方案对比</p><table><thead><tr><th align="center">工具</th><th align="center">主要功能</th><th align="center">优势</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">Nx</td><td align="center">任务调度、缓存、生成器</td><td align="center">构建快、扩展强</td><td align="center">学习曲线陡</td><td align="center">大型项目</td></tr><tr><td align="center">Lerna</td><td align="center">包管理、发布</td><td align="center">简单、集成 Yarn</td><td align="center">维护少、任务慢</td><td align="center">中小型 Monorepo</td></tr><tr><td align="center">pnpm workspace</td><td align="center">依赖管理、工作区</td><td align="center">高效存储、快速安装</td><td align="center">需额外工具调度任务</td><td align="center">依赖重项目</td></tr></tbody></table><p>2、什么是 Monorepo，其优势和缺点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Monorepo 是将多个项目置于单一仓库的管理方式。</span><br><span class="line">优势：简化依赖管理、代码共享、统一构建；</span><br><span class="line">缺点：仓库庞大、构建慢。</span><br><span class="line">适合大型团队，避免版本冲突。</span><br></pre></td></tr></table></figure><p>3、pnpm workspace 如何设置和使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在根目录创建 pnpm-workspace.yaml，指定 packages（如 &quot;packages/*&quot;），然后 pnpm install 安装依赖。</span><br><span class="line">支持符号链接和高效存储，适合快速 Monorepo 管理。</span><br></pre></td></tr></table></figure><p>4、Monorepo 工具选型考虑因素？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于中小项目，用 pnpm workspace 或 Lerna 简单上手；</span><br><span class="line">大型项目用 Nx 支持复杂构建和 CI/CD 集成。</span><br></pre></td></tr></table></figure><p>5、如何在 Monorepo 中处理依赖和发布？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 pnpm workspace 管理依赖拓扑，结合 Changesets 或 Lerna 自动化版本发布，确保包间一致性。</span><br></pre></td></tr></table></figure><h3 id="3-4-规范工具"><a href="#3-4-规范工具" class="headerlink" title="3.4 规范工具"></a>3.4 规范工具</h3><p>1、ESLint 和 Prettier 的区别及如何结合使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ESLint 侧重代码质量检查（如变量未用），Prettier 专注格式化（如缩进、引号）。</span><br><span class="line">结合：在 .eslintrc 中集成 eslint-plugin-prettier，运行时先格式化再检查，避免冲突。</span><br></pre></td></tr></table></figure><p>2、如何在项目中配置 ESLint 和 Prettier？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装 eslint、prettier 和插件，</span><br><span class="line">.eslintrc.js 配置规则（如 extends: [&#x27;airbnb&#x27;]），.prettierrc 设置格式（如 singleQuote: true）。</span><br><span class="line"></span><br><span class="line">通过 VSCode 插件和 CI 集成强制规范。</span><br></pre></td></tr></table></figure><p>3、Zod 在前端的作用是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypeScript 类型验证库，用于运行时 schema 校验（如表单、接口数据），生成类型安全对象。</span><br><span class="line">优势：与 TS 集成好，避免运行时错误，常用于表单校验和类型安全化</span><br></pre></td></tr></table></figure><p>4、这些工具如何提升团队协作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ESLint 统一代码风格，Prettier 自动化格式，Zod 确保数据一致。</span><br><span class="line">通过 VSCode 插件和 CI 集成，强制规范，减少 review 时间。</span><br></pre></td></tr></table></figure><h3 id="3-5-ORM-Schema"><a href="#3-5-ORM-Schema" class="headerlink" title="3.5 ORM&#x2F;Schema"></a>3.5 ORM&#x2F;Schema</h3><p>1、Prisma 是什么，与其他 ORM（如 TypeORM）有何区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">Prisma 是 Node.js/TS 的现代 ORM，</span><br><span class="line">提供类型安全的查询 API、自动迁移和 schema 建模，支持 MySQL/PostgreSQL/SQLite 等。</span><br><span class="line"></span><br><span class="line">2、区别：</span><br><span class="line">Prisma 用声明式 schema 文件，查询简洁（如 prisma.user.findMany()）；</span><br><span class="line">TypeORM 传统，依赖装饰器。集成 GraphQL/REST 方便。</span><br></pre></td></tr></table></figure><p>2、如何初始化 Prisma 项目？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装 @prisma/client 和 prisma，</span><br><span class="line">创建 schema.prisma 定义模型和数据源，prisma init 生成 .env，prisma migrate dev 应用迁移。</span><br><span class="line">生成 TS 类型。</span><br></pre></td></tr></table></figure><p>3、Prisma 的优势是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优势：类型安全、自动化迁移、支持多种数据库（如 PostgreSQL），简化数据交互。适合全栈开发，提升开发效率。</span><br></pre></td></tr></table></figure><p>4、Prisma Schema 如何工作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Schema 文件定义模型（如 model User &#123; id Int @id &#125;），Prisma 生成客户端 API，支持 CRUD 查询。</span><br></pre></td></tr></table></figure><h3 id="3-6-CI-CD"><a href="#3-6-CI-CD" class="headerlink" title="3.6 CI&#x2F;CD"></a>3.6 CI&#x2F;CD</h3><p>1、GitHub Actions 与 Jenkins 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Actions 是云原生、YAML 工作流，与 GitHub 集成紧密；</span><br><span class="line">Jenkins 自托管、插件丰富，但配置复杂。</span><br><span class="line">Actions 适合快速 CI/CD，Jenkins 适合自定义管道。</span><br></pre></td></tr></table></figure><p>2、如何使用 GitHub Actions 部署到 Vercel&#x2F;Netlify？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 .github/workflows 创建 YAML，定义 jobs（如 build/deploy），用 CLI 推送。</span><br><span class="line">触发于 push/pull_request，实现自动构建/部署</span><br></pre></td></tr></table></figure><p>3、Vercel 和 Netlify 的优势？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vercel 优化 Next.js，支持预览分支；Netlify 支持静态站点/函数/webhook。</span><br><span class="line">两者免费层多，适合前端部署。</span><br><span class="line">Jenkins 与之区别：自建灵活但维护高；Vercel/Netlify 云托管自动。</span><br></pre></td></tr></table></figure><p>4、CI&#x2F;CD 管道的最佳实践？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用 Actions/Jenkins 测试/构建/部署；</span><br><span class="line">集成 Vercel/Netlify 钩子，确保分支保护和回滚。</span><br></pre></td></tr></table></figure><h3 id="3-7-前端监控"><a href="#3-7-前端监控" class="headerlink" title="3.7 前端监控"></a>3.7 前端监控</h3><p>1、前端监控的常见思路是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监控性能（加载时间）、错误（JS 异常）、行为（PV/UV、点击）。</span><br><span class="line">用 Sentry 自动捕获，或自研 SDK 监听事件（如 window.onerror）上报</span><br></pre></td></tr></table></figure><p>2、Sentry SDK 如何收集错误和性能数据？ </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过全局监听（如 ErrorEvent）和性能 API（如 PerformanceObserver）收集错误/性能，追踪路径并阈值发送。</span><br><span class="line">支持自定义埋点、堆栈追踪、告警</span><br></pre></td></tr></table></figure><p>3、自研埋点 SDK 的实现要点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建 tracker.js，监听 error/click/route change/xhr/fetch，</span><br><span class="line">利用 navigator.sendBeacon 上报 PV/停留时长/来源。</span><br><span class="line">灵活自定义，适合特定需求。</span><br></pre></td></tr></table></figure><p>4、监控工具的优势？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sentry 提供 dashboard 和警报；</span><br><span class="line">自研 SDK 自定义灵活，适合特定需求，如与埋点联动分析用户行为。</span><br></pre></td></tr></table></figure><h3 id="3-8-测试"><a href="#3-8-测试" class="headerlink" title="3.8 测试"></a>3.8 测试</h3><p>1、单元测试 vs E2E 测试？</p><table><thead><tr><th align="center">类型</th><th align="center">工具</th><th align="center">目标</th></tr></thead><tbody><tr><td align="center">单元测试</td><td align="center">Jest、Vitest</td><td align="center">测试函数&#x2F;组件逻辑</td></tr><tr><td align="center">集成测试</td><td align="center">Jest + RTL</td><td align="center">测试组件交互</td></tr><tr><td align="center">E2E 测试</td><td align="center">Cypress、Playwright</td><td align="center">测试完整用户流程</td></tr></tbody></table><p>2、Jest 与 Vitest 区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vitest：Vite 原生支持，启动快，兼容 Jest API，性能更好；</span><br><span class="line">Jest：生态成熟，Node 环境丰富，支持快照/mock。</span><br><span class="line">Vitest 适合现代项目。</span><br></pre></td></tr></table></figure><p>3、什么是 E2E 测试，与单元测试的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E2E 模拟用户交互（如 Cypress 脚本），验证整个应用；</span><br><span class="line">单元隔离组件（如 Jest）。E2E 全面但慢/易碎。</span><br></pre></td></tr></table></figure><p>4、如何选择测试框架？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单元用 Jest/Vitest，E2E 用 Cypress/Playwright。</span><br><span class="line">集成 CI，确保覆盖率。</span><br></pre></td></tr></table></figure><h3 id="3-9-接口调试"><a href="#3-9-接口调试" class="headerlink" title="3.9 接口调试"></a>3.9 接口调试</h3><p>1、Postman 如何用于接口测试？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Postman 支持创建集合、变量和脚本，模拟请求、断言响应。适合自动化测试链，如环境切换。</span><br></pre></td></tr></table></figure><p>2、Charles 的作用和使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抓包工具，捕获 HTTP/HTTPS 流量，分析参数/响应。</span><br><span class="line">设置代理、断点调试，适合移动端/Mock 返回。</span><br></pre></td></tr></table></figure><p>3、Swagger 在接口调试中的作用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成互动 API 文档，支持在线测试。</span><br><span class="line">基于 OpenAPI，实时更新，可生成前端 SDK，减少手动文档。</span><br></pre></td></tr></table></figure><p>4、这些工具如何结合？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Swagger 文档化，Postman 测试，Charles 抓包验证，提升调试效率。</span><br></pre></td></tr></table></figure><h2 id="四-总结建议"><a href="#四-总结建议" class="headerlink" title="四 总结建议"></a>四 总结建议</h2><table><thead><tr><th align="center">模块</th><th align="center">一句话答法</th></tr></thead><tbody><tr><td align="center">构建工具</td><td align="center">Vite 快、Webpack 强、Rollup 精、Gulp 老</td></tr><tr><td align="center">优化手段</td><td align="center">拆包、懒加载、Tree-shaking 提性能</td></tr><tr><td align="center">Monorepo</td><td align="center">Nx&#x2F;Lerna&#x2F;pnpm workspace 提高复用</td></tr><tr><td align="center">规范</td><td align="center">ESLint + Prettier + Zod，统一风格与类型安全</td></tr><tr><td align="center">ORM</td><td align="center">Prisma 类型安全、迁移方便</td></tr><tr><td align="center">CI&#x2F;CD</td><td align="center">Actions 自动化，Vercel 一键部署</td></tr><tr><td align="center">监控</td><td align="center">Sentry 异常监控 + 自研埋点上报</td></tr><tr><td align="center">测试</td><td align="center">Jest 单测，Cypress&#x2F;Playwright E2E</td></tr><tr><td align="center">调试</td><td align="center">Postman&#x2F;Charles&#x2F;Swagger，API 全流程保障</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——框架与库之其他框架与UI(7)</title>
    <link href="https://pgzxc.github.io/posts/6dbfbdfe.html"/>
    <id>https://pgzxc.github.io/posts/6dbfbdfe.html</id>
    <published>2025-10-25T00:39:25.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.AngularJS</span><br><span class="line">2.UI 框架：Element UI/Plus、Vant、Bootstrap、Tailwind CSS、HeadlessUI、RadixUI、ShadcnUI</span><br><span class="line">3.数据可视化：ECharts、D3.js、Three.js</span><br><span class="line">4.GIS 技术：OpenLayers、GeoServer、ArcGIS、QGIS</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-AngularJS"><a href="#3-1-AngularJS" class="headerlink" title="3.1 AngularJS"></a>3.1 AngularJS</h3><p>1、AngularJS 是什么？其主要特点和优势？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、概念：AngularJS 是 Google 维护的开源前端框架，用于构建动态单页面应用(SPA)。</span><br><span class="line">2、核心特点：双向数据绑定、依赖注入(DI)、MVC/MVVM 架构、指令系统、模块化(angular.module())。</span><br><span class="line">3、优势：开发效率高、测试友好、社区活跃；</span><br><span class="line">4、缺点：大数据场景性能较差，不如 React/Vue。</span><br></pre></td></tr></table></figure><p>2、关键概念与角色(MVVM 视角)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、$scope：</span><br><span class="line">Model 与 View 的桥梁，存储数据和方法。$rootScope 是所有 $scope 的根，避免全局污染。</span><br><span class="line"></span><br><span class="line">2、Controller：</span><br><span class="line">ViewModel，处理业务逻辑和数据绑定。</span><br><span class="line"></span><br><span class="line">3、Directive：</span><br><span class="line"> View 层扩展 HTML(如 ng-if、ng-repeat)，实现组件化。</span><br><span class="line"> 创建自定义指令：.directive() 配置 restrict、template、scope 和 link 函数。</span><br><span class="line"> </span><br><span class="line">4、Service/Factory：</span><br><span class="line"> Model 层，提供可复用服务(如 $http)。</span><br><span class="line"> Service 用 new 实例化，Factory 返回对象/函数；</span><br><span class="line"> 两者均为单例，支持 DI。</span><br></pre></td></tr></table></figure><p>3、双向数据绑定原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、通过脏检查(Dirty Checking)：</span><br><span class="line">$scope 上设置 $watch 监听器，事件触发 $digest 循环遍历检查变化，更新 DOM。</span><br><span class="line">$apply() 从外部进入 Angular 体系。</span><br><span class="line"></span><br><span class="line">2、缺点：性能开销大；</span><br><span class="line">3、优化：用单向绑定 (::)、减少 $watch。</span><br><span class="line">4、示例：ng-model 绑定输入到 $scope，实现实时同步。</span><br></pre></td></tr></table></figure><p>4、常见指令区别(ng-if vs ng-show&#x2F;ng-hide)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ng-if 条件 true 时创建 DOM(节省资源，但重建慢)；</span><br><span class="line">ng-show/ng-hide 始终存在 DOM，仅切换 display(切换快，但内存高)。</span><br><span class="line">ng-if 适合条件内容，ng-show 适合频繁切换。</span><br></pre></td></tr></table></figure><p>5、如何创建自定义过滤器？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 .filter() 定义工厂函数，返回转换逻辑(如 reverse 过滤器)。</span><br><span class="line">在模板中：&#123;&#123; text | reverse &#125;&#125;。</span><br><span class="line">用于视图数据格式化，不改原数据。</span><br></pre></td></tr></table></figure><p>6、AngularJS 与 Angular 的区别？</p><table><thead><tr><th align="center">对比项</th><th align="center">AngularJS (1.x)</th><th align="center">Angular (2+)</th></tr></thead><tbody><tr><td align="center">语言</td><td align="center">JavaScript</td><td align="center">TypeScript</td></tr><tr><td align="center">架构</td><td align="center">MVC&#x2F;MVVM</td><td align="center">基于组件的架构</td></tr><tr><td align="center">数据绑定</td><td align="center">$scope 双向绑定</td><td align="center">单向 + 双向绑定(模板语法)</td></tr><tr><td align="center">性能</td><td align="center">较低(脏检查)</td><td align="center">高(变更检测、虚拟 DOM)</td></tr><tr><td align="center">模块化</td><td align="center">模块系统弱</td><td align="center">NgModule 强模块化</td></tr><tr><td align="center">路由</td><td align="center">ngRoute</td><td align="center">@angular&#x2F;router</td></tr></tbody></table><h3 id="3-2-UI-框架"><a href="#3-2-UI-框架" class="headerlink" title="3.2 UI 框架"></a>3.2 UI 框架</h3><h4 id="3-2-1-UI-框架—Element-UI-Plus-Vue-生态"><a href="#3-2-1-UI-框架—Element-UI-Plus-Vue-生态" class="headerlink" title="3.2.1 UI 框架—Element UI&#x2F;Plus(Vue 生态)"></a>3.2.1 UI 框架—Element UI&#x2F;Plus(Vue 生态)</h4><p>1、Element UI 和 Element Plus 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Element UI 基于 Vue 2.x，适用于桌面端；</span><br><span class="line">Element Plus 基于 Vue 3.x，支持 Composition API、TypeScript，更高性能和树摇优化。</span><br><span class="line">两者组件类似，但 Plus 提供更好国际化支持。</span><br></pre></td></tr></table></figure><p>2、如何在项目中使用 Element UI&#x2F;Plus？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install element-plus；</span><br><span class="line">导入组件（如 import &#123; ElButton &#125; from &#x27;element-plus&#x27;）；</span><br><span class="line">在 main.js 全局注册；</span><br><span class="line">按需引入减少体积。</span><br><span class="line">表单验证：用 rules 和 prop 绑定。</span><br></pre></td></tr></table></figure><p>3、如何修改 el-input 样式？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 /deep/ 或 &gt;&gt;&gt; 穿透（如 .el-input__inner &#123; height: 40px; &#125;），或在组件 scoped 样式中添加。</span><br><span class="line">避免直接改全局 CSS。</span><br></pre></td></tr></table></figure><p>4、Element UI 如何做表单验证？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 rules 对象定义规则(如 required: true)，结合 ref 表单组件调用 validate() 方法。</span><br><span class="line">在循环中：为每个 input 动态生成 name 和 prop。</span><br></pre></td></tr></table></figure><h4 id="3-2-2-UI-框架—Vant-Vue-React-移动端"><a href="#3-2-2-UI-框架—Vant-Vue-React-移动端" class="headerlink" title="3.2.2 UI 框架—Vant((Vue&#x2F;React 移动端)"></a>3.2.2 UI 框架—Vant((Vue&#x2F;React 移动端)</h4><p>1、特点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">轻量（组件 ~1KB）、主题定制、国际化。</span><br><span class="line">优化：按需加载、Tree Shaking；</span><br><span class="line">适配 rem 单位。</span><br><span class="line">缺点：复杂页面 DOM 多。</span><br></pre></td></tr></table></figure><p>2、按需引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel-plugin-import 配置；</span><br><span class="line">import Button from &#x27;vant/lib/button&#x27;。</span><br></pre></td></tr></table></figure><h4 id="3-2-3-UI-框架—Bootstrap-HTML-CSS-JS"><a href="#3-2-3-UI-框架—Bootstrap-HTML-CSS-JS" class="headerlink" title="3.2.3 UI 框架—Bootstrap(HTML&#x2F;CSS&#x2F;JS)"></a>3.2.3 UI 框架—Bootstrap(HTML&#x2F;CSS&#x2F;JS)</h4><p>1、Bootstrap 的网格系统如何工作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基于 12 列响应式布局：row 容器 + col-- 类（如 col-md-6 为中等屏占 6 列）。</span><br><span class="line">移动优先：小屏先定义，逐步扩展。</span><br><span class="line">示例：内容。</span><br></pre></td></tr></table></figure><p>2、为什么使用 Bootstrap？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">移动优先、响应式设计、浏览器兼容好、易上手。</span><br><span class="line">需添加 viewport meta 标签确保移动友好。</span><br></pre></td></tr></table></figure><h4 id="3-2-4-UI-框架—Tailwind-CSS-原子化-CSS"><a href="#3-2-4-UI-框架—Tailwind-CSS-原子化-CSS" class="headerlink" title="3.2.4 UI 框架—Tailwind CSS(原子化 CSS)"></a>3.2.4 UI 框架—Tailwind CSS(原子化 CSS)</h4><p>1、Tailwind CSS 是什么？如何安装？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实用优先 CSS 框架，使用类名（如 bg-blue-500）快速构建 UI。</span><br><span class="line"></span><br><span class="line">安装：</span><br><span class="line">npm i -D tailwindcss；npx tailwindcss init 配置 content；@tailwind base; 等指令导入 CSS。</span><br><span class="line"></span><br><span class="line">优势：无命名冲突、易定制。</span><br></pre></td></tr></table></figure><p>2、Tailwind 的优点和缺点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：响应式强、主题可扩展（tailwind.config.js）。</span><br><span class="line">缺点：HTML 类名多，学习曲线陡。</span><br></pre></td></tr></table></figure><h4 id="3-2-5-UI-框架—HeadlessUI、RadixUI、ShadcnUI-无样式组件"><a href="#3-2-5-UI-框架—HeadlessUI、RadixUI、ShadcnUI-无样式组件" class="headerlink" title="3.2.5 UI 框架—HeadlessUI、RadixUI、ShadcnUI(无样式组件)"></a>3.2.5 UI 框架—HeadlessUI、RadixUI、ShadcnUI(无样式组件)</h4><p>1、Headless UI 是什么？如何使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">无样式、完全可访问的 React UI 组件库，与 Tailwind 集成。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">-import &#123; Menu &#125; from &#x27;@headlessui/react&#x27;；</span><br><span class="line">-用 render props 控制状态（如 open）。</span><br><span class="line"></span><br><span class="line">优势：自定义 UI，焦点管理好。</span><br></pre></td></tr></table></figure><p>2、Radix UI 和 Shadcn UI 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Radix UI：低级无头组件库，专注可访问性和 API（如 Popover.Root）。</span><br><span class="line">Shadcn UI：基于 Radix + Tailwind 的组件集合，非库而是代码分发（CLI 添加组件）。</span><br><span class="line">两者强调开源、可组合。</span><br></pre></td></tr></table></figure><h4 id="3-2-6-常见框架与面试题对比"><a href="#3-2-6-常见框架与面试题对比" class="headerlink" title="3.2.6 常见框架与面试题对比"></a>3.2.6 常见框架与面试题对比</h4><table><thead><tr><th align="center">框架</th><th align="center">生态定位</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">Element UI &#x2F; Element Plus</td><td align="center">Vue 生态</td><td align="center">完整的企业级组件库，常用于后台管理系统</td></tr><tr><td align="center">Vant</td><td align="center">Vue &#x2F; React</td><td align="center">轻量级移动端组件库，适合 H5、小程序</td></tr><tr><td align="center">Bootstrap</td><td align="center">HTML&#x2F;CSS&#x2F;JS</td><td align="center">老牌 UI 框架，响应式布局</td></tr><tr><td align="center">Tailwind CSS</td><td align="center">原子化 CSS</td><td align="center">高度可定制，无需自定义样式类</td></tr><tr><td align="center">HeadlessUI</td><td align="center">Vue &#x2F; React</td><td align="center">无样式组件，结合 Tailwind 构建灵活 UI</td></tr><tr><td align="center">Radix UI &#x2F; Shadcn UI</td><td align="center">React 生态</td><td align="center">无样式 + 可访问性(A11y)最佳实践，适合现代设计体系</td></tr></tbody></table><h3 id="3-3-数据可视化"><a href="#3-3-数据可视化" class="headerlink" title="3.3 数据可视化"></a>3.3 数据可视化</h3><h4 id="3-3-1-数据可视化—ECharts"><a href="#3-3-1-数据可视化—ECharts" class="headerlink" title="3.3.1 数据可视化—ECharts"></a>3.3.1 数据可视化—ECharts</h4><p>1、如何初始化图表？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echarts.init(dom).setOption(&#123; title, xAxis, yAxis, series: [&#123; type: &#x27;bar&#x27;, data &#125;] &#125;</span><br><span class="line">支持动态更新 data。</span><br></pre></td></tr></table></figure><p>2、原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于 Canvas/SVG，底层 ZRender</span><br></pre></td></tr></table></figure><p>3、如何优化性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazyUpdate、减少 setOption、数据下采样、dataZoom 分段加载、dispose() 销毁实例、resize() 适配。</span><br><span class="line">避免定时器内存泄漏。</span><br></pre></td></tr></table></figure><h4 id="3-3-2-数据可视化—D3-js"><a href="#3-3-2-数据可视化—D3-js" class="headerlink" title="3.3.2 数据可视化—D3.js"></a>3.3.2 数据可视化—D3.js</h4><p>1、数据绑定如何实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll().data().enter().append()；</span><br><span class="line">处理 enter/update/exit。</span><br><span class="line">示例：attr(&#x27;x&#x27;, (d, i) =&gt; i * 30)。</span><br></pre></td></tr></table></figure><p>2、比例尺是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">映射数据域(domain)到像素范围(range)，如 d3.scaleLinear().domain([0, 100]).range([0, 500]);。</span><br><span class="line">类型：线性、对数、序数。</span><br></pre></td></tr></table></figure><h4 id="3-3-3-数据可视化—Three-js"><a href="#3-3-3-数据可视化—Three-js" class="headerlink" title="3.3.3 数据可视化—Three.js"></a>3.3.3 数据可视化—Three.js</h4><p>1、基本组件有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、基本组件：</span><br><span class="line">场景（Scene）、相机（PerspectiveCamera）、渲染器（WebGLRenderer）。</span><br><span class="line"></span><br><span class="line">2、示例：</span><br><span class="line">const scene = new THREE.Scene(); </span><br><span class="line">const camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);</span><br><span class="line">renderer.render(scene, camera);。</span><br></pre></td></tr></table></figure><p>2、如何优化渲染性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">减少绘制调用（合并几何体）、视锥体裁剪、LOD（细节层次）。</span><br><span class="line">用 Web Workers 后台计算。</span><br></pre></td></tr></table></figure><h4 id="3-3-4-常见框架"><a href="#3-3-4-常见框架" class="headerlink" title="3.3.4 常见框架"></a>3.3.4 常见框架</h4><table><thead><tr><th align="center">框架</th><th align="center">应用场景</th><th align="center">优点</th></tr></thead><tbody><tr><td align="center">ECharts</td><td align="center">统计图、BI 系统</td><td align="center">配置化高、支持地图&#x2F;3D</td></tr><tr><td align="center">D3.js</td><td align="center">自定义复杂交互</td><td align="center">灵活但门槛高</td></tr><tr><td align="center">Three.js</td><td align="center">3D 建模、WebGL 场景</td><td align="center">实现 3D 动画与可视化效果</td></tr></tbody></table><h3 id="3-4-GIS-技术"><a href="#3-4-GIS-技术" class="headerlink" title="3.4 GIS 技术"></a>3.4 GIS 技术</h3><h4 id="3-4-1-GIS-技术—OpenLayers-Web-地图库"><a href="#3-4-1-GIS-技术—OpenLayers-Web-地图库" class="headerlink" title="3.4.1 GIS 技术—OpenLayers(Web 地图库)"></a>3.4.1 GIS 技术—OpenLayers(Web 地图库)</h4><p>1、如何加载瓦片地图？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import Map from &#x27;ol/Map&#x27;; </span><br><span class="line">import View from &#x27;ol/View&#x27;; </span><br><span class="line">import TileLayer from &#x27;ol/layer/Tile&#x27;; </span><br><span class="line">import OSM from &#x27;ol/source/OSM&#x27;; </span><br><span class="line"></span><br><span class="line">new Map(&#123; layers: [new TileLayer(&#123; source: new OSM() &#125;)], </span><br><span class="line">view: new View(&#123; center: [0, 0], zoom: 2 &#125;) &#125;);。</span><br><span class="line"></span><br><span class="line">支持 WMS/WMTS。</span><br></pre></td></tr></table></figure><p>2、自定义控件如何实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 CSS 样式和属性调整位置，如 .ol-zoom &#123; top: 10px; left: 10px; &#125;。</span><br><span class="line">自定义坐标系用 Projection 类。</span><br></pre></td></tr></table></figure><h4 id="3-4-2-GIS-技术—GeoServer-地图服务"><a href="#3-4-2-GIS-技术—GeoServer-地图服务" class="headerlink" title="3.4.2 GIS 技术—GeoServer(地图服务)"></a>3.4.2 GIS 技术—GeoServer(地图服务)</h4><p>1、如何发布地图服务？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">登录 Web 界面，创建 Workspace/Store/Layer；</span><br><span class="line">支持 Shapefile/PostGIS。</span><br><span class="line">发布 WMS/WFS 服务。</span><br><span class="line">解决中文乱码：设置 UTF-8 编码。</span><br></pre></td></tr></table></figure><p>2、特点和数据支持？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开源 J2EE 实现 OGC 标准（WMS/WFS）。</span><br><span class="line">支持 PostGIS、Shapefile、Oracle Spatial。</span><br><span class="line">优势：易共享地理数据、安全控制。</span><br></pre></td></tr></table></figure><h4 id="3-4-3-GIS-技术—ArcGIS-QGIS"><a href="#3-4-3-GIS-技术—ArcGIS-QGIS" class="headerlink" title="3.4.3 GIS 技术—ArcGIS&#x2F;QGIS"></a>3.4.3 GIS 技术—ArcGIS&#x2F;QGIS</h4><p>1、功能和与 QGIS 区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArcGIS：商业 GIS 软件，全功能（地图制作、空间分析）。</span><br><span class="line">QGIS：开源免费，支持插件扩展。ArcGIS 更强大但收费，QGIS 社区活跃、易上手。</span><br></pre></td></tr></table></figure><p>2、叠加分析是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将多图层叠加分析空间关系（如缓冲区交集）。</span><br><span class="line">在 ArcGIS 用 Spatial Analyst 工具；在 QGIS 用 Processing Toolbox。</span><br></pre></td></tr></table></figure><h4 id="3-4-4-常见框架"><a href="#3-4-4-常见框架" class="headerlink" title="3.4.4 常见框架"></a>3.4.4 常见框架</h4><table><thead><tr><th align="center">技术</th><th align="center">类型</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">OpenLayers</td><td align="center">Web 地图库</td><td align="center">开源、轻量，支持矢量&#x2F;瓦片&#x2F;交互</td></tr><tr><td align="center">GeoServer</td><td align="center">地图服务发布</td><td align="center">基于 Java，可发布 WMS&#x2F;WFS 服务</td></tr><tr><td align="center">ArcGIS</td><td align="center">商业 GIS 平台</td><td align="center">完整生态，API 强大但闭源</td></tr><tr><td align="center">QGIS</td><td align="center">桌面端</td><td align="center">开源 GIS 编辑与分析工具</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——框架与库之Vue(6)</title>
    <link href="https://pgzxc.github.io/posts/841637eb.html"/>
    <id>https://pgzxc.github.io/posts/841637eb.html</id>
    <published>2025-10-24T00:49:18.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Vue2 vs Vue3</span><br><span class="line">2.响应式原理：Object.defineProperty vs Proxy</span><br><span class="line">3.组件通信：props、emit、provide/inject、Vuex/Pinia</span><br><span class="line">4.虚拟 DOM 与 Diff 算法</span><br><span class="line">5.Vue Router：Hash / History 原理</span><br><span class="line">6.Composition API vs Options API</span><br><span class="line">7.性能优化：keep-alive、异步组件、虚拟滚动</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-Vue2-vs-Vue3"><a href="#3-1-Vue2-vs-Vue3" class="headerlink" title="3.1 Vue2 vs Vue3"></a>3.1 Vue2 vs Vue3</h3><p>1、Vue2 与 Vue3 有哪些主要区别？</p><table><thead><tr><th align="center">对比项</th><th align="center">Vue2</th><th align="center">Vue3</th></tr></thead><tbody><tr><td align="center">响应式实现</td><td align="center">Object.defineProperty</td><td align="center">Proxy（支持动态属性、数组、Map&#x2F;Set）</td></tr><tr><td align="center">代码组织</td><td align="center">Options API(data、methods 分散)</td><td align="center">Composition API(逻辑集中、可复用)</td></tr><tr><td align="center">性能优化</td><td align="center">全量依赖追踪</td><td align="center">静态提升、PatchFlag、Block Tree 优化</td></tr><tr><td align="center">TypeScript 支持</td><td align="center">支持较弱</td><td align="center">原生支持，类型推导更优</td></tr><tr><td align="center">架构设计</td><td align="center">单体核心</td><td align="center">模块化(runtime-core、reactivity 分离)</td></tr><tr><td align="center">新特性</td><td align="center">无</td><td align="center">Teleport、Suspense、Fragments、多根节点模板</td></tr></tbody></table><p>2、Vue3 的优势及迁移原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-更高效：Proxy 响应式性能更高，编译时优化（如静态提升、PatchFlag）减少运行时开销。</span><br><span class="line">-更灵活：Composition API 提升代码复用性和可维护性，适合复杂逻辑。</span><br><span class="line">-现代生态：原生 TypeScript 支持，兼容 Pinia 等新工具，适配大型项目。</span><br><span class="line">-企业迁移：为长期维护、性能提升和生态兼容，需注意插件迁移成本。</span><br></pre></td></tr></table></figure><p>3、Vue3 新特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Composition API：逻辑按功能组织，便于复用。</span><br><span class="line">-Teleport：传送组件到任意 DOM 位置。</span><br><span class="line">-Suspense：处理异步组件加载，显示 fallback。</span><br><span class="line">-响应式 API：ref（基本类型）、reactive（对象），更灵活。</span><br></pre></td></tr></table></figure><h3 id="3-2-响应式原理"><a href="#3-2-响应式原理" class="headerlink" title="3.2 响应式原理"></a>3.2 响应式原理</h3><p>1、Vue2 的响应式原理是什么？它使用 Object.defineProperty 的局限性有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、通过 Object.defineProperty 劫持对象属性 getter/setter，实现依赖收集和更新派发。</span><br><span class="line"></span><br><span class="line">2、局限性：</span><br><span class="line">-无法检测数组长度变化(如 push/pop)或对象新增/删除属性。</span><br><span class="line">-需递归遍历嵌套对象，性能开销大。</span><br><span class="line">-不支持 Map/Set 等新类型。</span><br></pre></td></tr></table></figure><p>2、Vue3 响应式原理？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、使用 Proxy 拦截整个对象，支持新增/删除属性、数组变化及 Map/Set，初始化性能更优。</span><br><span class="line"></span><br><span class="line">2、优势：</span><br><span class="line">-非入侵式，无需递归遍历属性。</span><br><span class="line">-支持更多操作（如 delete、has），覆盖广泛场景。</span><br><span class="line">-深度监听更高效。</span><br></pre></td></tr></table></figure><p>3、处理 Vue2 局限性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Vue.set 添加属性，Vue.delete 删除属性。</span><br><span class="line">数组操作用 splice 等方法。</span><br><span class="line">复杂场景用深拷贝或自定义 watcher。</span><br><span class="line">推荐迁移到 Vue3，彻底解决局限性。</span><br></pre></td></tr></table></figure><h3 id="3-3-组件通信"><a href="#3-3-组件通信" class="headerlink" title="3.3 组件通信"></a>3.3 组件通信</h3><p>1、Vue 组件间有哪些通信方式？适用场景如何？</p><table><thead><tr><th align="center">通信方式</th><th align="center">方向</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">props</td><td align="center">父 → 子</td><td align="center">数据单向下传</td></tr><tr><td align="center">emit</td><td align="center">子 → 父</td><td align="center">子组件触发事件通知父组件</td></tr><tr><td align="center">v-model</td><td align="center">双向</td><td align="center">父子组件值双向绑定</td></tr><tr><td align="center">provide &#x2F; inject</td><td align="center">任意层级</td><td align="center">跨层级依赖注入(如配置、主题)</td></tr><tr><td align="center">事件总线 (mitt&#x2F; EventBus)</td><td align="center">任意</td><td align="center">非父子通信(Vue3 推荐 mitt)</td></tr><tr><td align="center">全局状态(Vuex &#x2F; Pinia)</td><td align="center">任意</td><td align="center">复杂全局状态管理</td></tr></tbody></table><p>2、provide&#x2F;inject 与 props 的区别？何时使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">provide/inject 用于跨层级通信（如祖先提供，后代注入），非响应式（Vue3 可通过 reactive 实现响应）；props 限于父子，易追踪。</span><br><span class="line">provide/inject 适合配置注入或主题传递，不适合频繁数据变化。</span><br></pre></td></tr></table></figure><p>3、Vuex 和 Pinia 的区别？在 Vue3 中为什么推荐 Pinia？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vuex 是官方状态管理，模块化但 boilerplate 多；</span><br><span class="line">Pinia 更轻量，支持 Composition API、无 mutations（直接修改 state）、更好 TypeScript 支持。</span><br><span class="line">Pinia 在 Vue3 中更流行，因其简洁和模块化</span><br></pre></td></tr></table></figure><h3 id="3-4-虚拟-DOM-与-Diff-算法"><a href="#3-4-虚拟-DOM-与-Diff-算法" class="headerlink" title="3.4 虚拟 DOM 与 Diff 算法"></a>3.4 虚拟 DOM 与 Diff 算法</h3><p>1、什么是虚拟 DOM？Vue 如何使用它？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虚拟 DOM 是真实 DOM 的 JS 对象表示，用于高效更新。</span><br><span class="line">Vue 通过 render 函数生成 VNode 树，比较新旧树差异，只更新变化部分。</span><br></pre></td></tr></table></figure><p>2、Vue 的 Diff 算法原理是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、原理：</span><br><span class="line">同层比较，根节点类型相同则 patch 属性和子节点；</span><br><span class="line">子节点通过 key 优化列表复用；</span><br><span class="line">采用双端比较（oldStart/newStart 指针）找出最小操作。</span><br><span class="line"></span><br><span class="line">2、Vue3 优化：</span><br><span class="line"></span><br><span class="line">-静态提升：编译时提取静态节点，减少运行时 diff。</span><br><span class="line">-PatchFlag：标记动态内容，仅比较变化部分。</span><br><span class="line">-Block Tree：跳过静态子树，提升效率。</span><br><span class="line">-Fragment：支持多根节点，减少包裹层。</span><br></pre></td></tr></table></figure><p>3、虚拟 DOM 的优缺点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、优点：批量更新减少 DOM 操作，提高性能；跨平台。</span><br><span class="line">2、缺点：初次渲染慢，内存占用。Vue 通过优化 Diff 缓解。</span><br></pre></td></tr></table></figure><h3 id="3-5-Vue-Router"><a href="#3-5-Vue-Router" class="headerlink" title="3.5 Vue Router"></a>3.5 Vue Router</h3><p>1、Vue Router 的 Hash 和 History 模式区别是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash 使用 # 符号模拟 URL 变化（如 #/home），基于 hashchange 事件，不需服务器配置；</span><br><span class="line">History 使用真实 URL(如/home)，基于 popstate 和 pushState，需要服务器重定向到 index.html 以防 404。</span><br></pre></td></tr></table></figure><p>2、Hash 和 History 的原理及适用场景？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、Hash 原理：</span><br><span class="line">监听 hashchange，不发请求；适合简单部署。</span><br><span class="line"></span><br><span class="line">2、History 原理：</span><br><span class="line">HTML5 History API 操作浏览器历史；</span><br><span class="line">适合 SEO 和美观 URL，但需后端支持（如 Nginx rewrite）</span><br></pre></td></tr></table></figure><p>3、如何在项目中切换路由模式？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 router 配置中设置 mode: &#x27;history&#x27; 或 &#x27;hash&#x27;；</span><br><span class="line">History 模式需配置服务器（如 Apache .htaccess）。</span><br></pre></td></tr></table></figure><p>4、Vue Router 的两种模式有什么区别？底层原理是什么？</p><table><thead><tr><th align="center">模式</th><th align="center">URL 形式</th><th align="center">原理</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">Hash</td><td align="center">&#x2F;#&#x2F;path</td><td align="center">监听hashchange</td><td align="center">无需服务器配置，兼容性好</td></tr><tr><td align="center">History</td><td align="center">&#x2F;path</td><td align="center">使用pushState &#x2F; popstate</td><td align="center">URL 美观，需后端支持 404 回退</td></tr></tbody></table><p>面试加分点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue Router 实现本质是 监听 URL 变化（hash 或 popstate） → 匹配路由表 → 渲染对应组件。</span><br></pre></td></tr></table></figure><h3 id="3-6-Composition-API-vs-Options-API"><a href="#3-6-Composition-API-vs-Options-API" class="headerlink" title="3.6 Composition API vs Options API"></a>3.6 Composition API vs Options API</h3><p>1、主要区别</p><table><thead><tr><th align="center">对比项</th><th align="center">Options API</th><th align="center">Composition API</th></tr></thead><tbody><tr><td align="center">写法</td><td align="center">data、methods 分散</td><td align="center">setup() 函数，逻辑按功能分组</td></tr><tr><td align="center">可复用性</td><td align="center">mixins 易冲突</td><td align="center">composable 函数清晰复用</td></tr><tr><td align="center">类型支持</td><td align="center">TypeScript 支持弱</td><td align="center">原生支持 TypeScript</td></tr><tr><td align="center">逻辑组织</td><td align="center">分散，复杂组件难维护</td><td align="center">高内聚，逻辑清晰</td></tr></tbody></table><p>2、何时选择 Composition API？它的优势？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-逻辑复用性强，易抽取为 composable。</span><br><span class="line">-TypeScript 友好，类型推导更优。</span><br><span class="line">-适合复杂组件，逻辑清晰可维护。</span><br></pre></td></tr></table></figure><p>3、如何在 Composition API 中使用 ref 和 reactive？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-ref：用于基本类型，访问需 .value。</span><br><span class="line">-reactive：用于对象，返回响应式代理。</span><br><span class="line">-选择：基本类型用 ref，复杂对象用 reactive。</span><br></pre></td></tr></table></figure><h3 id="3-7-性能优化"><a href="#3-7-性能优化" class="headerlink" title="3.7 性能优化"></a>3.7 性能优化</h3><p>1、Vue 项目中常见的性能优化手段有哪些？</p><table><thead><tr><th align="center">场景</th><th align="center">优化手段</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">组件频繁切换</td><td align="center">&lt;keep-alive&gt;</td><td align="center">缓存组件实例，保留状态</td></tr><tr><td align="center">首屏加载慢</td><td align="center">异步组件 defineAsyncComponent + 路由懒加载</td><td align="center">减少初次 bundle 大小</td></tr><tr><td align="center">大量列表渲染</td><td align="center">虚拟滚动（vue-virtual-scroller）</td><td align="center">只渲染可视区，降低 DOM 开销</td></tr><tr><td align="center">响应式滥用</td><td align="center">合理使用 shallowRef&#x2F; shallowReactive</td><td align="center">减少深层依赖追踪成本</td></tr><tr><td align="center">静态资源</td><td align="center">CDN 加速 &#x2F; 图片懒加载</td><td align="center">优化加载速度</td></tr><tr><td align="center">编译优化</td><td align="center">静态提升 + PatchFlag(Vue3 自动支持)</td><td align="center">减少运行时 diff 开销</td></tr></tbody></table><p>2、什么是异步组件？如何实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">异步组件使用 defineAsyncComponent(() =&gt; import(&#x27;./Comp.vue&#x27;)) 懒加载，</span><br><span class="line">减少初次 bundle 大小，提升加载速度。适合非核心组件。</span><br></pre></td></tr></table></figure><p>3、虚拟滚动在 Vue 中的应用？性能优势？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟滚动只渲染可视区元素（如 vue-virtual-scroller），处理长列表。</span><br><span class="line">优势：减少 DOM 节点，降低内存和渲染开销。</span><br><span class="line">结合 Intersection Observer 实现。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——框架与库之React(5)</title>
    <link href="https://pgzxc.github.io/posts/c39400e0.html"/>
    <id>https://pgzxc.github.io/posts/c39400e0.html</id>
    <published>2025-10-23T01:10:37.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Fiber 架构</span><br><span class="line">2.组件通信：props、context、事件、全局状态</span><br><span class="line">3.Hooks 原理：useState/useEffect/useMemo/useCallback/useRef</span><br><span class="line">4.Diff 算法</span><br><span class="line">5.React 18：Concurrent Rendering、Suspense</span><br><span class="line">6.状态管理：Redux、MobX、Recoil、Zustand</span><br><span class="line">7.性能优化：memo、虚拟化、懒加载</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-Fiber-架构"><a href="#3-1-Fiber-架构" class="headerlink" title="3.1 Fiber 架构"></a>3.1 Fiber 架构</h3><p>1、什么是 React 的 Fiber 架构？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fiber 是 React 16 引入的核心渲染引擎，</span><br><span class="line">通过将渲染任务拆分为可中断的单元，</span><br><span class="line">支持优先级调度和并发渲染，</span><br><span class="line">提升 UI 响应性和复杂应用的性能。</span><br></pre></td></tr></table></figure><p>2、Fiber 如何提升渲染效率？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、任务分片：</span><br><span class="line">将渲染任务拆分为小块，高优先级任务(如用户交互)优先执行，低优先级任务(如数据加载)可暂停，避免UI阻塞。</span><br><span class="line">2、时间切片：利用浏览器空闲时间处理任务，保持界面流畅。</span><br><span class="line">3、优先级调度：通过 Scheduler 动态调整任务优先级。</span><br></pre></td></tr></table></figure><p>3、Fiber 中 Reconciliation 的过程是怎样的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Reconciliation 比较新旧 Virtual DOM，计算最小更新集，批量应用到真实 DOM。</span><br><span class="line"></span><br><span class="line">Fiber 使此过程可中断，支持并发更新，分两阶段：</span><br><span class="line"> -Render 阶段（可中断）：生成 Fiber 树，计算变化。</span><br><span class="line"> -Commit 阶段（不可中断）：更新 DOM，触发生命周期</span><br></pre></td></tr></table></figure><p>4、什么是 React Fiber？为什么要引入 Fiber？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">Fiber是React 16之后重构的核心架构，用来优化 协调(Reconciliation)过程，支持 可中断、可恢复的异步渲染。</span><br><span class="line"></span><br><span class="line">2、旧架构问题（Stack Reconciler）：</span><br><span class="line">-递归遍历虚拟 DOM，同步执行；</span><br><span class="line">-1次更新会长时间占用主线程，造成页面卡顿（无法响应用户交互）。</span><br><span class="line"></span><br><span class="line">3、Fiber 的改进：</span><br><span class="line">-Fiber 是一种数据结构(每个节点对应一个 Fiber 对象，保存组件状态、DOM 信息、上下文引用等)。</span><br><span class="line">-通过 链表结构（child、sibling、return）实现 可中断遍历。</span><br><span class="line">-支持 时间切片（Time Slicing） 和 优先级调度（Scheduler）。</span><br><span class="line"></span><br><span class="line">4、简要流程：</span><br><span class="line">-render 阶段（可中断）：生成 Fiber 树、计算变化；</span><br><span class="line">-commit 阶段（不可中断）：DOM 更新、生命周期触发。</span><br><span class="line"></span><br><span class="line">5、考点总结：</span><br><span class="line">-Fiber 提升了 UI 响应性；</span><br><span class="line">-核心思想是 将同步任务分片化；</span><br><span class="line">-React 18 的并发特性基于 Fiber 实现。</span><br></pre></td></tr></table></figure><h3 id="3-2-组件通信"><a href="#3-2-组件通信" class="headerlink" title="3.2 组件通信"></a>3.2 组件通信</h3><p>1、props 和 state 的区别是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Props：父组件传递给子组件的只读数据，驱动单向数据流。</span><br><span class="line">State：组件内部可变数据，通过 setState 或 useState 更新，管理交互逻辑</span><br></pre></td></tr></table></figure><p>2、什么是 prop drilling，如何解决？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">Prop Drilling 是多层组件逐层传递 props 的问题，</span><br><span class="line"></span><br><span class="line">2、解决方案：</span><br><span class="line">-Context API：跨层级共享全局数据（如主题、用户信息）。</span><br><span class="line">-状态管理库：如 Redux、MobX，适合复杂数据共享。</span><br></pre></td></tr></table></figure><p>3、React 中如何通过事件实现组件通信？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子组件通过父组件传入的回调函数（如 onClick）传递数据，父组件更新状态，实现通信。</span><br></pre></td></tr></table></figure><p>4、Context API 的作用和适用场景？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context API 用于全局数据共享（如主题、用户信息），通过 Provider 和 Consumer 或 useContext 访问，适合中等规模应用。</span><br></pre></td></tr></table></figure><p>5、React 组件之间有哪些通信方式？适用场景？</p><table><thead><tr><th align="center">通信方式</th><th align="center">场景</th><th align="center">实现方式</th></tr></thead><tbody><tr><td align="center">Props</td><td align="center">父 → 子</td><td align="center">直接传递属性</td></tr><tr><td align="center">回调函数</td><td align="center">子 → 父</td><td align="center">通过 props 传函数</td></tr><tr><td align="center">Context</td><td align="center">跨层级</td><td align="center">React.createContext + useContext</td></tr><tr><td align="center">全局状态</td><td align="center">多组件共享</td><td align="center">Redux &#x2F; MobX &#x2F; Recoil &#x2F; Zustand</td></tr><tr><td align="center">事件总线</td><td align="center">异步解耦</td><td align="center">mitt &#x2F; EventEmitter</td></tr><tr><td align="center">URL 参数、localStorage</td><td align="center">页面间传递</td><td align="center">Router 或本地存储</td></tr></tbody></table><h3 id="3-3-Hooks-原理"><a href="#3-3-Hooks-原理" class="headerlink" title="3.3 Hooks 原理"></a>3.3 Hooks 原理</h3><p>1、useState 的工作原理是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useState 管理函数组件状态，返回 [state, setState]。</span><br><span class="line"></span><br><span class="line">React 内部：</span><br><span class="line">-用数组按调用顺序存储状态，依赖闭包保持值。</span><br><span class="line">-setState 触发 re-render，更新对应 Hook 节点状态。</span><br></pre></td></tr></table></figure><p>2、useEffect 原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">useEffect 处理副作用（如 DOM 操作、请求、订阅）</span><br><span class="line"></span><br><span class="line">2、分两阶段：</span><br><span class="line">-Render 阶段：注册 effect。</span><br><span class="line">-Commit 阶段：执行清理函数后运行新 effect。</span><br><span class="line"></span><br><span class="line">3、依赖数组：</span><br><span class="line">-[]：仅 mount 时执行。</span><br><span class="line">-[deps]：依赖变化时执行。</span><br><span class="line">-无依赖：每次渲染后执行。</span><br></pre></td></tr></table></figure><p>3、useMemo &#x2F; useCallback 区别</p><table><thead><tr><th align="center">Hook</th><th align="center">返回值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">useMemo(fn, deps)</td><td align="center">计算结果</td><td align="center">缓存计算值，减少重复计算</td></tr><tr><td align="center">useCallback(fn, deps)</td><td align="center">函数</td><td align="center">缓存函数引用，防止子组件重复渲染</td></tr></tbody></table><p>4、useRef 原理及用途</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">useRef 返回可变对象 &#123; current: ... &#125;，不随渲染更新。</span><br><span class="line"></span><br><span class="line">2、用途：</span><br><span class="line"></span><br><span class="line">-访问 DOM 节点。</span><br><span class="line">-存储可变值（如定时器 ID）。</span><br><span class="line">-保持前一状态。</span><br></pre></td></tr></table></figure><p>5、Hooks 的使用规则是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">仅在函数组件或自定义 Hook 顶层调用。</span><br><span class="line">不可在循环、条件或嵌套函数中调用，确保调用顺序一致。</span><br></pre></td></tr></table></figure><h3 id="3-4-Diff-算法"><a href="#3-4-Diff-算法" class="headerlink" title="3.4 Diff 算法"></a>3.4 Diff 算法</h3><p>1、React 的 Diff 算法是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Diff 算法比较新旧 Virtual DOM，计算最小变化集，更新真实 DOM。</span><br><span class="line">假设同级元素类型相同，使用 key 优化列表。</span><br></pre></td></tr></table></figure><p>2、列表中 key 的作用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key 帮助 React 识别列表项的唯一性，优化 diffing 过程，减少不必要 re-render。</span><br><span class="line">key 需唯一且稳定，不建议用索引。</span><br></pre></td></tr></table></figure><p>3、Virtual DOM 如何与 Diff 算法协作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Virtual DOM 是真实 DOM 的轻量表示，Diff 算法在其上计算变化，批量更新真实 DOM，降低操作成本。</span><br></pre></td></tr></table></figure><h3 id="3-5-React-18"><a href="#3-5-React-18" class="headerlink" title="3.5 React 18"></a>3.5 React 18</h3><p>1、React 18 的 Concurrent Rendering 是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">通过 createRoot 启用，允许中断渲染任务，优先处理高优先级更新（如用户交互），提升 UI 响应性。</span><br><span class="line"></span><br><span class="line">2、核心 API：</span><br><span class="line"></span><br><span class="line">-startTransition：标记非紧急更新。</span><br><span class="line">-useTransition：处理延迟状态。</span><br><span class="line">-useDeferredValue：延迟渲染高开销内容。</span><br></pre></td></tr></table></figure><p>2、Suspense 和懒加载如何结合？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Suspense：暂停组件渲染，显示 fallback，等待条件满足（如数据加载）。</span><br><span class="line">React.lazy：动态导入组件，结合 Suspense 实现代码拆分，优化初始加载。</span><br></pre></td></tr></table></figure><p>3、React 18 如何改善用户体验？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React 18 通过时间切片、优先级调度和 Suspense，提升交互流畅性和加载体验。</span><br></pre></td></tr></table></figure><h3 id="3-6-状态管理"><a href="#3-6-状态管理" class="headerlink" title="3.6 状态管理"></a>3.6 状态管理</h3><p>1、状态管理方案对比</p><table><thead><tr><th align="center">库</th><th align="center">特点</th><th align="center">优缺点</th></tr></thead><tbody><tr><td align="center">Redux</td><td align="center">单向数据流、可预测状态</td><td align="center">模板多，生态强大</td></tr><tr><td align="center">MobX</td><td align="center">响应式、面向对象</td><td align="center">上手快，调试复杂</td></tr><tr><td align="center">Recoil</td><td align="center">原子化状态，React 集成</td><td align="center">学习曲线低，社区中等</td></tr><tr><td align="center">Zustand</td><td align="center">轻量简洁，Hooks 驱动，支持 immer</td><td align="center">适合中小项目，API 简单</td></tr></tbody></table><p>2、何时选择全局状态管理？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复杂应用：需要调试工具、中间件或跨组件共享状态时，使用 Redux、MobX 等。</span><br><span class="line">简单场景：useState 或 useContext 足以应对。</span><br></pre></td></tr></table></figure><h3 id="3-7-性能优化"><a href="#3-7-性能优化" class="headerlink" title="3.7 性能优化"></a>3.7 性能优化</h3><p>1、React.memo 的作用是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.memo 缓存函数组件，浅比较 props 避免不必要 re-render，适用于 props 稳定场景。</span><br></pre></td></tr></table></figure><p>2、虚拟化如何优化大列表？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟化(如 react-window)仅渲染视口内元素，回收其他，减少 DOM 节点，优化滚动性能。</span><br></pre></td></tr></table></figure><p>3、如何实现懒加载？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 React.lazy 动态导入组件，结合 Suspense 显示 fallback，减少初始加载大小。</span><br></pre></td></tr></table></figure><p>4、React 性能优化的常见方法？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 memo 避免重渲染、useMemo/useCallback 缓存值/函数、虚拟化大列表、懒加载组件、本地化状态、DevTools 分析瓶颈。</span><br></pre></td></tr></table></figure><p>5、性能优化策略</p><table><thead><tr><th align="center">手段</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">React.memo</td><td align="center">缓存纯组件，浅比较 props 避免重渲染</td></tr><tr><td align="center">useMemo &#x2F; useCallback</td><td align="center">缓存值&#x2F;函数，减少重复计算或子组件重渲染</td></tr><tr><td align="center">虚拟化</td><td align="center">使用 react-window &#x2F; react-virtualized 渲染长列表</td></tr><tr><td align="center">懒加载</td><td align="center">React.lazy + Suspense 动态加载组件，减少初始加载</td></tr><tr><td align="center">代码分割</td><td align="center">通过 Webpack 动态 import 拆分代码</td></tr><tr><td align="center">合并更新</td><td align="center">避免频繁 setState，批量更新状态</td></tr><tr><td align="center">key 使用优化</td><td align="center">使用唯一且稳定的 key 减少列表重渲染</td></tr></tbody></table><p>6、性能分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 React DevTools 定位瓶颈，针对性优化。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——ES6+与现代语法(4)</title>
    <link href="https://pgzxc.github.io/posts/3fbed6d5.html"/>
    <id>https://pgzxc.github.io/posts/3fbed6d5.html</id>
    <published>2025-10-23T01:06:43.000Z</published>
    <updated>2025-11-01T01:39:34.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.语法增强：解构赋值、展开运算符、模板字符串</span><br><span class="line">2.新数据结构：Map/Set/WeakMap/WeakSet</span><br><span class="line">3.模块化：ESM vs CommonJS、Browserify/RequireJS/SeaJS</span><br><span class="line">4.Proxy/Reflect 应用</span><br><span class="line">5.异步：async/await 错误处理、Generator</span><br><span class="line">6.Symbol 的作用</span><br><span class="line">7.新特性：可选链（?.）、空值合并（??）</span><br><span class="line">8.工程特性：Tree-shaking 原理、Babel 工作机制</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-语法增强"><a href="#3-1-语法增强" class="headerlink" title="3.1 语法增强"></a>3.1 语法增强</h3><p>1、什么是解构赋值？有哪些优势和应用场景？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、概念：解构赋值从数组或对象提取值赋给变量，支持默认值和嵌套提取。</span><br><span class="line">2、优势: 代码简洁、可读性强。</span><br><span class="line">3、应用场景: </span><br><span class="line">-交换变量：[a, b] = [b, a]</span><br><span class="line">-函数参数：function printUser(&#123; name, age &#125;) &#123; ... &#125;</span><br><span class="line">-模块导入：const &#123; useState &#125; = require(&#x27;react&#x27;)</span><br><span class="line">-处理多返回值：const [err, data] = await to(fetchData())</span><br><span class="line"></span><br><span class="line">4、示例:</span><br><span class="line">const [a, b = 4] = [1, 2]; // a=1, b=2</span><br><span class="line">const &#123; name, age = 30 &#125; = &#123; name: &#x27;Alice&#x27; &#125;; // name=&#x27;Alice&#x27;, age=30</span><br><span class="line">const [x, y] = [y, x]; // 交换变量</span><br></pre></td></tr></table></figure><p>2、展开运算符和剩余参数有什么区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">-展开运算符 (...) 将可迭代对象/对象展开为单个元素；</span><br><span class="line">-剩余参数 (...) 收集函数多余参数为数组。</span><br><span class="line"></span><br><span class="line">2、区别: </span><br><span class="line">Spread 扩展，Rest 收集。</span><br><span class="line"></span><br><span class="line">3、示例:</span><br><span class="line"></span><br><span class="line">// Spread</span><br><span class="line">const arr = [...[1, 2], 3]; // [1, 2, 3]</span><br><span class="line">const obj = &#123; ...&#123; a: 1 &#125;, b: 2 &#125;; // &#123; a: 1, b: 2 &#125;</span><br><span class="line">// Rest</span><br><span class="line">function sum(...nums) &#123; return nums.reduce((a, b) =&gt; a + b); &#125; // sum(1, 2, 3) = 6</span><br></pre></td></tr></table></figure><p>3、模板字符串的作用是什么？如何支持多行和插值？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、概念：使用反引号（`）支持多行字符串和插值（$&#123;&#125;），无需拼接或转义。</span><br><span class="line">2、作用: 提高字符串处理易用性，适合动态 HTML、日志、i18n。</span><br><span class="line">3、示例:</span><br><span class="line">const name = &#x27;Bob&#x27;;</span><br><span class="line">const greeting = `Hello, $&#123;name&#125;!\nWelcome to ES6.`; // 多行</span><br></pre></td></tr></table></figure><h3 id="3-2-新数据结构"><a href="#3-2-新数据结构" class="headerlink" title="3.2 新数据结构"></a>3.2 新数据结构</h3><p>1、Map 和 Set 与 Object 和 Array 有何区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">Map: 键值对集合，键支持任意类型，可迭代，有 size、has 等方法。</span><br><span class="line">Set: 唯一值集合，自动去重，可迭代。</span><br><span class="line"></span><br><span class="line">2、区别: </span><br><span class="line">Object 键仅限字符串/Symbol，Map 键任意；</span><br><span class="line">Set 适合唯一值，优于 Array。</span><br><span class="line"></span><br><span class="line">3、示例:</span><br><span class="line">const map = new Map().set(&#123; key: true &#125;, &#x27;value&#x27;); // 对象作为键</span><br><span class="line">const set = new Set([1, 2, 2]); // [1, 2]</span><br></pre></td></tr></table></figure><p>2、WeakMap 和 WeakSet 的特点和应用场景是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">WeakMap: 键为对象，弱引用，GC 可回收，不可迭代。</span><br><span class="line">WeakSet: 唯一对象集合，弱引用，GC 可回收。</span><br><span class="line"></span><br><span class="line">2、应用: DOM 元数据、缓存（自动清理）。</span><br><span class="line"></span><br><span class="line">3、示例:</span><br><span class="line">let weakMap = new WeakMap();</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">weakMap.set(obj, &#x27;data&#x27;);</span><br><span class="line">obj = null; // 可被 GC</span><br></pre></td></tr></table></figure><p>3、Map &#x2F; Set &#x2F; WeakMap &#x2F; WeakSet</p><table><thead><tr><th align="center">特性</th><th align="center">Map</th><th align="center">Set</th><th align="center">WeakMap</th><th align="center">WeakSet</th></tr></thead><tbody><tr><td align="center">键类型</td><td align="center">任意类型</td><td align="center">无重复值</td><td align="center">仅对象</td><td align="center">仅对象</td></tr><tr><td align="center">可迭代</td><td align="center">可</td><td align="center">可</td><td align="center">不可</td><td align="center">不可</td></tr><tr><td align="center">GC回收</td><td align="center">不可</td><td align="center">不可</td><td align="center">弱引用</td><td align="center">弱引用</td></tr></tbody></table><h3 id="3-3-模块化"><a href="#3-3-模块化" class="headerlink" title="3.3 模块化"></a>3.3 模块化</h3><p>1、ESM 和 CommonJS 的区别是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">ESM: 静态、异步，import/export，支持 tree-shaking，浏览器/Node 通用。</span><br><span class="line">CommonJS: 同步、动态，require/module.exports，Node 默认。</span><br><span class="line"></span><br><span class="line">2、示例:</span><br><span class="line"></span><br><span class="line">// ESM</span><br><span class="line">export const add = (a, b) =&gt; a + b;</span><br><span class="line">import &#123; add &#125; from &#x27;./math.js&#x27;;</span><br><span class="line">// CommonJS</span><br><span class="line">module.exports.add = (a, b) =&gt; a + b;</span><br><span class="line">const &#123; add &#125; = require(&#x27;./math.js&#x27;);</span><br></pre></td></tr></table></figure><p>2、Browserify、RequireJS、SeaJS 的作用是什么？与 ESM 相比如何？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Browserify: 打包 CommonJS 为浏览器代码。</span><br><span class="line">RequireJS/SeaJS: AMD/CMD 模块加载器，异步加载。</span><br><span class="line">与 ESM 对比: ESM 原生支持，静态分析更高效，现代首选。</span><br></pre></td></tr></table></figure><p>3、ESM vs CommonJS</p><table><thead><tr><th align="center">对比项</th><th align="center">ESM</th><th align="center">CommonJS</th></tr></thead><tbody><tr><td align="center">语法</td><td align="center">import&#x2F;export</td><td align="center">require&#x2F;module.exports</td></tr><tr><td align="center">加载方式</td><td align="center">静态编译时</td><td align="center">运行时加载</td></tr><tr><td align="center">输出引用</td><td align="center">引用绑定（实时）</td><td align="center">值拷贝（缓存）</td></tr><tr><td align="center">环境</td><td align="center">浏览器&#x2F;Node(ESM模式)</td><td align="center">Node默认</td></tr></tbody></table><p>4、模块化演进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、早期方案：</span><br><span class="line">AMD(RequireJS) → 浏览器异步加载</span><br><span class="line">CMD(SeaJS) → 按需加载</span><br><span class="line">CommonJS → Node 环境同步模块</span><br><span class="line"></span><br><span class="line">2、现代方案：</span><br><span class="line">ESM：统一浏览器与 Node 模块规范</span><br></pre></td></tr></table></figure><h3 id="3-4-Proxy-Reflect-应用"><a href="#3-4-Proxy-Reflect-应用" class="headerlink" title="3.4 Proxy&#x2F;Reflect 应用"></a>3.4 Proxy&#x2F;Reflect 应用</h3><p>1、Proxy 的作用和应用场景是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、概念：</span><br><span class="line">Proxy 拦截对象操作（如 get/set/delete）。</span><br><span class="line"></span><br><span class="line">2、应用: </span><br><span class="line">数据校验、响应式系统（如 Vue3）、日志追踪、接口 mock。</span><br><span class="line"></span><br><span class="line">3、示例:</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(&#123; age: 20 &#125;, &#123;</span><br><span class="line">  set: (obj, prop, value) =&gt; &#123;</span><br><span class="line">    if (prop === &#x27;age&#x27; &amp;&amp; value &lt; 0) throw new Error(&#x27;Invalid age&#x27;);</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2、Reflect 的作用是什么？如何与 Proxy 结合？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、概念：</span><br><span class="line">Reflect 提供标准化的对象操作 API，与 Proxy 拦截方法对应，返回布尔值。</span><br><span class="line">2、作用: 规范化操作，搭配 Proxy 实现默认行为转发。</span><br><span class="line">3、示例:</span><br><span class="line"></span><br><span class="line">const proxy = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">  get: (target, prop) =&gt; Reflect.get(target, prop) || &#x27;default&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(proxy.unknown); // &#x27;default&#x27;</span><br></pre></td></tr></table></figure><p>3、Proxy 对比 Object.defineProperty 的优势是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proxy: 拦截 13 种操作，支持数组操作和动态属性。</span><br><span class="line">Object.defineProperty: 仅限 get/set，需预定义属性，数组支持有限。</span><br><span class="line">应用: Proxy 更适合现代响应式系统。</span><br></pre></td></tr></table></figure><h3 id="3-5-异步"><a href="#3-5-异步" class="headerlink" title="3.5 异步"></a>3.5 异步</h3><p>1、async&#x2F;await 如何处理错误？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">使用 try-catch 捕获错误，或封装为 [err, res] = await to(fetchData())。</span><br><span class="line"></span><br><span class="line">2、示例:</span><br><span class="line"></span><br><span class="line">async function fetchData() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const res = await fetch(&#x27;url&#x27;);</span><br><span class="line">    if (!res.ok) throw new Error(`HTTP error: $&#123;res.status&#125;`);</span><br><span class="line">    return await res.json();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, err);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Generator 函数的作用和特点是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念：通过 function* 和 yield 实现可暂停/恢复的函数，返回迭代器。</span><br><span class="line">2、特点: 惰性求值、双向通信。</span><br><span class="line">3、作用: 异步流程控制（如 redux-saga）、自定义迭代器。</span><br><span class="line">4、示例:</span><br><span class="line"></span><br><span class="line">function* gen() &#123; yield 1; yield 2; &#125;</span><br><span class="line">const it = gen();</span><br><span class="line">console.log(it.next().value); // 1</span><br></pre></td></tr></table></figure><h3 id="3-6-Symbol-的作用"><a href="#3-6-Symbol-的作用" class="headerlink" title="3.6 Symbol 的作用"></a>3.6 Symbol 的作用</h3><p>1、Symbol 的作用是什么？为什么不可被 for...in 遍历？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念：Symbol 是唯一、不可变的原始类型，用于对象属性键，避免命名冲突。</span><br><span class="line">2、作用: 模拟私有属性、定义内置行为（如 Symbol.iterator）。</span><br><span class="line">3、不可遍历: Symbol 属性不可枚举，需用 Object.getOwnPropertySymbols() 访问。</span><br><span class="line">4、示例:</span><br><span class="line"></span><br><span class="line">const sym = Symbol(&#x27;id&#x27;);</span><br><span class="line">const obj = &#123; [sym]: 123 &#125;;</span><br><span class="line">console.log(obj[sym]); // 123</span><br></pre></td></tr></table></figure><h3 id="3-7-新特性"><a href="#3-7-新特性" class="headerlink" title="3.7 新特性"></a>3.7 新特性</h3><p>1、可选链 (?.) 的作用是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、概念：安全访问嵌套属性，若中间为 null/undefined，返回 undefined。</span><br><span class="line">2、解决痛点: 避免 Cannot read property &#x27;x&#x27; of undefined 错误。</span><br><span class="line">3、示例:</span><br><span class="line"></span><br><span class="line">const obj = &#123; user: &#123; name: &#x27;Alice&#x27; &#125; &#125;;</span><br><span class="line">console.log(obj?.user?.age); // undefined</span><br></pre></td></tr></table></figure><p>2、空值合并 (??) 与 || 的区别是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念：</span><br><span class="line">?? 仅在 null/undefined 时取默认值；|| 对所有 falsy 值生效（如 0、空字符串）。</span><br><span class="line"></span><br><span class="line">2、示例:</span><br><span class="line"></span><br><span class="line">const val = 0;</span><br><span class="line">console.log(val ?? 10); // 0</span><br><span class="line">console.log(val || 10); // 10</span><br></pre></td></tr></table></figure><h3 id="3-8-工程特性"><a href="#3-8-工程特性" class="headerlink" title="3.8 工程特性"></a>3.8 工程特性</h3><p>1、Tree-shaking 的原理是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、概念：通过静态分析 ESM 的 import/export，移除未使用代码。</span><br><span class="line">2、原理: 标记未用模块，工具（如 Webpack/Rollup）删除。</span><br><span class="line">3、要求: 模块需无副作用。</span><br></pre></td></tr></table></figure><p>2、Babel 的工作机制和作用是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念：Babel 将 ES6+ 代码转为 ES5，兼容旧环境。</span><br><span class="line">2、机制:</span><br><span class="line">-解析：代码转为 AST。</span><br><span class="line">-转换：插件修改 AST。</span><br><span class="line">-生成：输出目标代码。</span><br><span class="line">3、作用: 兼容旧浏览器、支持 JSX/TypeScript、配合 polyfill 填充 API。</span><br><span class="line">4、常用插件: </span><br><span class="line">@babel/preset-env(语法转换)、@babel/plugin-transform-runtime(减少冗余)。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——浏览器与性能(3)</title>
    <link href="https://pgzxc.github.io/posts/4a55ccba.html"/>
    <id>https://pgzxc.github.io/posts/4a55ccba.html</id>
    <published>2025-10-22T01:41:13.000Z</published>
    <updated>2025-11-01T01:39:34.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.渲染机制：HTML/CSS 渲染机制、JS 执行机制、浏览器循环系统</span><br><span class="line">2.渲染流程：DOM + CSSOM → Render Tree → Layout → Paint → Composite</span><br><span class="line">3.重排 vs 重绘</span><br><span class="line">4.缓存策略：强缓存、协商缓存</span><br><span class="line">5.首屏优化：SSR、预渲染、骨架屏、BigPipe</span><br><span class="line">6.跨域解决方案：CORS、JSONP、代理、postMessage</span><br><span class="line">7.Web Worker/Service Worker</span><br><span class="line">8.安全防御：XSS、CSRF、点击劫持</span><br><span class="line">9.浏览器存储：cookie、localStorage、sessionStorage、IndexedDB</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-渲染机制"><a href="#3-1-渲染机制" class="headerlink" title="3.1 渲染机制"></a>3.1 渲染机制</h3><p>1、浏览器的渲染机制是怎样的？HTML、CSS、JS 如何影响渲染？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器渲染机制包括以下步骤：</span><br><span class="line"></span><br><span class="line">HTML解析：生成 DOM 树（Document Object Model）。</span><br><span class="line">CSS解析：生成 CSSOM 树（CSS Object Model）。</span><br><span class="line">JS执行：通过 DOM/CSSOM API 操作页面，JS 单线程运行，依赖事件循环处理异步任务。</span><br><span class="line">渲染树：DOM 树和 CSSOM 树结合生成 Render Tree（仅包含可见元素）。</span><br><span class="line">布局（Layout）：计算元素位置和大小（Reflow）。</span><br><span class="line">绘制（Paint）：将元素绘制为像素，生成图层。</span><br><span class="line">合成（Composite）：将图层合成为最终图像。</span><br><span class="line"></span><br><span class="line">2、JS 执行与事件循环：</span><br><span class="line"></span><br><span class="line">-JS 单线程，同步任务直接执行，异步任务分宏任务(setTimeout、DOM事件)和微任务(Promise、MutationObserver)。</span><br><span class="line">-事件循环(Event Loop)：每次宏任务后清空微任务队列，再取下一个宏任务。</span><br><span class="line"></span><br><span class="line">3、影响：CSSOM 阻塞渲染，JS 可能阻塞 HTML 解析(可用 async/defer 优化)。</span><br></pre></td></tr></table></figure><h3 id="3-2-渲染流程"><a href="#3-2-渲染流程" class="headerlink" title="3.2 渲染流程"></a>3.2 渲染流程</h3><p>1、重排和重绘的区别？如何减少重排？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、流程</span><br><span class="line">-DOM + CSSOM：HTML 生成 DOM 树，CSS 生成 CSSOM 树。</span><br><span class="line">-Render Tree：DOM 和 CSSOM 结合，剔除不可见元素（如 display: none）。</span><br><span class="line">-Layout（回流）：计算元素位置和大小。</span><br><span class="line">-Paint（重绘）：绘制元素像素，生成图层。</span><br><span class="line">-Composite（合成）：GPU 加速合成图层，显示屏幕。</span><br><span class="line"></span><br><span class="line">2、关键点：CSSOM 和 JS 可能阻塞渲染，优化需减少阻塞资源。</span><br></pre></td></tr></table></figure><h3 id="3-3-重排-vs-重绘"><a href="#3-3-重排-vs-重绘" class="headerlink" title="3.3 重排 vs 重绘"></a>3.3 重排 vs 重绘</h3><p>1、重排和重绘的区别是什么？如何减少重排？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">重排(Reflow)：DOM 几何属性（如 width、position）变化，触发布局重新计算，成本高。</span><br><span class="line">重绘(Repaint)：样式变化（如 color）不影响布局，仅重新绘制。</span><br><span class="line"></span><br><span class="line">2、区别：重排触发重绘，重绘不一定触发重排；重排开销更大。</span><br><span class="line"></span><br><span class="line">3、减少重排：</span><br><span class="line">批量修改样式：用 class 替换逐条内联样式。</span><br><span class="line">离线操作 DOM：使用 DocumentFragment 或虚拟 DOM。</span><br><span class="line">使用 transform/opacity：避免触发布局的动画。</span><br><span class="line">缓存布局属性：避免频繁读取 offsetWidth 等。</span><br></pre></td></tr></table></figure><h3 id="3-4-缓存策略"><a href="#3-4-缓存策略" class="headerlink" title="3.4 缓存策略"></a>3.4 缓存策略</h3><p>1、强缓存和协商缓存的区别？如何配置？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、强缓存：直接使用本地缓存，无需请求服务器。</span><br><span class="line"> -实现：Cache-Control: max-age=秒数 或 Expires。</span><br><span class="line"> -特点：返回 200（from cache）。</span><br><span class="line"></span><br><span class="line">2、协商缓存：向服务器验证资源是否更新。</span><br><span class="line"> -实现：ETag/If-None-Match 或 Last-Modified/If-Modified-Since。</span><br><span class="line"> -特点：未修改返回 304，否则返回新资源。</span><br><span class="line"></span><br><span class="line">3、区别：强缓存不发请求，优先级高于协商缓存。</span><br><span class="line"></span><br><span class="line">4、配置：</span><br><span class="line"> -强缓存：Cache-Control: max-age=31536000。</span><br><span class="line"> -协商缓存：服务器返回 ETag 或 Last-Modified。</span><br></pre></td></tr></table></figure><h3 id="3-5-首屏优化"><a href="#3-5-首屏优化" class="headerlink" title="3.5 首屏优化"></a>3.5 首屏优化</h3><p>1、如何优化首屏加载速度？SSR、预渲染、骨架屏、BigPipe 的作用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、目标：缩短用户看到首屏内容的时间。</span><br><span class="line"></span><br><span class="line">2、方案：</span><br><span class="line">-SSR（服务端渲染）：服务端生成 HTML，首屏快，SEO 友好，但服务器压力大。</span><br><span class="line">-预渲染：构建时生成静态 HTML，适合固定内容，首屏快但动态内容需处理。</span><br><span class="line">-骨架屏：加载时显示占位 UI，提升用户体验，用 CSS/HTML 实现。</span><br><span class="line">-BigPipe：分块传输 HTML，优先渲染关键内容。</span><br><span class="line"></span><br><span class="line">3、其他：</span><br><span class="line">-压缩资源（JS/CSS/图片）。</span><br><span class="line">-懒加载非首屏资源。</span><br><span class="line">-使用 async/defer 加载 JS，启用 CDN 和 HTTP/2。</span><br></pre></td></tr></table></figure><h3 id="3-6-跨域解决方案"><a href="#3-6-跨域解决方案" class="headerlink" title="3.6 跨域解决方案"></a>3.6 跨域解决方案</h3><p>1、什么是跨域？有哪些跨域解决方案？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、跨域：浏览器同源策略限制不同源（协议、域名、端口）资源访问。</span><br><span class="line"></span><br><span class="line">2、解决方案：</span><br><span class="line">-CORS：服务器设置 Access-Control-Allow-Origin，支持复杂/简单请求。</span><br><span class="line">-JSONP：利用 &lt;script&gt; 无跨域限制，仅支持 GET，安全性低。</span><br><span class="line">-代理：同源服务器转发请求（Nginx/Node.js）。</span><br><span class="line">-postMessage：HTML5 API，适用于 iframe/window 通信。</span><br></pre></td></tr></table></figure><h3 id="3-7-Web-Worker-Service-Worker"><a href="#3-7-Web-Worker-Service-Worker" class="headerlink" title="3.7 Web Worker &#x2F; Service Worker"></a>3.7 Web Worker &#x2F; Service Worker</h3><p>1、Web Worker 和 Service Worker 的区别和用途？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、Web Worker：</span><br><span class="line"></span><br><span class="line">-用途：独立线程运行 JS，处理复杂计算（如图像处理），避免阻塞主线程。</span><br><span class="line">-特点：无 DOM 访问，通过 postMessage 通信。</span><br><span class="line">-示例：new Worker(&#x27;worker.js&#x27;)。</span><br><span class="line"></span><br><span class="line">2、Service Worker：</span><br><span class="line"></span><br><span class="line">-用途：后台拦截网络请求，支持离线缓存、PWA，需 HTTPS。</span><br><span class="line">-特点：拦截 fetch 请求，生命周期包括 install、activate、fetch。</span><br><span class="line">-示例：navigator.serviceWorker.register(&#x27;sw.js&#x27;)。</span><br><span class="line"></span><br><span class="line">3、区别：Web Worker 专注计算，Service Worker 专注网络和缓存。</span><br></pre></td></tr></table></figure><h3 id="3-8-安全防御"><a href="#3-8-安全防御" class="headerlink" title="3.8 安全防御"></a>3.8 安全防御</h3><p>1、前端如何防御 XSS、CSRF 和点击劫持？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、XSS（跨站脚本攻击）：</span><br><span class="line"> -攻击：注入恶意脚本窃取数据。</span><br><span class="line"> -防御：转义输出（用 textContent）、使用 CSP、框架自动转义。</span><br><span class="line"></span><br><span class="line">2、CSRF（跨站请求伪造）：</span><br><span class="line"> -攻击：伪造用户请求执行恶意操作。</span><br><span class="line"> -防御：CSRF Token、SameSite Cookie（Strict/Lax）、验证 Referer。</span><br><span class="line"></span><br><span class="line">3、点击劫持：</span><br><span class="line"> -攻击：通过透明 iframe 诱导点击。</span><br><span class="line"> -防御：设置 X-Frame-Options: DENY 或 CSP frame-ancestors。</span><br></pre></td></tr></table></figure><h3 id="3-9-浏览器存储"><a href="#3-9-浏览器存储" class="headerlink" title="3.9 浏览器存储"></a>3.9 浏览器存储</h3><p>1、cookie、localStorage、sessionStorage、IndexedDB 的区别和使用场景？</p><table><thead><tr><th align="center">存储方式</th><th align="center">容量</th><th align="center">生命周期</th><th align="center">访问方式</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">Cookie</td><td align="center">~4KB</td><td align="center">可设置过期时间</td><td align="center">客户端&#x2F;服务端</td><td align="center">用户认证、跟踪用户行为</td></tr><tr><td align="center">localStorage</td><td align="center">~5-10MB</td><td align="center">永久(手动清除)</td><td align="center">客户端(同源)</td><td align="center">持久化存储(如用户设置)</td></tr><tr><td align="center">sessionStorage</td><td align="center">~5-10MB</td><td align="center">页面会话(关闭标签失效)</td><td align="center">客户端(同源)</td><td align="center">临时数据(如表单数据)</td></tr><tr><td align="center">IndexedDB</td><td align="center">较大(~GB)</td><td align="center">永久(手动清除)</td><td align="center">客户端(异步API)</td><td align="center">复杂数据存储(如离线应用)</td></tr></tbody></table><p>区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie：随请求自动发送，适合服务端交互。</span><br><span class="line">localStorage/sessionStorage：简单键值存储，客户端操作，sessionStorage生命周期短。</span><br><span class="line">IndexedDB：支持复杂查询，适合大数据量存储。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——JavaScript(2)</title>
    <link href="https://pgzxc.github.io/posts/27712fd6.html"/>
    <id>https://pgzxc.github.io/posts/27712fd6.html</id>
    <published>2025-10-21T01:25:26.000Z</published>
    <updated>2025-11-01T01:39:34.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.变量声明：var/let/const</span><br><span class="line">2.数据类型：基本 vs 引用，null vs undefined</span><br><span class="line">3.值/引用传递：浅拷贝 vs 深拷贝</span><br><span class="line">4.运算符：== vs ===</span><br><span class="line">5.闭包：原理与应用</span><br><span class="line">6.原型链与继承机制</span><br><span class="line">7.this 绑定：规则与箭头函数区别</span><br><span class="line">8.事件机制：冒泡、捕获、阻止冒泡</span><br><span class="line">9.异步编程：Promise、async/await、回调、事件循环（宏任务/微任务）</span><br><span class="line">10.函数式编程：高阶函数、纯函数、柯里化</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-变量声明"><a href="#3-1-变量声明" class="headerlink" title="3.1 变量声明"></a>3.1 变量声明</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.var: 函数作用域，存在变量提升（hoisting），允许重复声明和重新赋值，易导致作用域问题。</span><br><span class="line">2.let: 块级作用域，无变量提升，存在暂时性死区（TDZ），不可重复声明，可重新赋值。</span><br><span class="line">3.const: 块级作用域，无变量提升，存在 TDZ，不可重复声明，不可重新赋值（引用类型可修改内部属性）。</span><br></pre></td></tr></table></figure><p>1、var、let 和 const 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">var: 函数作用域，变量提升，允许重复声明，初始化为 undefined。</span><br><span class="line">let: 块级作用域，TDZ，适合需要重新赋值的场景（如循环计数器）。</span><br><span class="line">const: 块级作用域，声明时必须初始化，适合常量或引用类型（如配置对象）。</span><br><span class="line">应用场景: 优先用 const，需重新赋值时用 let，避免 var 以减少作用域问题。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">var x = 1;</span><br><span class="line">if (true) &#123;</span><br><span class="line">  var x = 2; // 覆盖全局 x</span><br><span class="line">  let y = 3; // 块级作用域</span><br><span class="line">&#125;</span><br><span class="line">console.log(x); // 2</span><br><span class="line">console.log(y); // ReferenceError</span><br><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">obj.a = 2; // 允许修改属性</span><br></pre></td></tr></table></figure><p>2、变量提升如何影响 var、let 和 const？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">var: 声明提升，初始化为 undefined。</span><br><span class="line">let/const: 声明提升但存在 TDZ，访问前抛 ReferenceError。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 1;</span><br><span class="line">console.log(b); // ReferenceError</span><br><span class="line">let b = 2;</span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line"></span><br><span class="line">优先使用 const 和 let，var 已不推荐。</span><br><span class="line">注意 TDZ 和 const 引用类型的可修改性。</span><br></pre></td></tr></table></figure><h3 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.基本类型: number、string、boolean、null、undefined、symbol、bigint，按值存储，比较值。</span><br><span class="line">2.引用类型: object（包括 array、function 等），按引用存储，比较地址。</span><br><span class="line">3.null vs undefined:</span><br><span class="line"></span><br><span class="line">-undefined: 变量声明未初始化、函数无返回值、对象属性不存在。</span><br><span class="line">-null: 主动设为空对象指针。</span><br><span class="line">-比较: null == undefined 为 true，null === undefined 为 false。</span><br></pre></td></tr></table></figure><p>1、基本类型和引用类型的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">基本类型值不可变，按值传递；引用类型存储地址，修改影响原对象。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">let a = 1, b = a;</span><br><span class="line">b = 2;</span><br><span class="line">console.log(a); // 1</span><br><span class="line">let obj1 = &#123; x: 1 &#125;, obj2 = obj1;</span><br><span class="line">obj2.x = 2;</span><br><span class="line">console.log(obj1.x); // 2</span><br></pre></td></tr></table></figure><p>2、null 和 undefined 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">undefined: 表示“缺少值”，默认未初始化。</span><br><span class="line">null: 表示“无对象”，常用于重置。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">console.log(typeof null); // &quot;object&quot; (历史遗留 bug)</span><br><span class="line">console.log(null == undefined); // true</span><br><span class="line">console.log(null === undefined); // false</span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line">注意 typeof null 的历史遗留问题。</span><br><span class="line">引用类型操作需小心，避免意外修改。</span><br></pre></td></tr></table></figure><h3 id="3-3-值-引用传递"><a href="#3-3-值-引用传递" class="headerlink" title="3.3 值&#x2F;引用传递"></a>3.3 值&#x2F;引用传递</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.值传递: 基本类型传递值副本，互不影响。</span><br><span class="line">2.引用传递: 引用类型传递地址副本，修改影响原对象。</span><br><span class="line">3.浅拷贝: 复制顶层属性，嵌套对象共享引用（如 Object.assign, ...）。</span><br><span class="line">4.深拷贝: 递归复制所有层（如 JSON.parse(JSON.stringify(obj)), lodash cloneDeep）。</span><br></pre></td></tr></table></figure><p>1、JavaScript 是按值传递还是按引用传递？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统一按值传递，基本类型传递值，引用类型传递地址副本</span><br></pre></td></tr></table></figure><p>2、浅拷贝和深拷贝的区别及实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">浅拷贝只复制顶层，深拷贝复制所有层。</span><br><span class="line"></span><br><span class="line">2、实现:</span><br><span class="line">-浅拷贝: Object.assign(&#123;&#125;, obj) 或 &#123; ...obj &#125;</span><br><span class="line">-深拷贝: JSON.parse(JSON.stringify(obj))（有限制）或递归函数。</span><br><span class="line"></span><br><span class="line">3、代码示例:</span><br><span class="line">let obj = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;</span><br><span class="line">let shallow = &#123; ...obj &#125;;</span><br><span class="line">let deep = JSON.parse(JSON.stringify(obj));</span><br><span class="line">shallow.b.c = 3;</span><br><span class="line">console.log(obj.b.c); // 3</span><br><span class="line">deep.b.c = 4;</span><br><span class="line">console.log(obj.b.c); // 3</span><br><span class="line"></span><br><span class="line">4、重点</span><br><span class="line">深拷贝需处理循环引用、特殊类型。</span><br><span class="line">浅拷贝性能高但易导致意外修改。</span><br></pre></td></tr></table></figure><h3 id="3-4-运算符"><a href="#3-4-运算符" class="headerlink" title="3.4 运算符"></a>3.4 运算符</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.==: 松散相等，进行类型转换，规则复杂。</span><br><span class="line">2.===: 严格相等，值和类型必须相同，推荐使用。</span><br></pre></td></tr></table></figure><p>1、&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">==: 转换类型后比较，可能导致意外结果（如 [] == 0 为 true）。</span><br><span class="line">===: 不转换类型，推荐优先使用。</span><br><span class="line"></span><br><span class="line">2、代码示例</span><br><span class="line">console.log(&#x27;1&#x27; == 1); // true</span><br><span class="line">console.log(&#x27;1&#x27; === 1); // false</span><br><span class="line">console.log([] == 0); // true</span><br></pre></td></tr></table></figure><p>2、&#x3D;&#x3D; 类型转换规则？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">优先转数字，对象调用 valueOf 或 toString。</span><br><span class="line">示例: [] == 0 中，[] 转为 &#x27;&#x27;，再转为 0。</span><br><span class="line"></span><br><span class="line">2、重点</span><br><span class="line">优先使用 ===，仅在明确需要类型转换（如 value == null）时用 ==。</span><br></pre></td></tr></table></figure><h3 id="3-5-闭包"><a href="#3-5-闭包" class="headerlink" title="3.5 闭包"></a>3.5 闭包</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.闭包: 函数记住并访问其外部词法作用域的变量，即使外部函数执行结束。</span><br><span class="line">2.原理: 词法作用域链，外部变量被引用后不被垃圾回收。</span><br><span class="line">3.应用: 私有变量、工厂函数、节流/防抖。</span><br></pre></td></tr></table></figure><p>1、什么是闭包？原理是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">闭包是函数与其外部词法环境的组合，依赖作用域链实现。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">function createCounter() &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line">  return () =&gt; count++;</span><br><span class="line">&#125;</span><br><span class="line">const counter = createCounter();</span><br><span class="line">console.log(counter()); // 0</span><br><span class="line">console.log(counter()); // 1</span><br></pre></td></tr></table></figure><p>2、闭包的应用场景？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">数据私有化、模块化、节流/防抖、柯里化。</span><br><span class="line"></span><br><span class="line">2、代码示例（节流）:</span><br><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">  let last = 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const now = Date.now();</span><br><span class="line">    if (now - last &gt; wait) &#123;</span><br><span class="line">      fn.apply(this, arguments);</span><br><span class="line">      last = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line">闭包可能导致内存泄漏，需谨慎管理。</span><br><span class="line">常用于封装和状态保持。</span><br></pre></td></tr></table></figure><h3 id="3-6-原型链与继承机制"><a href="#3-6-原型链与继承机制" class="headerlink" title="3.6 原型链与继承机制"></a>3.6 原型链与继承机制</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.原型链: 对象通过 __proto__ 链接到原型，属性查找沿链向上。</span><br><span class="line">2.继承: 通过设置 prototype 或 ES6 class/extends 实现。</span><br><span class="line">3.ES6 前: 组合继承、寄生组合继承。</span><br><span class="line">4.ES6: class/extends 语法糖。</span><br></pre></td></tr></table></figure><p>1、原型链如何工作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">属性查找沿 __proto__ 链到 Object.prototype 或 null。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype.say = () =&gt; console.log(&quot;Hi&quot;);</span><br><span class="line">const p = new Person();</span><br><span class="line">p.say(); // Hi</span><br></pre></td></tr></table></figure><p>2、继承的实现方式？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">ES6 前: Child.prototype = new Parent()（需重置 constructor）。</span><br><span class="line">ES6: class Child extends Parent &#123;&#125;。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">class Parent &#123; say() &#123; return &quot;Parent&quot;; &#125; &#125;</span><br><span class="line">class Child extends Parent &#123;&#125;</span><br><span class="line">console.log(new Child().say()); // Parent</span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line"></span><br><span class="line">原型链是继承核心，注意共享问题。</span><br><span class="line">ES6 class 更直观但仍基于原型。</span><br></pre></td></tr></table></figure><h3 id="3-7-this-绑定"><a href="#3-7-this-绑定" class="headerlink" title="3.7 this 绑定"></a>3.7 this 绑定</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、this 绑定规则:</span><br><span class="line">-默认绑定: 全局（window/undefined）。</span><br><span class="line">-隐式绑定: 调用对象。</span><br><span class="line">-显式绑定: call/apply/bind。</span><br><span class="line">-new 绑定: 新实例。</span><br><span class="line"></span><br><span class="line">2、箭头函数: 无自身 this，继承外层词法作用域的 this。</span><br></pre></td></tr></table></figure><p>1、this 的绑定规则？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">取决于调用上下文，优先级: new &gt; 显式 &gt; 隐式 &gt; 默认。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">javascriptconst obj = &#123; x: 1, fn() &#123; console.log(this.x); &#125; &#125;;</span><br><span class="line">obj.fn(); // 1</span><br><span class="line">const fn = obj.fn;</span><br><span class="line">fn(); // undefined (严格模式)</span><br></pre></td></tr></table></figure><p>2、箭头函数的 this 与普通函数区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">箭头函数的 this 在定义时绑定，无法通过 call/apply/bind 改变。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">const obj = &#123;</span><br><span class="line">  x: 1,</span><br><span class="line">  fn: () =&gt; console.log(this.x),</span><br><span class="line">  fn2() &#123; console.log(this.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn(); // undefined</span><br><span class="line">obj.fn2(); // 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line">-箭头函数适合回调，避免 this 动态变化。</span><br><span class="line">-注意严格模式下默认绑定的 undefined</span><br></pre></td></tr></table></figure><h3 id="3-8-事件机制"><a href="#3-8-事件机制" class="headerlink" title="3.8 事件机制"></a>3.8 事件机制</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、事件流: 捕获（根到目标）→ 目标 → 冒泡（目标到根）。</span><br><span class="line">2、阻止方法:</span><br><span class="line">-e.stopPropagation(): 阻止冒泡/捕获。</span><br><span class="line">-e.preventDefault(): 阻止默认行为。</span><br><span class="line">-e.stopImmediatePropagation(): 阻止后续监听器。</span><br></pre></td></tr></table></figure><p>1、事件冒泡和捕获的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">捕获从外到内，冒泡从内到外，默认冒泡。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;, () =&gt; console.log(&quot;capture&quot;), true);</span><br><span class="line">document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;, () =&gt; console.log(&quot;bubble&quot;));</span><br></pre></td></tr></table></figure><p>2、如何阻止事件传播？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">用 e.stopPropagation() 阻止传播，e.preventDefault() 阻止默认行为。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">document.querySelector(&quot;a&quot;).addEventListener(&quot;click&quot;, (e) =&gt; &#123;</span><br><span class="line">  e.preventDefault(); // 阻止跳转</span><br><span class="line">  e.stopPropagation(); // 阻止冒泡</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line">-默认冒泡，捕获需明确指定。</span><br><span class="line">-注意区分 stopPropagation 和 preventDefault。</span><br></pre></td></tr></table></figure><h3 id="3-9-异步编程"><a href="#3-9-异步编程" class="headerlink" title="3.9 异步编程"></a>3.9 异步编程</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.事件循环: 单线程，同步 → 微任务（Promise.then）→ 宏任务（setTimeout）。</span><br><span class="line">2.回调: 传统异步，易导致回调地狱。</span><br><span class="line">3.Promise: 对象化异步，状态管理（pending/fulfilled/rejected）。</span><br><span class="line">4.async/await: Promise 语法糖，同步风格。</span><br></pre></td></tr></table></figure><p>1、事件循环、宏任务和微任务的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">宏任务: setTimeout、setInterval、I/O。</span><br><span class="line">微任务: Promise.then、MutationObserver。</span><br><span class="line">循环: 同步 → 微任务 → 渲染 → 宏任务。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">console.log(1);</span><br><span class="line">setTimeout(() =&gt; console.log(2));</span><br><span class="line">Promise.resolve().then(() =&gt; console.log(3));</span><br><span class="line">console.log(4);</span><br><span class="line">// 输出: 1, 4, 3, 2</span><br></pre></td></tr></table></figure><p>2、Promise、async&#x2F;await 和回调的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">回调: 嵌套复杂，错误处理麻烦。</span><br><span class="line">Promise: 链式调用，统一错误处理。</span><br><span class="line">async/await: 更简洁，适合复杂异步逻辑。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">async function fetchData() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const res = await fetch(&quot;url&quot;);</span><br><span class="line">    return await res.json();</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line"></span><br><span class="line">-微任务优先于宏任务。</span><br><span class="line">-async/await 提高代码可读性</span><br></pre></td></tr></table></figure><h3 id="3-10-函数式编程"><a href="#3-10-函数式编程" class="headerlink" title="3.10 函数式编程"></a>3.10 函数式编程</h3><p>面试考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.纯函数: 相同输入相同输出，无副作用。</span><br><span class="line">2.高阶函数: 接受/返回函数（如 map、filter）。</span><br><span class="line">3.柯里化: 多参数函数转为单参数函数链。</span><br></pre></td></tr></table></figure><p>1、纯函数和高阶函数是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">纯函数: 确定性、无副作用，易测试。</span><br><span class="line">高阶函数: 增强复用性，如 array.map(x =&gt; x * 2)。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">const add = (a, b) =&gt; a + b; // 纯函数</span><br><span class="line">const map = (fn, arr) =&gt; arr.map(fn); // 高阶函数</span><br></pre></td></tr></table></figure><p>2、柯里化的定义和实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、概念</span><br><span class="line">将 f(a, b) 转为 f(a)(b)，利用闭包。</span><br><span class="line"></span><br><span class="line">2、代码示例:</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">  return function curried(...args) &#123;</span><br><span class="line">    if (args.length &gt;= fn.length) return fn(...args);</span><br><span class="line">    return (...next) =&gt; curried(...args, ...next);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const add = curry((a, b) =&gt; a + b);</span><br><span class="line">console.log(add(1)(2)); // 3</span><br><span class="line"></span><br><span class="line">3、重点</span><br><span class="line"></span><br><span class="line">-纯函数提高可测试性。</span><br><span class="line">-柯里化适合参数复用和延迟执行。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Web前端高频面试题——HTML&amp;CSS(1)</title>
    <link href="https://pgzxc.github.io/posts/8d4570fa.html"/>
    <id>https://pgzxc.github.io/posts/8d4570fa.html</id>
    <published>2025-10-20T00:19:26.000Z</published>
    <updated>2025-11-01T01:39:34.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文题目来自于：</span><br><span class="line"> - 面试招聘要求</span><br><span class="line"> - 网友分享</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试要求和面试题"><a href="#二-面试要求和面试题" class="headerlink" title="二  面试要求和面试题"></a>二  面试要求和面试题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.HTML5 新特性：语义化标签、音视频、Canvas、WebSocket、LocalStorage 等</span><br><span class="line">2.语义化意义：可读性、SEO、无障碍化</span><br><span class="line">3.常见标签：行内元素 vs 块级元素</span><br><span class="line">4.BFC(块级格式化上下文)：概念、触发方式</span><br><span class="line">5.CSS3 新特性：Flex、Grid、动画、过渡、变量</span><br><span class="line">6.定位：relative/absolute/fixed/sticky 区别</span><br><span class="line">7.元素显示模式：inline、inline-block、block</span><br><span class="line">8.布局与适配：响应式布局方案、rem/em/vw/vh/px 区别与应用</span><br><span class="line">9.CSS 优先级：权重计算方式</span><br><span class="line">10.CSS 预处理/架构：Less、Sass、Stylus、BEM</span><br><span class="line">11.页面架构和布局：组件化/模块化/工程化思想</span><br><span class="line">12.性能优化：减少重排重绘、合并样式、压缩、CDN</span><br></pre></td></tr></table></figure><h3 id="三-面试题解答-仅供参考"><a href="#三-面试题解答-仅供参考" class="headerlink" title="三 面试题解答(仅供参考)"></a>三 面试题解答(仅供参考)</h3><h3 id="3-1-HTML5-新特性"><a href="#3-1-HTML5-新特性" class="headerlink" title="3.1 HTML5 新特性"></a>3.1 HTML5 新特性</h3><p>1、HTML5 的主要新特性有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语义化标签：&lt;header&gt;、&lt;footer&gt;、&lt;article&gt; —&gt; 提高可读性、SEO、无障碍支持</span><br><span class="line">多媒体：&lt;audio&gt;、&lt;video&gt; —&gt; 原生支持音视频播放</span><br><span class="line">图形：&lt;canvas&gt;（JS绘图）、&lt;svg&gt;（矢量图）</span><br><span class="line">存储：localStorage、sessionStorage、IndexedDB —&gt;  本地大容量存储</span><br><span class="line">通信：WebSocket —&gt; 全双工实时通信</span><br><span class="line">表单增强：&lt;input type=&quot;email/date/range&quot;&gt;</span><br></pre></td></tr></table></figure><p>2、语义化标签 &#x2F; 音视频 &#x2F; Canvas &#x2F; WebSocket &#x2F; LocalStorage 的作用和场景？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语义化：结构清晰、SEO 友好（如 &lt;article&gt; 包裹文章）</span><br><span class="line">音视频：无需 Flash，原生 &lt;video src=&quot;xx&quot; controls&gt;</span><br><span class="line">Canvas：JS 动态绘图，游戏、图表</span><br><span class="line">WebSocket：实时通信（聊天室/股票推送）</span><br><span class="line">LocalStorage：持久化键值存储(5MB+)，适合离线应用</span><br></pre></td></tr></table></figure><p>3、HTML5 离线缓存如何实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旧方案：Application Cache + manifest（已废弃）</span><br><span class="line">新方案：PWA + Service Worker（动态缓存、离线支持）</span><br></pre></td></tr></table></figure><h3 id="3-2-语义化意义"><a href="#3-2-语义化意义" class="headerlink" title="3.2 语义化意义"></a>3.2 语义化意义</h3><p>1、什么是 HTML 语义化？为什么重要？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：用合适标签表达内容含义(如 &lt;nav&gt; 代替 &lt;div&gt;)</span><br><span class="line">意义：提高可维护性、利于 SEO、方便读屏器解析、无样式时也有清晰结构</span><br><span class="line">应用：博客用 &lt;article&gt; + &lt;section&gt;；导航用 &lt;nav&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-行内-vs-块级元素"><a href="#3-3-行内-vs-块级元素" class="headerlink" title="3.3 行内 vs 块级元素"></a>3.3 行内 vs 块级元素</h3><p>1、行内元素和块级元素的区别？</p><table><thead><tr><th align="center">特性</th><th align="center">块级元素</th><th align="center">行内元素</th><th align="center">inline-block</th></tr></thead><tbody><tr><td align="center">排列</td><td align="center">独占一行</td><td align="center">同行排列</td><td align="center">同行排列</td></tr><tr><td align="center">宽高</td><td align="center">可设置</td><td align="center">不可设置</td><td align="center">可设置</td></tr><tr><td align="center">margin&#x2F;padding</td><td align="center">全支持</td><td align="center">垂直方向无效</td><td align="center">全支持</td></tr><tr><td align="center">示例</td><td align="center">div、p、ul</td><td align="center">span、a、em</td><td align="center">img、button</td></tr></tbody></table><p>2、如何转换显示模式？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过 display: block/inline/inline-block。</span><br></pre></td></tr></table></figure><h3 id="3-4-BFC-块级格式化上下文"><a href="#3-4-BFC-块级格式化上下文" class="headerlink" title="3.4 BFC(块级格式化上下文)"></a>3.4 BFC(块级格式化上下文)</h3><p>1、什么是 BFC？如何触发？有什么作用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概念：独立渲染区域，内部布局不影响外部</span><br><span class="line">触发：overflow≠visible、float≠none、display:inline-block/flex/grid、position:absolute/fixed</span><br><span class="line">作用：清除浮动、避免 margin 重叠、防止文字环绕</span><br></pre></td></tr></table></figure><h3 id="3-5-CSS3-新特性"><a href="#3-5-CSS3-新特性" class="headerlink" title="3.5 CSS3 新特性"></a>3.5 CSS3 新特性</h3><p>1、CSS3 的核心新特性有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">布局：Flex（一维）、Grid（二维）</span><br><span class="line">动效：transition（过渡）、@keyframes/animation（动画）</span><br><span class="line">样式：变量 --var、圆角 border-radius、阴影 box-shadow</span><br><span class="line">增强选择器：:nth-child()、:not()</span><br></pre></td></tr></table></figure><p>2、Flex 和 Grid 有什么区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flex：一维布局（单行/列），适合导航、居中</span><br><span class="line">Grid：二维布局，适合整体页面网格</span><br></pre></td></tr></table></figure><p>3、transition 和 animation 区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transition：事件触发，一次性</span><br><span class="line">animation：可自动执行，可循环</span><br></pre></td></tr></table></figure><h3 id="3-6-定位"><a href="#3-6-定位" class="headerlink" title="3.6 定位"></a>3.6 定位</h3><p>1、relative&#x2F;absolute&#x2F;fixed&#x2F;sticky区别及应用？</p><table><thead><tr><th align="center">定位方式</th><th align="center">参考点</th><th align="center">脱离文档流</th><th align="center">场景</th></tr></thead><tbody><tr><td align="center">relative</td><td align="center">自身</td><td align="center">否</td><td align="center">元素微调</td></tr><tr><td align="center">absolute</td><td align="center">最近定位祖先</td><td align="center">是</td><td align="center">弹窗、下拉</td></tr><tr><td align="center">fixed</td><td align="center">视口</td><td align="center">是</td><td align="center">固定导航</td></tr><tr><td align="center">sticky</td><td align="center">滚动阈值</td><td align="center">否</td><td align="center">吸顶效果</td></tr></tbody></table><h3 id="3-7-元素显示模式"><a href="#3-7-元素显示模式" class="headerlink" title="3.7 元素显示模式"></a>3.7 元素显示模式</h3><p>1、block、inline、inline-block 的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block：独占一行，可设宽高</span><br><span class="line">inline：不独占，宽高无效，margin/padding 垂直方向无效</span><br><span class="line">inline-block：不独占，可设宽高，常用于按钮/导航</span><br></pre></td></tr></table></figure><h3 id="3-8-布局与适配"><a href="#3-8-布局与适配" class="headerlink" title="3.8 布局与适配"></a>3.8 布局与适配</h3><p>1、如何实现响应式布局？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、方法：</span><br><span class="line">媒体查询 @media、流式布局 %、Flex/Grid、栅格系统</span><br><span class="line"></span><br><span class="line">2、单位：</span><br><span class="line">px：绝对像素，精确控制</span><br><span class="line">em：相对父元素字体</span><br><span class="line">rem：相对根元素字体，常用于移动端</span><br><span class="line">vw/vh：视口百分比，全屏自适应</span><br></pre></td></tr></table></figure><p>2、常见的响应式布局方案有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">流式布局（百分比宽度）</span><br><span class="line">媒体查询（@media screen and (max-width:768px)）</span><br><span class="line">弹性布局（Flex、Grid）</span><br><span class="line">栅格系统（12 列布局）</span><br><span class="line">相对单位（rem、vw/vh）</span><br></pre></td></tr></table></figure><h3 id="3-9-CSS-优先级"><a href="#3-9-CSS-优先级" class="headerlink" title="3.9 CSS 优先级"></a>3.9 CSS 优先级</h3><p>1、CSS 优先级如何计算？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内联样式：1000</span><br><span class="line">ID 选择器：100</span><br><span class="line">类/伪类/属性选择器：10</span><br><span class="line">标签/伪元素：1</span><br><span class="line">继承/通配符：0</span><br><span class="line">规则：!important &gt; 内联 &gt; ID &gt; 类 &gt; 标签</span><br></pre></td></tr></table></figure><h3 id="3-10-CSS-预处理-架构"><a href="#3-10-CSS-预处理-架构" class="headerlink" title="3.10 CSS 预处理&#x2F;架构"></a>3.10 CSS 预处理&#x2F;架构</h3><p>1、什么是 CSS 预处理器？常见的有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义：对 CSS 增强，支持变量、嵌套、mixin</span><br><span class="line">工具：Less（轻量）、Sass（强大，支持函数/循环）、Stylus（简洁）</span><br></pre></td></tr></table></figure><p>2、BEM 命名规范是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Block__Element--Modifier，例如 .btn__icon--large</span><br><span class="line">作用：避免冲突，模块化，适合大型项目</span><br></pre></td></tr></table></figure><h3 id="3-11-页面架构和布局"><a href="#3-11-页面架构和布局" class="headerlink" title="3.11 页面架构和布局"></a>3.11 页面架构和布局</h3><p>1、HTML&#x2F;CSS 工程化思想是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组件化：复用 UI（如按钮组件）</span><br><span class="line">模块化：CSS Modules / Scoped CSS，避免污染</span><br><span class="line">工程化：Webpack/PostCSS 自动构建、代码分离、压缩优</span><br></pre></td></tr></table></figure><h3 id="3-12-性能优化"><a href="#3-12-性能优化" class="headerlink" title="3.12 性能优化"></a>3.12 性能优化</h3><p>1、如何优化 HTML&#x2F;CSS 性能？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">减少重排/重绘：使用 transform/opacity 替代 top/left；批量修改 DOM；will-change 优化动画</span><br><span class="line">资源优化：合并压缩 CSS，CDN 加速</span><br><span class="line">图片优化：雪碧图、懒加载、WebP</span><br><span class="line">加载优化：CSS 置顶、JS 底部、异步加载</span><br></pre></td></tr></table></figure><p>2、如何减少重排和重绘？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 transform 和 opacity 代替 top/left 修改位置</span><br><span class="line">合并 DOM 操作，使用 DocumentFragment 或 requestAnimationFrame</span><br><span class="line">避免频繁读取布局属性（如 offsetTop、clientWidth）</span><br><span class="line">批量修改样式（修改 class，而不是逐个修改 style）</span><br></pre></td></tr></table></figure><p>3、CSS 层面的常见优化方式有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">压缩合并样式表</span><br><span class="line">使用 CDN 加速</span><br><span class="line">图片优化（雪碧图、懒加载、WebP）</span><br><span class="line">CSS 动画优先（开启 GPU 合成层）</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文题目来自于：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 面试招聘要求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 网友分享&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Web前端面试题" scheme="https://pgzxc.github.io/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>KMP面试题之——专家级之测试与发布(13)</title>
    <link href="https://pgzxc.github.io/posts/d18b404b.html"/>
    <id>https://pgzxc.github.io/posts/d18b404b.html</id>
    <published>2025-10-19T01:01:34.000Z</published>
    <updated>2025-11-01T01:39:34.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.如何在 KMP 项目中进行多平台单元测试？</span><br><span class="line">2.如何配置 commonTest、androidTest、iosTest？</span><br><span class="line">3.如何使用 Ktor MockEngine 测试跨平台网络逻辑？</span><br><span class="line">4.如何发布 KMP 库到 Maven Central？</span><br><span class="line">5.如何在 CI/CD 流程中构建与验证多平台产物？</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-如何在-KMP-项目中进行多平台单元测试？"><a href="#2-1-如何在-KMP-项目中进行多平台单元测试？" class="headerlink" title="2.1 如何在 KMP 项目中进行多平台单元测试？"></a>2.1 如何在 KMP 项目中进行多平台单元测试？</h3><p>1、核心考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试架构、共享逻辑验证、平台差异处理</span><br></pre></td></tr></table></figure><p>2、解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、说明</span><br><span class="line">KMP 支持在 commonTest 层编写一次测试，自动在各平台运行。</span><br><span class="line">通过 Kotlin Test Framework (kotlin(&quot;test&quot;)) 统一测试 API</span><br><span class="line"></span><br><span class="line">2、配置</span><br><span class="line">dependencies &#123;</span><br><span class="line">    commonTestImplementation(kotlin(&quot;test&quot;))</span><br><span class="line">    androidTestImplementation(&quot;androidx.test:runner:1.5.2&quot;)</span><br><span class="line">    iosTestImplementation(kotlin(&quot;test&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、常见测试类型</span><br><span class="line">-业务逻辑测试：测试共享逻辑（Repository、UseCase）。</span><br><span class="line">-期望声明 (expect/actual) 测试：验证平台差异行为。</span><br><span class="line">-MockEngine 网络测试（见问题 3）</span><br><span class="line"></span><br><span class="line">4、运行方式</span><br><span class="line">-./gradlew :shared:allTests 运行全部平台测试。</span><br><span class="line">-或在 IDE 中选择对应 Target（如 Android/iOS Simulator）。</span><br></pre></td></tr></table></figure><p>3、面试关键点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">展现你能统一测试框架、隔离平台特性，并保证 CI 可复现</span><br></pre></td></tr></table></figure><h3 id="2-2-如何配置-commonTest、androidTest、iosTest？"><a href="#2-2-如何配置-commonTest、androidTest、iosTest？" class="headerlink" title="2.2 如何配置 commonTest、androidTest、iosTest？"></a>2.2 如何配置 commonTest、androidTest、iosTest？</h3><p>1、目录结构示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared/</span><br><span class="line"> ├── src/</span><br><span class="line"> │   ├── commonMain/</span><br><span class="line"> │   ├── commonTest/</span><br><span class="line"> │   ├── androidMain/</span><br><span class="line"> │   ├── androidTest/</span><br><span class="line"> │   ├── iosMain/</span><br><span class="line"> │   └── iosTest/</span><br></pre></td></tr></table></figure><p>2、Gradle 配置要点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    androidTarget()</span><br><span class="line">    iosX64()</span><br><span class="line">    iosArm64()</span><br><span class="line">    iosSimulatorArm64()</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        val commonTest by getting &#123;</span><br><span class="line">            dependencies &#123;</span><br><span class="line">                implementation(kotlin(&quot;test&quot;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        val androidTest by getting</span><br><span class="line">        val iosTest by creating &#123;</span><br><span class="line">            dependsOn(commonTest)</span><br><span class="line">            iosX64Test.dependsOn(this)</span><br><span class="line">            iosArm64Test.dependsOn(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、测试执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android → ./gradlew connectedAndroidTest</span><br><span class="line">iOS → ./gradlew iosX64Test 或通过 Xcode scheme。</span><br></pre></td></tr></table></figure><p>4、技巧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对 iOS 使用 iosSimulatorArm64() 可直接在 Apple Silicon Mac 上本地跑测试</span><br></pre></td></tr></table></figure><h3 id="2-3-如何使用-Ktor-MockEngine-测试跨平台网络逻辑？"><a href="#2-3-如何使用-Ktor-MockEngine-测试跨平台网络逻辑？" class="headerlink" title="2.3 如何使用 Ktor MockEngine 测试跨平台网络逻辑？"></a>2.3 如何使用 Ktor MockEngine 测试跨平台网络逻辑？</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跨平台网络层可测性</span><br></pre></td></tr></table></figure><p>2、示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、说明</span><br><span class="line">Ktor 提供 MockEngine，用于拦截网络请求并模拟响应</span><br><span class="line"></span><br><span class="line">2、示例</span><br><span class="line">val mockEngine = MockEngine &#123; request -&gt;</span><br><span class="line">    respond(</span><br><span class="line">        content = &quot;&quot;&quot;&#123;&quot;code&quot;: 200, &quot;data&quot;: &quot;ok&quot;&#125;&quot;&quot;&quot;,</span><br><span class="line">        status = HttpStatusCode.OK,</span><br><span class="line">        headers = headersOf(&quot;Content-Type&quot; to listOf(&quot;application/json&quot;))</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val client = HttpClient(mockEngine)</span><br><span class="line">val api = MyApi(client)</span><br><span class="line">val result = api.fetchData()</span><br><span class="line">assertEquals(&quot;ok&quot;, result)</span><br></pre></td></tr></table></figure><p>3、优点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-不依赖真实服务器。</span><br><span class="line">-支持多平台。</span><br><span class="line">-可精确验证 Header、Body。</span><br></pre></td></tr></table></figure><p>4、面试关键点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">强调「可重复性测试」与「网络层 mock 化能力」</span><br></pre></td></tr></table></figure><h3 id="2-4-如何发布-KMP-库到-Maven-Central？"><a href="#2-4-如何发布-KMP-库到-Maven-Central？" class="headerlink" title="2.4 如何发布 KMP 库到 Maven Central？"></a>2.4 如何发布 KMP 库到 Maven Central？</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">产物管理、版本发布、构建流程。</span><br></pre></td></tr></table></figure><p>2、常用插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(&quot;maven-publish&quot;)</span><br><span class="line">    id(&quot;signing&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、配置示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        withType&lt;MavenPublication&gt; &#123;</span><br><span class="line">            groupId = &quot;io.github.username&quot;</span><br><span class="line">            artifactId = &quot;shared&quot;</span><br><span class="line">            version = &quot;1.0.0&quot;</span><br><span class="line">            from(components[&quot;kotlin&quot;])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&quot;)</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username = findProperty(&quot;ossrhUsername&quot;) as String</span><br><span class="line">                password = findProperty(&quot;ossrhPassword&quot;) as String</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signing &#123;</span><br><span class="line">    sign(publishing.publications)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、要点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gradlew publishToMavenLocal → 本地验证。</span><br><span class="line">gradlew publish → 上传到 Maven Central。</span><br><span class="line">使用 Sonatype 账号审批。</span><br><span class="line">自动化推荐使用 GitHub Actions + secrets。</span><br></pre></td></tr></table></figure><h3 id="2-5-如何在-CI-CD-流程中构建与验证多平台产物？"><a href="#2-5-如何在-CI-CD-流程中构建与验证多平台产物？" class="headerlink" title="2.5 如何在 CI&#x2F;CD 流程中构建与验证多平台产物？"></a>2.5 如何在 CI&#x2F;CD 流程中构建与验证多平台产物？</h3><p>1、核心考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CI 跨平台构建、测试自动化、发布安全性。</span><br></pre></td></tr></table></figure><p>2、常见方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GitHub Actions（推荐）</span><br><span class="line">GitLab CI</span><br><span class="line">CircleCI</span><br></pre></td></tr></table></figure><p>3、示例（GitHub Actions）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: macos-latest</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v4</span><br><span class="line">      - uses: actions/setup-java@v4</span><br><span class="line">        with:</span><br><span class="line">          java-version: 17</span><br><span class="line">          distribution: &#x27;temurin&#x27;</span><br><span class="line">      - uses: gradle/gradle-build-action@v3</span><br><span class="line">      - run: ./gradlew build allTests publishToMavenLocal</span><br></pre></td></tr></table></figure><p>4、验证内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-commonTest 单元测试。</span><br><span class="line">-androidTest 运行于 Emulator。</span><br><span class="line">-iosTest 在 macOS runner 上运行。</span><br><span class="line">-publishToMavenLocal 验证产物结构。</span><br><span class="line">-最终部署到 MavenCentral / GitHub Packages</span><br></pre></td></tr></table></figure><p>5、面试亮点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">展现你能搭建一条「KMP 全端构建流水线」—— 自动构建、测试、签名与发布。</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><table><thead><tr><th align="center">主题</th><th align="center">考察点</th><th align="center">关键亮点</th></tr></thead><tbody><tr><td align="center">测试体系</td><td align="center">commonTest&#x2F;platformTest</td><td align="center">统一逻辑验证、MockEngine 测试</td></tr><tr><td align="center">目录结构</td><td align="center">多平台 sourceSets</td><td align="center">iOS Test dependsOn commonTest</td></tr><tr><td align="center">发布流程</td><td align="center">MavenCentral + GPG</td><td align="center">Gradle publishing &amp; signing</td></tr><tr><td align="center">CI&#x2F;CD</td><td align="center">多平台构建验证</td><td align="center">GitHub Actions 全流程自动化</td></tr><tr><td align="center">能力体现</td><td align="center">可交付、可维护、可测试</td><td align="center">工程化意识与质量保障能力</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.如何在 KMP 项目中进行多平台单元测试？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.如何配置 commonTest、androidTest、iosTest？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.如何使用 Ktor MockEngine 测试跨平台网络逻辑？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.如何发布 KMP 库到 Maven Central？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.如何在 CI/CD 流程中构建与验证多平台产物？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/tags/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>KMP面试题之——专家级之多端同步与扩展(12)</title>
    <link href="https://pgzxc.github.io/posts/ebc325bb.html"/>
    <id>https://pgzxc.github.io/posts/ebc325bb.html</id>
    <published>2025-10-19T00:52:23.000Z</published>
    <updated>2025-11-01T01:39:34.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.如何支持 Web(Kotlin/JS)或 Desktop(Compose Desktop)？</span><br><span class="line">2.Kotlin Multiplatform Compose 与 React/Flutter 在渲染机制上的差异？</span><br><span class="line">3.如何在 KMP 中实现跨端消息总线(SharedFlow + MutableSharedFlow)？</span><br><span class="line">4.如何解决 iOS Swift 与 Kotlin 集成中的包大小与符号冲突问题？</span><br><span class="line">5.如何在 iOS 中处理 KMP Framework 的 ABI 兼容性问题？</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-支持Web或-Desktop"><a href="#2-1-支持Web或-Desktop" class="headerlink" title="2.1 支持Web或 Desktop"></a>2.1 支持Web或 Desktop</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KMP 多平台扩展目标、Kotlin/JS 配置、Compose Multiplatform 渲染体系、资源与依赖管理。</span><br></pre></td></tr></table></figure><p>2、实现思路</p><p>2-1、KMP 支持多平台目标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    androidTarget()</span><br><span class="line">    ios()</span><br><span class="line">    js(IR) &#123;</span><br><span class="line">        browser()  // or nodejs()</span><br><span class="line">    &#125;</span><br><span class="line">    jvm(&quot;desktop&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2-2、Web 端 (Kotlin&#x2F;JS)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Kotlin 编译为 JavaScript（使用 IR 后端，输出 .js 或 .wasm）。</span><br><span class="line">-常用 Compose Multiplatform Web 版本（JetBrains Compose for Web）。</span><br><span class="line">-可通过 compose.html 模块构建 DOM 或 Canvas UI。</span><br><span class="line">-打包方式：Gradle → webpack/bundled.js，部署与 React/Vite 类似。</span><br><span class="line">-数据逻辑依旧复用 shared 层。</span><br></pre></td></tr></table></figure><p>2-3、Desktop 端 (Compose Desktop)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-VM Target，使用 Skia 渲染引擎（与 Android Compose 底层一致）。</span><br><span class="line">-可直接调用 shared 模块业务逻辑：</span><br></pre></td></tr></table></figure><p>2-4、项目结构建议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared/         // 业务逻辑（KMP）</span><br><span class="line">androidApp/</span><br><span class="line">iosApp/</span><br><span class="line">desktopApp/</span><br><span class="line">webApp/</span><br></pre></td></tr></table></figure><p>3、优势</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有端复用 shared 层(Ktor、SQLDelight、ViewModel)。</span><br><span class="line">Compose Desktop/Web 与 Compose Android 共用 Compose Runtime → UI DSL 一致。</span><br></pre></td></tr></table></figure><h3 id="2-2-KMP-与-React-Flutter-在渲染机制上的差异？"><a href="#2-2-KMP-与-React-Flutter-在渲染机制上的差异？" class="headerlink" title="2.2 KMP 与 React&#x2F;Flutter 在渲染机制上的差异？"></a>2.2 KMP 与 React&#x2F;Flutter 在渲染机制上的差异？</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI 框架的底层机制、渲染架构差异、声明式编程模型</span><br></pre></td></tr></table></figure><p>2、差异</p><table><thead><tr><th align="center">框架</th><th align="center">渲染机制</th><th align="center">状态驱动</th><th align="center">UI 引擎</th><th align="center">性能特征</th></tr></thead><tbody><tr><td align="center">Compose Multiplatform</td><td align="center">声明式 + Skia 渲染(Desktop)&#x2F;<br>Android View(Android)&#x2F; <br>DOM(Web)</td><td align="center">State + Recomposition</td><td align="center">平台原生(Android)或 Skia</td><td align="center">高度原生集成，资源轻量</td></tr><tr><td align="center">React</td><td align="center">Virtual DOM Diff</td><td align="center">React Fiber Scheduler</td><td align="center">浏览器 DOM</td><td align="center">依赖 diff 算法，JS 调度</td></tr><tr><td align="center">Flutter</td><td align="center">自绘引擎（Skia）</td><td align="center">Widget Tree rebuild</td><td align="center">Skia Engine</td><td align="center">完全跨平台一致，性能接近原生</td></tr><tr><td align="center">SwiftUI</td><td align="center">声明式 + 原生 UIKit&#x2F;Metal</td><td align="center">State &amp; Binding</td><td align="center">Apple UI 栈</td><td align="center">原生融合性最优</td></tr></tbody></table><p>3、总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compose Multiplatform = “原生 UI 声明式统一 DSL”。</span><br><span class="line">React = “虚拟 DOM diff 渲染”。</span><br><span class="line">Flutter = “完全自绘引擎，跨平台一致”。</span><br><span class="line">SwiftUI = “原生系统声明式框架”。</span><br></pre></td></tr></table></figure><p>4、面试答法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compose MPP 不重写渲染引擎，而是通过</span><br><span class="line">Compose Runtime 统一 DSL + 各平台 backend(AndroidView/Skia/DOM) 实现跨端一致语义。</span><br></pre></td></tr></table></figure><h3 id="2-3-如何在-KMP-中实现跨端消息总线-SharedFlow-MutableSharedFlow"><a href="#2-3-如何在-KMP-中实现跨端消息总线-SharedFlow-MutableSharedFlow" class="headerlink" title="2.3 如何在 KMP 中实现跨端消息总线(SharedFlow + MutableSharedFlow)"></a>2.3 如何在 KMP 中实现跨端消息总线(SharedFlow + MutableSharedFlow)</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多端事件总线设计、线程安全、生命周期管理、UI 层订阅</span><br></pre></td></tr></table></figure><p>2、设计思路</p><p>2-1、使用 Kotlin 协程的 <code>SharedFlow</code> 实现事件总线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object EventBus &#123;</span><br><span class="line">    private val _events = MutableSharedFlow&lt;Any&gt;(extraBufferCapacity = 64)</span><br><span class="line">    val events = _events.asSharedFlow()</span><br><span class="line"></span><br><span class="line">    suspend fun post(event: Any) = _events.emit(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2-2、发布事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.post(UserUpdatedEvent(user))</span><br></pre></td></tr></table></figure><p>2-3、订阅事件（Android Compose）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LaunchedEffect(Unit) &#123;</span><br><span class="line">    EventBus.events.collect &#123; event -&gt;</span><br><span class="line">        when (event) &#123;</span><br><span class="line">            is UserUpdatedEvent -&gt; updateUI(event.user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2-4、订阅事件（iOS Swift）(Kotlin Flow → Swift <code>AsyncStream</code>：)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let flow = EventBus.shared.events</span><br><span class="line">Task &#123;</span><br><span class="line">    for await event in flow &#123;</span><br><span class="line">        print(&quot;Event from Kotlin: \(event)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2-5、多端同步策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared 层负责定义事件模型与 bus；</span><br><span class="line">各端通过 flow/stream 监听；</span><br><span class="line">线程安全由 SharedFlow 自身保证（多发多收）。</span><br></pre></td></tr></table></figure><p>3、面试加分答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharedFlow 在 Kotlin/Native 新 GC 下线程安全且无冻结限制，</span><br><span class="line">适合实现轻量级跨端事件总线，可替代 RxBus/EventBus。</span><br></pre></td></tr></table></figure><h3 id="2-4-如何解决-iOS-Swift-与-Kotlin-集成中的包大小与符号冲突问题"><a href="#2-4-如何解决-iOS-Swift-与-Kotlin-集成中的包大小与符号冲突问题" class="headerlink" title="2.4  如何解决 iOS Swift 与 Kotlin 集成中的包大小与符号冲突问题"></a>2.4  如何解决 iOS Swift 与 Kotlin 集成中的包大小与符号冲突问题</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native 编译产物体积优化、符号混淆、Framework 重复符号</span><br></pre></td></tr></table></figure><p>2、 常见问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native framework 较大（&gt;15MB）</span><br><span class="line">Swift 与 Kotlin 混编时符号重复（如重复依赖第三方 C 库）</span><br><span class="line">Debug 版本带符号信息过多</span><br></pre></td></tr></table></figure><p>3、优化方案</p><p>3-1、减小包体积</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、开启 Release 构建（关闭调试符号）</span><br><span class="line">./gradlew :shared:assembleReleaseXCFramework</span><br><span class="line"></span><br><span class="line">2、在 binaries.framework 中开启优化</span><br><span class="line">binaries.framework &#123;</span><br><span class="line">    freeCompilerArgs += listOf(&quot;-Xallocator=mimalloc&quot;, &quot;-opt&quot;)</span><br><span class="line">    isStatic = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、移除不必要的调试符号</span><br><span class="line">strip -x Shared.framework/Shared</span><br><span class="line"></span><br><span class="line">4、多模块按需导出：避免整个 shared 暴露所有符号，使用 export 控制：</span><br><span class="line">export(project(&quot;:core&quot;))</span><br></pre></td></tr></table></figure><p>3-2、解决符号冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、确保只在一个层级链接相同的依赖库（例如 cinterop OpenSSL 重复时仅保留一份）。</span><br><span class="line">2、使用不同 module namespace：baseName = &quot;SharedCore&quot;</span><br><span class="line">3、若存在 Swift module 重名冲突，修改 Kotlin framework 名称（baseName）。</span><br></pre></td></tr></table></figure><p>3-3、动态 vs 静态 Framework</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态 .framework → 链接期合并，减少符号冲突；</span><br><span class="line">动态 .framework → 可独立更新，但符号隔离差。</span><br></pre></td></tr></table></figure><h3 id="2-5-如何在-iOS-中处理-KMP-Framework-的-ABI-兼容性问题？"><a href="#2-5-如何在-iOS-中处理-KMP-Framework-的-ABI-兼容性问题？" class="headerlink" title="2.5 如何在 iOS 中处理 KMP Framework 的 ABI 兼容性问题？"></a>2.5 如何在 iOS 中处理 KMP Framework 的 ABI 兼容性问题？</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native ABI 稳定性、framework 更新策略、Xcode linking</span><br></pre></td></tr></table></figure><p>2、背景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native 在 1.9 前 ABI 频繁变化，导致升级后旧 framework 无法二进制兼容。</span><br></pre></td></tr></table></figure><p>3、 解决思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、使用 XCFramework</span><br><span class="line">-XCFramework 内部支持多架构（arm64、x86_64），保证稳定性。</span><br><span class="line">-对外发布时始终提供完整 XCFramework 包。</span><br><span class="line"></span><br><span class="line">2、固定 Kotlin 版本</span><br><span class="line">-保持 Kotlin 与 Kotlin/Native 版本一致（宿主和依赖端）。</span><br><span class="line">-ABI 不同版本 framework 不可混用。</span><br><span class="line"></span><br><span class="line">3、封装稳定 API 层</span><br><span class="line">-对外只暴露稳定接口（DTO + 协议层），内部逻辑可改。</span><br><span class="line">-使用 thin adapter 隔离 ABI。</span><br><span class="line"></span><br><span class="line">4、使用静态链接（isStatic = true）</span><br><span class="line">避免动态符号重定位问题，提高兼容性。</span><br><span class="line"></span><br><span class="line">5、自动化版本检查</span><br><span class="line">在 CI/CD 中检查：</span><br><span class="line">Shared.framework/Shared | grep &quot;kotlin_version&quot;</span><br><span class="line">确保 framework 与宿主编译链匹配。</span><br></pre></td></tr></table></figure><p>4、一句话总结面试答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native Framework 目前仍非完全 ABI 稳定，</span><br><span class="line">应通过 XCFramework 打包 + Kotlin 版本固定 + 静态链接策略保证兼容性，业务层使用稳定 API 封装</span><br></pre></td></tr></table></figure><h2 id="三-延伸追问"><a href="#三-延伸追问" class="headerlink" title="三  延伸追问"></a>三  延伸追问</h2><table><thead><tr><th align="center">方向</th><th align="center">示例问题</th></tr></thead><tbody><tr><td align="center">多端 UI</td><td align="center">Compose MPP 能否完全替代 SwiftUI？为什么？</td></tr><tr><td align="center">编译优化</td><td align="center">如何缩小 XCFramework 体积？</td></tr><tr><td align="center">性能</td><td align="center">SharedFlow 与 LiveData 区别？</td></tr><tr><td align="center">原生互通</td><td align="center">Kotlin&#x2F;Native 的 CInterop 如何工作？</td></tr><tr><td align="center">部署</td><td align="center">你们是如何 CI&#x2F;CD 发布多端 framework 的？</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.如何支持 Web(Kotlin/JS)或 Desktop(Compose Desktop)？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.Kotlin Multiplatform Compose 与 React/Flutter 在渲染机制上的差异？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.如何在 KMP 中实现跨端消息总线(SharedFlow + MutableSharedFlow)？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.如何解决 iOS Swift 与 Kotlin 集成中的包大小与符号冲突问题？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.如何在 iOS 中处理 KMP Framework 的 ABI 兼容性问题？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/tags/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>KMP面试题之——专家级之工程化与生态集成(11)</title>
    <link href="https://pgzxc.github.io/posts/de98d4bc.html"/>
    <id>https://pgzxc.github.io/posts/de98d4bc.html</id>
    <published>2025-10-19T00:45:29.000Z</published>
    <updated>2025-11-01T01:39:34.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.你如何实现 KMP 与 Compose Multiplatform、SwiftUI、Jetpack Compose 三端统一架构？</span><br><span class="line">2.如何用 KMP 实现多端插件系统？</span><br><span class="line">3.如何封装跨平台音视频模块(基于 FFmpeg/C++)？</span><br><span class="line">4.如何在 shared 层调用 C/C++ 库（CInterop + CMake）？</span><br><span class="line">5.解释 cinterop(C interoperation/C 语言互操作) 与 gradle-native 的关系。</span><br><span class="line">6.如何在 KMP 中集成 TensorFlow Lite、OpenCV 等原生库？</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-三端统一架构"><a href="#2-1-三端统一架构" class="headerlink" title="2.1 三端统一架构"></a>2.1 三端统一架构</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">架构分层、责任边界、状态管理、测试与复用策略、性能权衡</span><br></pre></td></tr></table></figure><p>2、核心思路(高层)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、Shared(KMP)层只负责业务逻辑与状态：</span><br><span class="line">UseCases、Repositories、Domain Models、跨平台 ViewModel（StateFlow/SharedFlow/Observable）。</span><br><span class="line"></span><br><span class="line">2、Platform 层负责 UI 与原生交互：</span><br><span class="line">Android → Jetpack Compose；</span><br><span class="line">Desktop/Multi → Compose Multiplatform；</span><br><span class="line">iOS → SwiftUI/UIViewController。</span><br><span class="line"></span><br><span class="line">3、桥接层(adapter)：</span><br><span class="line">每个平台写 thin adapter(薄包装器)把 Shared 的状态转换为本平台的 UI 形态</span><br><span class="line">（例如 StateFlow -&gt; LiveData/Compose State/ObservableObject）。</span><br><span class="line"></span><br><span class="line">4、通信契约：</span><br><span class="line">使用 DTO + 明确的不可变 State(data class)作为界面层输入输出，避免共享可变模型直接用于 UI。</span><br></pre></td></tr></table></figure><p>3、关键组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、shared：</span><br><span class="line">ViewModel(exposed as StateFlow)、UseCase、Repository(expect/actual 分离平台实现的 I/O)。</span><br><span class="line"></span><br><span class="line">2、android：</span><br><span class="line">ViewModel wrapper（将 StateFlow 转为 Compose collectAsState()），UI 使用 Compose。</span><br><span class="line"></span><br><span class="line">3、ios：</span><br><span class="line">生成的 Kotlin framework，</span><br><span class="line">写一个 Swift 的 ObservableObject wrapper，订阅 StateFlow 并发布到 SwiftUI。</span><br></pre></td></tr></table></figure><p>4、示例(伪代码)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、Kotlin shared：</span><br><span class="line">class MainViewModel &#123;</span><br><span class="line">  private val _uiState = MutableStateFlow(MainState())</span><br><span class="line">  val uiState: StateFlow&lt;MainState&gt; = _uiState.asStateFlow()</span><br><span class="line">  suspend fun load() &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、Android adapter：</span><br><span class="line">@Composable</span><br><span class="line">fun MainScreen(vm: MainViewModel) &#123;</span><br><span class="line">  val state by vm.uiState.collectAsState()</span><br><span class="line">  // Compose UI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、iOS adapter（Swift）</span><br><span class="line">class MainViewModelWrapper: ObservableObject &#123;</span><br><span class="line">  @Published var state: MainStateKotlin</span><br><span class="line">  init(vm: SharedMainViewModel) &#123;</span><br><span class="line">    // subscribe to Kotlin StateFlow and map to @Published</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、要点&#x2F;注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">统一状态模型(immutable)有助于在三端保持一致性。</span><br><span class="line">网络/存储/平台 API 用 expect/actual 分层实现。</span><br><span class="line">UI-specific optimizations（例如 Compose 的 recomposition）放在平台端处理。</span><br><span class="line">写良好的测接口（unit tests in shared）可以提升复用率。</span><br></pre></td></tr></table></figure><h3 id="2-2-多端插件"><a href="#2-2-多端插件" class="headerlink" title="2.2 多端插件"></a>2.2 多端插件</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插件抽象、模块化、动态/静态装载、平台限制（iOS 不允许运行时加载未经签名的代码）、依赖注入/扩展点实现。</span><br></pre></td></tr></table></figure><p>2、设计思路(两种模式)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、编译时插件（推荐）：</span><br><span class="line">插件以单独 KMP module 实现并在构建时注入到主 app（通过 Gradle include/CocoaPods/XCFramework）。</span><br><span class="line">优点：安全、上线可控。</span><br><span class="line"></span><br><span class="line">2、运行时插件（有限制）：</span><br><span class="line">Android 可用 ClassLoader + Dex 动态加载；</span><br><span class="line">iOS 限制严格（只能通过预编译的动态 framework/SPM 集成），通常采用运行时“模块开关”而不是真实动态代码下载。</span><br></pre></td></tr></table></figure><p>3、实现模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、定义插件接口(shared)：</span><br><span class="line">interface Plugin &#123;</span><br><span class="line">  val id: String</span><br><span class="line">  fun initialize(context: PlatformContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、插件实现：</span><br><span class="line">每个 plugin module 实现 Plugin 并在其 platform 目录实现必要的 expect/actual。</span><br><span class="line"></span><br><span class="line">3、注册机制</span><br><span class="line">Android：使用 ServiceLoader（JVM）或手动在 Application 中注入列表。</span><br><span class="line">iOS：通过一个 PluginRegistry 在 app 启动时把需要的 plugin 实例注入（手动或通过生成代码）。</span><br><span class="line"></span><br><span class="line">4、扩展点与生命周期：</span><br><span class="line">定义 plugin 的生命周期接口(onStart/onStop)，并由宿主统一管理。</span><br></pre></td></tr></table></figure><p>4、注意事项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安全：iOS 不支持任意运行时代码加载（App Store 限制）；动态插件需提前签名与打包。</span><br><span class="line">版本兼容：指定插件契约版本，做好向后/向前兼容。</span><br><span class="line">依赖冲突：插件尽量少依赖 heavy third-party libs 或用 shading/relocation 手段隔离</span><br></pre></td></tr></table></figure><h3 id="2-3-如何封装跨平台音视频模块"><a href="#2-3-如何封装跨平台音视频模块" class="headerlink" title="2.3 如何封装跨平台音视频模块"></a>2.3 如何封装跨平台音视频模块</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原生C++与KMP的互操作、性能(解码/编码)、线程/渲染路径、API 设计、平台渲染(Surface/Metal/AVPlayer)。</span><br></pre></td></tr></table></figure><p>2、架构建议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、C++ 层（核心）：</span><br><span class="line">封装 FFmpeg 解码/编码逻辑、packet/frame 管理、低延迟 buffer。</span><br><span class="line">使用 C++ 提供一致 API（例如 MediaEngine）。</span><br><span class="line">编译成 .so（Android）、.framework/.a 或 XCFramework（iOS）。</span><br><span class="line"></span><br><span class="line">2、Native bridge 层：</span><br><span class="line">为每个平台写 thin wrapper(薄包装器)：</span><br><span class="line">-Android：JNI 层（C++) -&gt; Kotlin。</span><br><span class="line">-iOS：直接用 Kotlin/Native cinterop 调用 C++（通过 extern &quot;C&quot; 的 C API 封装，或使用 Objective-C++ 辅助）。</span><br><span class="line"></span><br><span class="line">3、Kotlin Shared API：</span><br><span class="line">在 shared 层提供高层 Kotlin API（协程 + Flow），隐藏底层同步/回调。</span><br><span class="line"></span><br><span class="line">4、渲染：</span><br><span class="line">平台端负责渲染：Android 用 SurfaceTexture / SurfaceView / Compose AndroidView；</span><br><span class="line">iOS 用 AVSampleBufferDisplayLayer 或 Metal 纹理。</span><br></pre></td></tr></table></figure><p>3、数据流示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FFmpeg 解出的 frame -&gt; native buffer -&gt; Kotlin 层通过 ByteArray/CInterop 传回 -&gt; 平台渲染</span><br></pre></td></tr></table></figure><p>4、性能注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-避免在 Kotlin 层复制大量帧数据；优先使用零拷贝（native buffer 指针）并在平台端直接渲染。</span><br><span class="line">-在 JNI/Native 层做好线程调度与内存管理（回收 AVFrame）。</span><br><span class="line">-使用硬件加速（MediaCodec、VideoToolbox、Metal）做解码/渲染时，FFmpeg 主要用于封装/回退。</span><br></pre></td></tr></table></figure><h3 id="2-4-如何在-shared-层调用-C-C-库"><a href="#2-4-如何在-shared-层调用-C-C-库" class="headerlink" title="2.4 如何在 shared 层调用 C&#x2F;C++ 库"></a>2.4 如何在 shared 层调用 C&#x2F;C++ 库</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native cinterop、CMake 构建 pipeline、跨目标编译、头文件绑定、ABI 兼容。</span><br></pre></td></tr></table></figure><p>2、实现步骤（概要）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1、准备 native 库</span><br><span class="line">用 CMake 构建 C/C++ 库，输出为 .so(Android)、.a/.framework 或 XCFramework(iOS)。在 CI 中为所有目标构建二进制。</span><br><span class="line"></span><br><span class="line">2、为 Kotlin/Native 写 cinterop binding</span><br><span class="line">2-1、创建 .def 文件（描述 headers 与 linker flags）：</span><br><span class="line">headers = mylib.h</span><br><span class="line">linkerOpts = -L/path/to/lib -lmylib</span><br><span class="line"></span><br><span class="line">2-2、在 gradle 中声明 cinterop：</span><br><span class="line"></span><br><span class="line">kotlin &#123;</span><br><span class="line">  iosX64 &#123;</span><br><span class="line">    compilations.getByName(&quot;main&quot;) &#123;</span><br><span class="line">      cinterops.create(&quot;mylib&quot;) &#123;</span><br><span class="line">        defFile = file(&quot;src/nativeInterop/cinterop/mylib.def&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、使用 C APIs（prefer extern &quot;C&quot; 接口）</span><br><span class="line">若库是 C++，推荐提供外部 extern &quot;C&quot; C wrapper 层以兼容 cinterop。</span><br><span class="line">或使用 Objective-C++ on iOS side.</span><br><span class="line"></span><br><span class="line">4、CMake + Gradle 集成</span><br><span class="line">CMake 负责生成 native artifacts。Gradle（Kotlin plugin）负责将预构建二进制作为依赖并在 cinterop 中引用。</span><br><span class="line">也可在 Gradle task 中触发 CMake 构建，输出到 build/ 目录供 cinterop 使用。</span><br></pre></td></tr></table></figure><p>3、注意事项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ABI 与架构：为每个平台/ABI 编译 native 库（arm64, armeabi-v7a, x86_64 等）。</span><br><span class="line">头文件兼容性：cinterop 会生成 Kotlin 调用的签名，避免复杂模板/宏。</span><br><span class="line">C++ name mangling：最好暴露 C ABI wrapper。</span><br><span class="line">内存管理：cinterop 返回的指针在 Kotlin 层需要小心释放（定义释放 API）</span><br></pre></td></tr></table></figure><h3 id="2-5-解释-cinterop-与-gradle-native-的关系"><a href="#2-5-解释-cinterop-与-gradle-native-的关系" class="headerlink" title="2.5 解释 cinterop 与 gradle-native 的关系"></a>2.5 解释 cinterop 与 gradle-native 的关系</h3><p>1、核心解释（面试简答版）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、cinterop（Kotlin/Native 的 cinterop）</span><br><span class="line">-是 Kotlin/Native 提供的工具链组件，用来 根据 C 头文件生成 Kotlin 绑定（Kotlin 调用 C API）。</span><br><span class="line">输出是 Kotlin 可调用的类/方法（bridge）。</span><br><span class="line">需要 .def 配置描述 headers、linker flags、预处理器宏等。</span><br><span class="line"></span><br><span class="line">-作用域：把 native C ABI 映射为 Kotlin 类型/函数，方便在 shared 模块中直接调用 native 库。</span><br><span class="line"></span><br><span class="line">2、gradle-native / build system（Gradle + CMake/ndk）</span><br><span class="line">-指的是通过 Gradle 配置编译和打包 native 代码（C/C++），</span><br><span class="line">通常使用 CMake 或 ndk-build 在 Android（或外部 CI）构建.so/.a/XCFramework。</span><br><span class="line"></span><br><span class="line">-Gradle 负责 orchestration（触发 native 构建、把产物放到正确位置、与 Kotlin/Native 的 cinterop 链接）。</span><br></pre></td></tr></table></figure><p>2、关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、cinterop 依赖 由 gradle-native（或 CMake 构建）产生的 native artifacts（头 + lib）。</span><br><span class="line">通常流程是：</span><br><span class="line">先 CMake 构建 native 二进制 -&gt; </span><br><span class="line">然后 cinterop 读取 headers &amp; link 到库 -&gt; Kotlin/Native 将库链接到最终 framework/binary。</span><br><span class="line"></span><br><span class="line">2、cinterop 不做 native 编译，只做“绑定生成”；Gradle/CMake 做编译与产物管理。</span><br></pre></td></tr></table></figure><h3 id="2-6-如何在-KMP-中集成-TensorFlow-Lite、OpenCV-等原生库？"><a href="#2-6-如何在-KMP-中集成-TensorFlow-Lite、OpenCV-等原生库？" class="headerlink" title="2.6 如何在 KMP 中集成 TensorFlow Lite、OpenCV 等原生库？"></a>2.6 如何在 KMP 中集成 TensorFlow Lite、OpenCV 等原生库？</h3><p>1、考点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多平台二进制管理、性能（硬件 delegate）、模型/资源部署、ABI 分发</span><br></pre></td></tr></table></figure><p>2、通用策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1、为每个平台准备 native 二进制</span><br><span class="line">-Android：编译 .so（多个 ABI）；放入 src/main/jniLibs/&lt;abi&gt;/libtflite.so 或用 Gradle externalNativeBuild。</span><br><span class="line">-iOS：打包成 XCFramework（包含 arm64、x86_64 等）。</span><br><span class="line">-Desktop：提供 native shared libs。</span><br><span class="line"></span><br><span class="line">2、定义 C ABI 或使用官方C API：</span><br><span class="line">多数库（TFLite、OpenCV）提供CAPI/flatbuffers C interface，可以直接通过 cinterop 绑定。</span><br><span class="line">若只有 C++ 接口，建议写 C wrapper。</span><br><span class="line"></span><br><span class="line">3、Kotlin 层抽象：</span><br><span class="line">在 shared 用 expect/actual 或 cinterop 直接封装 low-level 调用，</span><br><span class="line">并在 shared 中提供高层 Kotlin API（ModelRunner、ImageProcessor）。</span><br><span class="line"></span><br><span class="line">interface TFLiteRunner &#123;</span><br><span class="line">  fun run(input: ByteArray): FloatArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4、资源/模型分发：</span><br><span class="line">模型（.tflite）作为 assets（Android）/bundle resource（iOS），加载路径需平台实现（expect/actual）。</span><br><span class="line">注意模型大文件的分发策略（on-demand download / CDN）。</span><br><span class="line"></span><br><span class="line">5、性能优化：</span><br><span class="line">利用平台 delegate（Android NNAPI/GPU、iOS Metal delegate）并暴露给 Kotlin 层配置选项。</span><br><span class="line">注意线程亲和性、内存池与 buffer reuse，避免频繁分配。</span><br></pre></td></tr></table></figure><p>3、具体注意点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、许可与体积：这些库会显著增加二进制大小，面试时要能讨论拆分策略（on-demand、modularized）与 license（Apache/BSD）。</span><br><span class="line">2、线程模型：TFLite 在多线程与 delegate 下的行为差异，需要测并行吞吐和延迟。</span><br><span class="line">3、测试：CI 中添加集成测试（小模型/回归）验证所有 target 的二进制可用性。</span><br><span class="line">4、部署：对 iOS 使用 XCFramework + bitcode/strip 策略，对 Android 提供 per-ABI APK 或 split apk。</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、统一架构：shared 管状态+业务，platform 层做 UI + adapter（StateFlow -&gt; Compose/SwiftUI）。</span><br><span class="line">2、插件系统：优先编译时插件，iOS 限制运行时加载；用接口 + registry 模式。</span><br><span class="line">3、跨平台音视频：核心用 C++（FFmpeg），native wrapper + Kotlin 高层 API，平台端做渲染。</span><br><span class="line">4、调用 C/C++：用 CMake 构建 native 库，cinterop 生成 Kotlin 绑定（最好暴露 C ABI）。</span><br><span class="line">5、cinterop vs gradle-native：cinterop 生成绑定；Gradle/CMake 负责编译 native artifacts。</span><br><span class="line">6、集成 TFLite/OpenCV：为每个平台提供 native 二进制 + cinterop 绑定 + shared 层高层封装 + delegate/性能调优。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.你如何实现 KMP 与 Compose Multiplatform、SwiftUI、Jetpack Compose 三端统一架构？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.如何用 KMP 实现多端插件系统？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.如何封装跨平台音视频模块(基于 FFmpeg/C++)？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.如何在 shared 层调用 C/C++ 库（CInterop + CMake）？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.解释 cinterop(C interoperation/C 语言互操作) 与 gradle-native 的关系。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.如何在 KMP 中集成 TensorFlow Lite、OpenCV 等原生库？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/tags/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>KMP面试题之——高级之混合开发与通信(10)</title>
    <link href="https://pgzxc.github.io/posts/9cc03366.html"/>
    <id>https://pgzxc.github.io/posts/9cc03366.html</id>
    <published>2025-10-18T01:18:45.000Z</published>
    <updated>2025-11-01T01:39:34.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Android 如何调用 shared 模块？</span><br><span class="line">2.iOS 如何调用 shared 模块？(Swift 调用 Kotlin Framework)</span><br><span class="line">3.如何桥接 Swift &lt;-&gt; Kotlin 的数据类型？</span><br><span class="line">4.如何共享 business logic 而保留原生 UI？</span><br><span class="line">5.如何调试 shared 模块的 native 崩溃问题？</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-Android-如何调用-shared-模块"><a href="#2-1-Android-如何调用-shared-模块" class="headerlink" title="2.1 Android 如何调用 shared 模块"></a>2.1 Android 如何调用 shared 模块</h3><p>1、面试要点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KMP 工程结构、Gradle 配置、依赖方式、Android 集成路径</span><br></pre></td></tr></table></figure><p>2、解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、说明</span><br><span class="line">在 Android 中，shared 模块被视为普通的 Gradle Module</span><br><span class="line">（类型：kotlin(&quot;multiplatform&quot;) + androidTarget()）</span><br><span class="line"></span><br><span class="line">2、调用步骤</span><br><span class="line">2-1、settings.gradle.kts</span><br><span class="line">// settings.gradle.kts</span><br><span class="line">include(&quot;:androidApp&quot;, &quot;:shared&quot;)</span><br><span class="line"></span><br><span class="line">// androidApp/build.gradle.kts</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(project(&quot;:shared&quot;))</span><br><span class="line">&#125;</span><br><span class="line">2-2、在 Android 代码中直接引用</span><br><span class="line">import com.example.shared.*</span><br><span class="line"></span><br><span class="line">// 调用 shared 模块逻辑</span><br><span class="line">val result = Greeting().greet()</span><br></pre></td></tr></table></figure><p>3、重点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android 会编译 shared 模块为 .aar，直接集成到 app module 中；</span><br><span class="line">可以复用 Kotlin 源码、协程、Ktor、SQLDelight 等业务逻辑。</span><br></pre></td></tr></table></figure><h3 id="2-2-iOS-如何调用-shared-模块？"><a href="#2-2-iOS-如何调用-shared-模块？" class="headerlink" title="2.2 iOS 如何调用 shared 模块？"></a>2.2 iOS 如何调用 shared 模块？</h3><p>1、面试要点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KMP 生成 Framework 的原理、CInterop 桥接机制、Xcode 配置。</span><br></pre></td></tr></table></figure><p>2、解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、KMP 构建时会通过 Gradle 的 iosTarget() 生成 .framework：</span><br><span class="line">kotlin &#123;</span><br><span class="line">    ios &#123;</span><br><span class="line">        binaries.framework &#123;</span><br><span class="line">            baseName = &quot;SharedSDK&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">生成后，在 shared/build/XCFrameworks 中得到 SharedSDK.xcframework，</span><br><span class="line"></span><br><span class="line">2、在 Xcode 中添加：</span><br><span class="line">Xcode → General → Frameworks, Libraries, and Embedded Content → Add files…</span><br><span class="line"></span><br><span class="line">3、Swift 调用示例：</span><br><span class="line">import SharedSDK</span><br><span class="line"></span><br><span class="line">let greeting = Greeting()</span><br><span class="line">print(greeting.greet())</span><br></pre></td></tr></table></figure><p>3、重点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iOS 使用 Kotlin/Native 编译的 LLVM Bitcode Framework；</span><br><span class="line">可自动桥接到 Swift/C 运行时，内部包含 Kotlin Runtime。</span><br></pre></td></tr></table></figure><h3 id="2-3-如何桥接-Swift-Kotlin-的数据类型？"><a href="#2-3-如何桥接-Swift-Kotlin-的数据类型？" class="headerlink" title="2.3 如何桥接 Swift &lt;-&gt; Kotlin 的数据类型？"></a>2.3 如何桥接 Swift &lt;-&gt; Kotlin 的数据类型？</h3><p>1、面试要点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型映射规则、Nullability、集合与异步（Flow/Coroutine）桥接。</span><br></pre></td></tr></table></figure><p>2、解答</p><p>2-1、Kotlin&#x2F;Native 会自动映射常见类型</p><table><thead><tr><th align="center">Kotlin 类型</th><th align="center">Swift 映射类型</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">String</td></tr><tr><td align="center">Int, Long</td><td align="center">Int32, Int64</td></tr><tr><td align="center">Boolean</td><td align="center">Bool</td></tr><tr><td align="center">List&lt;T&gt;</td><td align="center">KotlinArray&lt;T&gt; &#x2F; NSArray</td></tr><tr><td align="center">Map&lt;K,V&gt;</td><td align="center">NSDictionary</td></tr><tr><td align="center">Nullable 类型</td><td align="center">Optional</td></tr></tbody></table><p>2-2、异步桥接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">suspend 函数 → Swift 异步闭包 (completionHandler)</span><br><span class="line">Flow&lt;T&gt; 可通过 combineFlow() 或 callbackFlow 适配成 Swift AsyncStream</span><br></pre></td></tr></table></figure><p>2-3、示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// shared</span><br><span class="line">suspend fun fetchUser(): User</span><br><span class="line"></span><br><span class="line">// Swift 调用</span><br><span class="line">shared.fetchUser &#123; user, error in</span><br><span class="line">    if let u = user &#123;</span><br><span class="line">        print(u.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、技巧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为提升可读性，可以在 Kotlin 层定义 “DTO + Mapper” 进行结构体转换，或在 Swift 层写扩展进行轻量封装。</span><br></pre></td></tr></table></figure><h3 id="2-4-如何共享-business-logic-而保留原生-UI？"><a href="#2-4-如何共享-business-logic-而保留原生-UI？" class="headerlink" title="2.4 如何共享 business logic 而保留原生 UI？"></a>2.4 如何共享 business logic 而保留原生 UI？</h3><p>1、面试要点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KMP 的架构定位、UI 分层策略（MVVM/MVI）、平台层职责。</span><br></pre></td></tr></table></figure><p>2、解答：</p><p>2-1、KMP 推荐架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared ──&gt; ViewModel + UseCase + Repository + Data</span><br><span class="line">androidApp ──&gt; Compose / View XML</span><br><span class="line">iosApp ──&gt; SwiftUI / UIKit</span><br></pre></td></tr></table></figure><p>2-2、典型实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared 层：定义 ViewModel、状态流（StateFlow）、业务逻辑。</span><br><span class="line">Android 端：collectAsState() 订阅状态。</span><br><span class="line">iOS 端：通过 Flow.asCommonFlow() 订阅并转为 SwiftUI ObservableObject。</span><br></pre></td></tr></table></figure><p>2-3、示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、示例</span><br><span class="line">class MainViewModel &#123;</span><br><span class="line">    private val _state = MutableStateFlow(&quot;Loading…&quot;)</span><br><span class="line">    val state: StateFlow&lt;String&gt; = _state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、Swift 端绑定：</span><br><span class="line">@ObservedObject var vm = MainViewModelWrapper()</span><br><span class="line"></span><br><span class="line">Text(vm.state)</span><br></pre></td></tr></table></figure><p>3、重点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享的是 “业务逻辑（ViewModel、UseCase）”，</span><br><span class="line">而 UI 层完全原生（Compose + SwiftUI），保证体验一致性与可维护性。</span><br></pre></td></tr></table></figure><h3 id="2-5-如何调试-shared-模块的-native-崩溃问题？"><a href="#2-5-如何调试-shared-模块的-native-崩溃问题？" class="headerlink" title="2.5 如何调试 shared 模块的 native 崩溃问题？"></a>2.5 如何调试 shared 模块的 native 崩溃问题？</h3><p>1、面试要点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native 调试难点、符号还原、调试工具链。</span><br></pre></td></tr></table></figure><p>2、解答</p><p>2-1、常见原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NullPointer（因 Swift Optional &lt;-&gt; Kotlin nullable 不匹配）</span><br><span class="line">并发问题（Kotlin/Native 对象冻结）</span><br><span class="line">内存泄漏（未释放 CPointer）</span><br><span class="line">Native 库交互错误（CInterop）</span><br></pre></td></tr></table></figure><p>2-2、调试手段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1、开启 Debug Symbol</span><br><span class="line">ios &#123;</span><br><span class="line">    binaries.framework &#123;</span><br><span class="line">        isStatic = false</span><br><span class="line">        freeCompilerArgs += listOf(&quot;-g&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、使用 Xcode 调试</span><br><span class="line">将 shared 的 .framework 以 debug 模式编译。</span><br><span class="line">在 Xcode 运行时可看到 Kotlin 栈追踪（带符号名）。</span><br><span class="line"></span><br><span class="line">3、查看 Kotlin/Native 崩溃日志</span><br><span class="line">运行时打印：Uncaught Kotlin exception: kotlin.NullPointerException</span><br><span class="line">可以在 Gradle 中启用：export KONAN_DEBUG=1</span><br><span class="line"></span><br><span class="line">4、符号化工具</span><br><span class="line">使用 atos 或 llvm-symbolizer 将 .dSYM 映射回 Kotlin 源码。</span><br></pre></td></tr></table></figure><p>3、最佳实践</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 Kotlin 层 catch 并包装异常（避免直接传到 Swift）。</span><br><span class="line">使用 Kermit 或 Napier 记录跨平台日志。</span><br><span class="line">测试阶段尽量启用 Debug 构建 + 内存泄漏检测</span><br></pre></td></tr></table></figure><h2 id="三-延伸提问"><a href="#三-延伸提问" class="headerlink" title="三 延伸提问"></a>三 延伸提问</h2><table><thead><tr><th align="center">方向</th><th align="center">示例问题</th></tr></thead><tbody><tr><td align="center">工程架构</td><td align="center">你们的 shared 模块怎么组织？是否使用 expect&#x2F;actual？</td></tr><tr><td align="center">性能优化</td><td align="center">iOS Framework 的体积如何优化？</td></tr><tr><td align="center">类型桥接</td><td align="center">Swift Optional 与 Kotlin nullable 的坑有哪些？</td></tr><tr><td align="center">崩溃分析</td><td align="center">如何定位 Native 崩溃堆栈？</td></tr><tr><td align="center">调试实践</td><td align="center">shared 层如何进行单元测试？是否使用 KMMTest？</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.Android 如何调用 shared 模块？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.iOS 如何调用 shared 模块？(Swift 调用 Kotlin Framework)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.如何桥接 Swift &amp;lt;-&amp;gt; Kotlin 的数据类型？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.如何共享 business logic 而保留原生 UI？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.如何调试 shared 模块的 native 崩溃问题？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/tags/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>KMP面试题之——高级之内存与性能(9)</title>
    <link href="https://pgzxc.github.io/posts/b1348e11.html"/>
    <id>https://pgzxc.github.io/posts/b1348e11.html</id>
    <published>2025-10-18T00:32:05.000Z</published>
    <updated>2025-11-01T01:39:34.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Kotlin/Native 的内存管理机制？</span><br><span class="line">2.为什么 Kotlin/Native 从 Freezing 模型迁移到新 GC？</span><br><span class="line">3.如何在多线程中避免数据冻结问题？</span><br><span class="line">4.KMP 项目常见性能瓶颈及优化思路？</span><br><span class="line">5.KMP 在 iOS 端调试困难的原因与解决方案？</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-内存管理机制"><a href="#2-1-内存管理机制" class="headerlink" title="2.1 内存管理机制"></a>2.1 内存管理机制</h3><p>1、核心概念</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Kotlin/Native 早期使用 Reference Counting + Freezing 模型，</span><br><span class="line">自 Kotlin 1.7+ 起引入 新一代并发 GC(Garbage Collector)，</span><br><span class="line">Kotlin 2.0 起成为默认机制。</span><br></pre></td></tr></table></figure><p>2、机制对比</p><table><thead><tr><th align="center">阶段</th><th align="center">模型</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">旧模型(Freezing)</td><td align="center">引用计数 + 对象冻结</td><td align="center">不可变对象可跨线程；可变对象需 <code>freeze()</code> 否则抛异常</td></tr><tr><td align="center">新模型(GC)</td><td align="center">并发标记清除 GC</td><td align="center">支持多线程安全共享可变对象，无需冻结</td></tr></tbody></table><p>3、关键点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个线程原本有独立 Heap，旧模型靠冻结共享。</span><br><span class="line">新 GC 使用并发标记清除算法(Concurrent Mark &amp; Sweep)，低延迟、自动内存管理。</span><br><span class="line">体验更接近 JVM 与 Swift。</span><br></pre></td></tr></table></figure><p>4、面试问法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、面试问法「请解释 Kotlin/Native 的内存管理机制，与 JVM 有何不同？」</span><br><span class="line">2、答题要点：</span><br><span class="line">-Native 不依赖 JVM，需自行管理内存。</span><br><span class="line">-旧模型使用 Freezing 保证线程安全，新 GC 则自动管理。</span><br><span class="line">-新 GC 兼顾性能与可用性，是 Kotlin/Native 的关键演进。</span><br></pre></td></tr></table></figure><p>5、示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val sharedList = mutableListOf&lt;Int&gt;()</span><br><span class="line">coroutineScope &#123;</span><br><span class="line">    launch &#123; sharedList.add(1) &#125; // 新模型下可直接共享</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Freezing-模型迁移到新-GC"><a href="#2-2-Freezing-模型迁移到新-GC" class="headerlink" title="2.2 Freezing 模型迁移到新 GC"></a>2.2 Freezing 模型迁移到新 GC</h3><p>1、背景说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Freezing 模型在早期保障线程安全，但带来了严重开发痛点。</span><br></pre></td></tr></table></figure><p>2、痛点</p><table><thead><tr><th align="center">问题</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">开发体验差</td><td align="center">一旦对象冻结，就无法修改属性，开发者需频繁复制数据(copy pattern)</td></tr><tr><td align="center">性能问题</td><td align="center">大量冻结&#x2F;解冻操作导致 GC 压力和 CPU 开销</td></tr><tr><td align="center">生态兼容差</td><td align="center">难以与 iOS&#x2F;Swift 共享可变数据结构(如 MutableList)</td></tr><tr><td align="center">学习曲线陡峭</td><td align="center">多线程逻辑必须围绕“共享 &#x3D; 不可变”设计，违背直觉</td></tr></tbody></table><p>3、新 GC 设计目标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与 Kotlin/JVM 体验一致</span><br><span class="line">简化跨平台共享逻辑</span><br><span class="line">减少冻结异常</span><br><span class="line">提升并发性能与生态兼容性</span><br></pre></td></tr></table></figure><p>4、总结一句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新 GC 让 Kotlin/Native 更像 Kotlin —— 无冻结哲学，性能与体验双提升</span><br></pre></td></tr></table></figure><p>5、面试问法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、面试问法：「为什么 Kotlin/Native 要从 Freezing 模型迁移到新 GC？」</span><br><span class="line">2、答题要点</span><br><span class="line">-旧模型冻结机制复杂、易出错；</span><br><span class="line">-新 GC 自动化内存管理、支持自然并发；</span><br><span class="line">-从 1.7 引入 → 2.0 稳定 → 2025 年默认。</span><br><span class="line"></span><br><span class="line">3、迁移对比：</span><br><span class="line">// 旧模型</span><br><span class="line">val obj = MyObject().freeze()</span><br><span class="line">// 新模型</span><br><span class="line">val obj = MyObject() // 可直接共享</span><br><span class="line"></span><br><span class="line">4、注意：</span><br><span class="line">-迁移时需删除 freeze()，并测试并发逻辑；</span><br><span class="line">-新模型略增内存占用但可调优。</span><br></pre></td></tr></table></figure><h3 id="2-3-避免数据冻结"><a href="#2-3-避免数据冻结" class="headerlink" title="2.3 避免数据冻结"></a>2.3 避免数据冻结</h3><p>1、在旧模型(Freezing)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、说明</span><br><span class="line">要么冻结整个对象（obj.freeze()），要么使用 线程隔离（Worker） 或 复制数据（deepCopy）。</span><br><span class="line"></span><br><span class="line">2、常见做法：</span><br><span class="line">val worker = Worker.start()</span><br><span class="line">val future = worker.execute(TransferMode.SAFE, &#123; myData.freeze() &#125;) &#123; data -&gt;</span><br><span class="line">    process(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、旧模型策略：</span><br><span class="line">-不可变对象优先；</span><br><span class="line">-必要时 .freeze()；</span><br><span class="line">-频繁冻结会影响性能。</span><br></pre></td></tr></table></figure><p>2、新模型(Concurrent GC)（&gt;&#x3D; Kotlin 1.9）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、说明</span><br><span class="line">不再需要冻结机制，可直接共享对象，Kotlin/Native runtime 自动管理内存安全。</span><br><span class="line"></span><br><span class="line">2、示例</span><br><span class="line">val sharedState = mutableMapOf&lt;String, Int&gt;()</span><br><span class="line">coroutineScope &#123;</span><br><span class="line">    launch(Dispatchers.Default) &#123; sharedState[&quot;key&quot;] = 1 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、关键点：</span><br><span class="line">-使用最新编译器（Kotlin 1.9+）；</span><br><span class="line">-确认启用新 GC（默认启用）；</span><br><span class="line">-避免显式 freeze 调用，可能导致不兼容。</span><br></pre></td></tr></table></figure><p>3、面试问法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、「如何在多线程中避免数据冻结问题？」</span><br><span class="line">2、答题要点：</span><br><span class="line">-迁移新模型：启用 kotlin.native.binary.memoryModel=experimental（1.7+ 默认）。</span><br><span class="line">-使用协程：coroutineScope + launch 多线程共享可变对象。</span><br><span class="line">-旧项目兼容方案：冻结必要对象或使用 Stately 状态隔离库。</span><br><span class="line"></span><br><span class="line">3、实践建议：</span><br><span class="line">-避免显式 .freeze()；</span><br><span class="line">-使用 ensureNeverFrozen() 检查误冻；</span><br><span class="line">-新模型中关注 GC 性能和内存占用。</span><br></pre></td></tr></table></figure><h3 id="2-4-性能瓶颈及优化思路"><a href="#2-4-性能瓶颈及优化思路" class="headerlink" title="2.4 性能瓶颈及优化思路"></a>2.4 性能瓶颈及优化思路</h3><p>1、常见瓶颈</p><table><thead><tr><th align="center">类型</th><th align="center">表现</th><th align="center">优化建议</th></tr></thead><tbody><tr><td align="center">JNI&#x2F;FFI 调用</td><td align="center">Native ↔ JVM&#x2F;Swift 频繁跨语言调用</td><td align="center">尽量批量传递数据、减少 bridge 调用</td></tr><tr><td align="center">序列化性能</td><td align="center">Json、Proto 缓慢</td><td align="center">用 kotlinx.serialization 预配置优化</td></tr><tr><td align="center">协程调度</td><td align="center">在 iOS 线程池执行时阻塞</td><td align="center">使用 Dispatchers.Default 或自定义调度器</td></tr><tr><td align="center">内存管理</td><td align="center">Kotlin&#x2F;Native 对象过多或冻结滥用</td><td align="center">升级至新 GC，减少对象跨线程操作</td></tr><tr><td align="center">I&#x2F;O 访问</td><td align="center">Ktor 客户端在 iOS&#x2F;Native 性能较弱</td><td align="center">替换为 platform-native 网络库或引入缓存层</td></tr><tr><td align="center">构建时间</td><td align="center">多平台 Gradle Task 过多</td><td align="center">使用 Configuration Cache + buildSrc优化 Gradle</td></tr></tbody></table><p>2、实践建议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、配置</span><br><span class="line"># gradle.properties</span><br><span class="line">kotlin.native.binary.memoryModel=experimental</span><br><span class="line"></span><br><span class="line">2、说明</span><br><span class="line">-用 expect/actual 拆分性能关键逻辑；</span><br><span class="line">-避免 shared 层做重计算；</span><br><span class="line">-使用 Instruments/KMP Benchmark 监控内存与 CPU。</span><br></pre></td></tr></table></figure><p>3、面试亮点答法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KMP 性能瓶颈集中在跨语言调用和构建环节，我通常通过减少桥接、模块化构建和 GC 调优来提升性能。</span><br></pre></td></tr></table></figure><h3 id="2-5-iOS-端调试"><a href="#2-5-iOS-端调试" class="headerlink" title="2.5 iOS 端调试"></a>2.5 iOS 端调试</h3><p>1、常见原因</p><table><thead><tr><th align="center">问题</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Debug 断点受限</td><td align="center">iOS 调试器 (lldb) 对 Kotlin&#x2F;Native 支持不完善</td></tr><tr><td align="center">符号信息缺失</td><td align="center">编译产物为 .framework，符号被 strip</td></tr><tr><td align="center">异常堆栈模糊</td><td align="center">Kotlin&#x2F;Native 抛错信息简化</td></tr><tr><td align="center">构建差异</td><td align="center">Gradle&#x2F;Xcode 不同步</td></tr></tbody></table><p>2、解决方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">方案1：启用调试符号</span><br><span class="line"></span><br><span class="line">binaries &#123;</span><br><span class="line">    framework &#123;</span><br><span class="line">        isStatic = false</span><br><span class="line">        freeCompilerArgs += listOf(&quot;-g&quot;) // 开启调试信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2、方案二：使用 KDoctor 工具检查配置</span><br><span class="line">kdoctor</span><br><span class="line">可检测 Gradle + Xcode 环境、Kotlin Native Toolchain。</span><br><span class="line"></span><br><span class="line">3、方案三：使用 KMM Plugin + Xcode Attach 调试</span><br><span class="line"></span><br><span class="line">-在 Android Studio 使用 Kotlin Multiplatform Mobile 插件；</span><br><span class="line">-启动 iOS App 后，用 Xcode “Attach to Process by PID or Name”。</span><br><span class="line"></span><br><span class="line">4、方案四：日志与 Crash 分析</span><br><span class="line"></span><br><span class="line">-使用 println() + NSLog() 混合输出；</span><br><span class="line">-捕获异常使用：</span><br><span class="line"></span><br><span class="line">try &#123; ... &#125; catch (e: Throwable) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5、方案五：升级 Kotlin 版本</span><br><span class="line">Kotlin 1.9+ 的 Native Debugger 对 LLDB 支持已大幅提升。</span><br></pre></td></tr></table></figure><p>3、面试答法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iOS 端调试困难主要因符号和 LLDB 支持不足，</span><br><span class="line">我通常通过开启 -g 调试符号、KDoctor 检查和 Xcode Attach 联调来解决。</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><table><thead><tr><th align="center">面试题</th><th align="center">一句话记忆</th></tr></thead><tbody><tr><td align="center">Kotlin&#x2F;Native 内存机制</td><td align="center">从 Freezing 模型进化到自动 GC，提升易用性</td></tr><tr><td align="center">迁移原因</td><td align="center">改善开发体验、性能与跨平台兼容性</td></tr><tr><td align="center">多线程冻结问题</td><td align="center">新 GC 下不再需要冻结，旧模型可用 Worker + freeze</td></tr><tr><td align="center">性能优化</td><td align="center">减少跨语言调用、优化序列化与构建流程</td></tr><tr><td align="center">iOS 调试困难</td><td align="center">启用调试符号、使用 KDoctor、Xcode Attach</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.Kotlin/Native 的内存管理机制？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.为什么 Kotlin/Native 从 Freezing 模型迁移到新 GC？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.如何在多线程中避免数据冻结问题？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.KMP 项目常见性能瓶颈及优化思路？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.KMP 在 iOS 端调试困难的原因与解决方案？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试相关" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="KMP面试题" scheme="https://pgzxc.github.io/tags/KMP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
