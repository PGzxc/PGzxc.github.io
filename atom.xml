<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PGzxc的博客</title>
  
  <subtitle>纸上得来终觉浅 绝知此事要躬行</subtitle>
  <link href="http://pgzxc.github.io/atom.xml" rel="self"/>
  
  <link href="http://pgzxc.github.io/"/>
  <updated>2020-08-15T10:38:21.939Z</updated>
  <id>http://pgzxc.github.io/</id>
  
  <author>
    <name>PGzxc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo博客开发之——Coding Pages 申请 SSL 证书错误</title>
    <link href="http://pgzxc.github.io/posts/73040432.html"/>
    <id>http://pgzxc.github.io/posts/73040432.html</id>
    <published>2020-08-15T10:37:30.000Z</published>
    <updated>2020-08-15T10:38:21.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-现象"><a href="#一-现象" class="headerlink" title="一 现象"></a>一 现象</h2><p>Hexo博客在进行Coding Pages绑定域名时显示如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme:error:unauthorized: During secondary validation: Invalid response from http:&#x2F;&#x2F;pgzxc.com&#x2F;.well-known&#x2F;acme-challenge&#x2F;u0F-eNkNn958JbxhnH0lyhGxS6d_FMLHWmIiiwF8P5k [185.199.108.153]: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n &lt;head&gt;\n &lt;meta http-equiv&#x3D;\&quot;Content-type\&quot; content&#x3D;\&quot;text&#x2F;html; charset&#x3D;utf-8\&quot;&gt;\n &lt;meta http-equiv&#x3D;\&quot;Co&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://images.pgzxc.com/coding-bang-error.png" alt=""></p><h2 id="二-原因分析"><a href="#二-原因分析" class="headerlink" title="二 原因分析"></a>二 原因分析</h2><p> 这种错误一般是 hexo 博客双线部署到 GitHub Pages 和 Coding Pages 过程中出现的，并且已经在域名 DNS 配置好了 GitHub 的域名解析，这种情况下，在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败 </p><h2 id="三-解决办法"><a href="#三-解决办法" class="headerlink" title="三 解决办法"></a>三 解决办法</h2><p> 先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，等待申请成功再恢复 GitHub 的解析 </p><p><img src="https://images.pgzxc.com/coding-github-pause.png" alt=""></p><p><img src="https://images.pgzxc.com/coding-yuming-bang-success.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-现象&quot;&gt;&lt;a href=&quot;#一-现象&quot; class=&quot;headerlink&quot; title=&quot;一 现象&quot;&gt;&lt;/a&gt;一 现象&lt;/h2&gt;&lt;p&gt;Hexo博客在进行Coding Pages绑定域名时显示如下错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;acme:error:unauthorized: During secondary validation: Invalid response from http:&amp;#x2F;&amp;#x2F;pgzxc.com&amp;#x2F;.well-known&amp;#x2F;acme-challenge&amp;#x2F;u0F-eNkNn958JbxhnH0lyhGxS6d_FMLHWmIiiwF8P5k [185.199.108.153]: &amp;quot;&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html&amp;gt;\n &amp;lt;head&amp;gt;\n &amp;lt;meta http-equiv&amp;#x3D;\&amp;quot;Content-type\&amp;quot; content&amp;#x3D;\&amp;quot;text&amp;#x2F;html; charset&amp;#x3D;utf-8\&amp;quot;&amp;gt;\n &amp;lt;meta http-equiv&amp;#x3D;\&amp;quot;Co&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——部署到Coding上</title>
    <link href="http://pgzxc.github.io/posts/7871b3a7.html"/>
    <id>http://pgzxc.github.io/posts/7871b3a7.html</id>
    <published>2020-08-15T10:34:59.000Z</published>
    <updated>2020-08-15T10:36:38.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>之前将博客部署到了Github上，但是由于网络的原因导致网站有时候无法访问，这时候的解决办法是将博客部署到两个服务器上，国外访问时使用Github上的项目，国内访问时使用本文介绍的Coding上</p><a id="more"></a><h2 id="二-列表"><a href="#二-列表" class="headerlink" title="二 列表"></a>二 列表</h2><ul><li>hexo博客代码</li><li><a href="https://coding.net/">coding</a></li></ul><h2 id="三-配置SSH"><a href="#三-配置SSH" class="headerlink" title="三 配置SSH"></a>三 配置SSH</h2><ul><li><p>查看<code>C:\Users\用户名\</code>下有没有.ssh文件夹(如果有，id_rsa.pub是要设置的)</p></li><li><p>如果没有，执行下面的指令生成SSH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot; </span><br></pre></td></tr></table></figure></li><li><p>接下来几步中系统会要你输入密码 ( <strong>注：不设置密码的可以直接按三次回车</strong> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):&lt;输入密码&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入密码&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://images.pgzxc.com/coding-ras-setting.png" alt=""></p><h2 id="四-配置Coding"><a href="#四-配置Coding" class="headerlink" title="四 配置Coding"></a>四 配置Coding</h2><h3 id="4-1-实名认证-没有实名认证，无法设置静态博客"><a href="#4-1-实名认证-没有实名认证，无法设置静态博客" class="headerlink" title="4.1 实名认证(没有实名认证，无法设置静态博客)"></a>4.1 实名认证(没有实名认证，无法设置静态博客)</h3><ul><li><p><a href="https://coding.net/">Cdoing官网</a>登录后，点击右上角下拉列表中的团队管理 </p><p><img src="https://images.pgzxc.com/coding-auth-disable.png" alt=""></p></li><li><p>绑定了手机号后，可以进行实名认证了</p><p><img src="https://images.pgzxc.com/coding-auth-set-phone-after.png" alt=""></p></li><li><p>点击进行实名认证，输入姓名和身份证号</p><p><img src="https://images.pgzxc.com/coding-auth-success.png" alt=""></p></li></ul><h3 id="4-2-配置SSH"><a href="#4-2-配置SSH" class="headerlink" title="4.2 配置SSH"></a>4.2 配置SSH</h3><ul><li><p>点击右上角下拉列表中的<code>个人账户设置</code>，在左侧找到SSH公钥</p><p><img src="https://images.pgzxc.com/coding-ssh-list.png" alt=""></p></li><li><p>点击右上角的<code>新增公钥</code>，将id_rsa.pub中的内容全部copy到<code>公钥内容</code>中，公钥名称自定义，并设置期限为<code>永久有效</code><br><img src="https://images.pgzxc.com/coding-ssh-setting.png" alt=""></p></li></ul><h3 id="4-3-新建项目"><a href="#4-3-新建项目" class="headerlink" title="4.3 新建项目"></a>4.3 新建项目</h3><ul><li><p>点击<code>创建项目</code>时，弹出项目模板选择页面(选择DevOps项目)</p><p><img src="https://images.pgzxc.com/coding-create-project-devops.png" alt=""></p></li><li><p>填写项目创建信息</p><p><img src="https://images.pgzxc.com/coding-devops-info.png" alt=""></p></li><li><p>进入刚刚创建的项目，找到仓库设置，copy SSH下路径(hexo博客设置会用到)</p><p><img src="https://images.pgzxc.com/coding-ssh-gitcopy.png" alt=""></p></li></ul><h2 id="五-配置hexo博客-config-yml"><a href="#五-配置hexo博客-config-yml" class="headerlink" title="五 配置hexo博客( _config.yml )"></a>五 配置hexo博客( _config.yml )</h2><h3 id="5-1-配置-config-yml"><a href="#5-1-配置-config-yml" class="headerlink" title="5.1 配置_config.yml"></a>5.1 配置_config.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:                                         #部署部分的设置</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">     github: git@github.com:PGzxc&#x2F;PGzxc.github.io.git(换成你自己的)</span><br><span class="line">     coding: git@e.coding.net:pgzxc&#x2F;pgzxc&#x2F;pgzxc.git(换成你自己的)</span><br></pre></td></tr></table></figure><h3 id="5-2-执行hexo-指令"><a href="#5-2-执行hexo-指令" class="headerlink" title="5.2 执行hexo 指令"></a>5.2 执行hexo 指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/coding-deploy-coding.png" alt=""></p><h2 id="六-Coding部署"><a href="#六-Coding部署" class="headerlink" title="六 Coding部署"></a>六 Coding部署</h2><ul><li><p>步骤五执行后，项目下会有部署的代码文件</p><p><img src="https://images.pgzxc.com/coding-code-property-view.png" alt=""></p></li><li><p>点击下方的<code>持续部署</code>，从列表中找到静态网站(此时的访问地址是无法访问的)</p><p><img src="https://images.pgzxc.com/coding-static-webview-list.png" alt=""></p></li><li><p>点击<code>立即部署</code>按钮，再次点击访问地址就可以正常访问了</p><p><img src="https://images.pgzxc.com/coding-static-webview-deply-quick.png" alt=""></p></li></ul><h2 id="七-自定义域名（有域名者—阿里云域名解析）"><a href="#七-自定义域名（有域名者—阿里云域名解析）" class="headerlink" title="七 自定义域名（有域名者—阿里云域名解析）"></a>七 自定义域名（有域名者—阿里云域名解析）</h2><ul><li><p>将在coding上的网站添加到域名解析列表中(最好先将github解析暂停，否则会出现解析失败的情况)</p><p><img src="https://images.pgzxc.com/coding-aliyun-jiexi.png" alt=""></p></li><li><p>在Coding静态网站—&gt;自定义域名，输入要绑定的域名，添加绑定，并强制开启https访问</p><p><img src="https://images.pgzxc.com/coding-yuming-bang-success.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;之前将博客部署到了Github上，但是由于网络的原因导致网站有时候无法访问，这时候的解决办法是将博客部署到两个服务器上，国外访问时使用Github上的项目，国内访问时使用本文介绍的Coding上&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——连接数据库(15.4)</title>
    <link href="http://pgzxc.github.io/posts/ba501380.html"/>
    <id>http://pgzxc.github.io/posts/ba501380.html</id>
    <published>2020-08-14T14:26:06.000Z</published>
    <updated>2020-08-14T14:28:03.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>C#语言中Connection类是ADO.NET组件连接数据库时第一个要使用的类，也是通过编程访问数据库的第一步。接下也来我们来了解一下Connection类中的常用属性和方法，以及如何连接SQL Server数据库</p><a id="more"></a><h2 id="二-Connection类概述"><a href="#二-Connection类概述" class="headerlink" title="二 Connection类概述"></a>二 Connection类概述</h2><p>Connection类根据要访问的数据和访问方式不同，使用的命名空间也不同，类名也稍有区别，SqlConnection类中提供的常用属性和方法如下</p><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">SqlConnection()</td><td align="center">无参构造方法</td></tr><tr><td align="center">SqlConnection(string connectionstring)</td><td align="center">带参数的构造方法，数据库连接字符串作为参数</td></tr><tr><td align="center">Connectionstring</td><td align="center">属性，获取或设置数据库的连接串</td></tr><tr><td align="center">State</td><td align="center">属性，获取当前数据库的状态，由枚举类型 Connectionstate 为其提供值</td></tr><tr><td align="center">ConnectionTimeout</td><td align="center">属性，获取在尝试连接时终止尝试并生成错误之前所等待的时间</td></tr><tr><td align="center">DataSource</td><td align="center">属性，获取要连接的 SQL Server 的实例名</td></tr><tr><td align="center">Open()</td><td align="center">方法，打开一个数据库连接</td></tr><tr><td align="center">Close()</td><td align="center">方法，关闭数据库连接</td></tr><tr><td align="center">BeginTransaction()</td><td align="center">方法，开始一个数据库事务</td></tr></tbody></table><h2 id="三-使用-Connection-类连接数据库"><a href="#三-使用-Connection-类连接数据库" class="headerlink" title="三 使用 Connection 类连接数据库"></a>三 使用 Connection 类连接数据库</h2><p> 数据库连接串的书写方法有很多，这里介绍两种常用的方法 </p><h3 id="3-1-第1种方式"><a href="#3-1-第1种方式" class="headerlink" title="3.1 第1种方式"></a>3.1 第1种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server &#x3D; 服务器名称 &#x2F; 数据库的实例名 ; uid &#x3D; 登录名 ; pwd &#x3D; 密码 ; database &#x3D; 数据库名称</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>server：用于指定要访问数据库的数据库实例名，服务器名称可以换成IP地址或者数据库所在的计算机名称，如果访问的是本机数据库，则可以使用”.”来代替。例如连接的是本机的默认数据库，则可以写成”server=.”</li><li>uid：登录到指定SQL Server数据库实例的用户名，相当于以SQL Server身份验证方式登录数据库时使用的用户名，例如sa用户</li><li>pwd：与uid用户对应的密码</li><li>database：要访问数据库实例下的数据库名</li></ul><h3 id="3-2-第2种方式"><a href="#3-2-第2种方式" class="headerlink" title="3.2 第2种方式"></a>3.2 第2种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data Source &#x3D; 服务器名称 \ 数据库实例名 ; Initial Catalog &#x3D; 数据库名称 ; User ID &#x3D; 用户名 ; Password &#x3D; 密码</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Data Source：与第1种连接串写法中的database属性的写法一样，用于指定数据库所在的服务器名称和数据库实例名，如果连接的是本机的默认数据库实例，则写成”Data Source=.”的形式</li><li>Initial Catalog：与第1种连接串写法中的database属性的写法一样，用于指定在Data Source中数据库实例下的数据库名</li><li>User ID：与第1种连接串写法中的uid属性的写法一样，用于指定登录数据库的用户名</li><li>Password：与第 1 种连接串写法中的 pwd 属性的写法一样，用于指定 User ID 用户名所对应的密码。</li></ul><h2 id="四-连接相关操作"><a href="#四-连接相关操作" class="headerlink" title="四 连接相关操作"></a>四 连接相关操作</h2><p> 在完成了数据库连接串的编写后即可使用 SqlConnection 类与数据库连接，分以下 3 步完成 </p><h3 id="4-1-创建-SqlConnection-类的实例"><a href="#4-1-创建-SqlConnection-类的实例" class="headerlink" title="4.1  创建 SqlConnection 类的实例"></a>4.1  创建 SqlConnection 类的实例</h3><p> 对于 SqlConnection 类来说，上表中提供了两个构造方法，通常是使用带一个字符串参数的构造方法来设置数据库的连接串创建其实例，语句形式如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlConnection 连接对象名 &#x3D; new SqlConnection( 数据库连接串 );</span><br></pre></td></tr></table></figure><h3 id="4-2-打开数据库连接"><a href="#4-2-打开数据库连接" class="headerlink" title="4.2 打开数据库连接"></a>4.2 打开数据库连接</h3><p> 在创建 SqlConnection 连接类的实例后并没有连接上数据库，需要使用连接类的 Open 方法打开数据库的连接。</p><p>在使用 Open 方法打开数据库连接时，如果数据库的连接串不正确或者数据库的服务处于关闭状态，会出现打开数据库失败的相关异常，因此需要通过异常处理来处理异常。</p><p>打开数据库连接的语句形式如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接对象名.Open();</span><br></pre></td></tr></table></figure><h3 id="4-3-关闭数据库连接"><a href="#4-3-关闭数据库连接" class="headerlink" title="4.3 关闭数据库连接"></a>4.3 关闭数据库连接</h3><p>在对数据库的操作结束后要将数据库的连接断开，以节省数据库连接的资源。</p><p>关闭数据库连接的语句形式如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接对象名.Close();</span><br></pre></td></tr></table></figure><p> 如果在打开数据库连接时使用了异常处理，则将关闭数据库连接的语句放到异常处理的 finally 语句中，这样能保证无论是否发生了异常都将数据库连接断开，以释放资源 </p><p> 除了使用异常处理的方式释放资源外，还可以使用 using 的方式释放资源 。具体的语句如下。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using(SqlConnection 连接对象名 &#x3D; new SQLConnection( 数据库连接串 ))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;打开数据库连接</span><br><span class="line">    &#x2F;&#x2F;对数据库先关操作的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> using 关键字的用法主要有两个，一个是引用命名空间，一个是创建非托管资源对象。</p><p>在 .NET 平台上资源分为托管资源和非托管资源，托管资源是由 .NET 框架直接提供对其资源在内存中的管理，例如声明的变量；非托管资源则不能直接由 .NET 框架对其管理，需要使用代码来释放资源，例如数据库资源、操作系统资源等。 </p><h2 id="五-实例"><a href="#五-实例" class="headerlink" title="五 实例"></a>五 实例</h2><h3 id="5-1-实例一-创建与本机-SQL-Server-数据库的连接，并使用异常处理"><a href="#5-1-实例一-创建与本机-SQL-Server-数据库的连接，并使用异常处理" class="headerlink" title="5.1 实例一  创建与本机 SQL Server 数据库的连接，并使用异常处理"></a>5.1 实例一  创建与本机 SQL Server 数据库的连接，并使用异常处理</h3><h4 id="5-1-1-分析"><a href="#5-1-1-分析" class="headerlink" title="5.1.1 分析"></a>5.1.1 分析</h4><p> 连接 SQL Server 数据库时使用的用户名为 sa、密码为 pwdpwd，连接的数据库为test </p><h4 id="5-1-2-创建数据库test"><a href="#5-1-2-创建数据库test" class="headerlink" title="5.1.2 创建数据库test"></a>5.1.2 创建数据库test</h4><p>打开Microsoft SQL Server Management Studio，登录后，在数据库上右键，新建数据库并输入创建的数据库名称</p><p><img src="https://images.pgzxc.com/csharp-sql-server-create-tabe.gif" alt=""></p><h4 id="5-1-3-代码"><a href="#5-1-3-代码" class="headerlink" title="5.1.3 代码"></a>5.1.3 代码</h4><p> 创建 Windows 窗体应用程序，并在窗体上放置一个按钮 ，在按钮的单击事件中加入以下代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line"> &#123;</span><br><span class="line">   &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">   &#x2F;&#x2F;string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">   string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;Integrate Security &#x3D; True&quot;;</span><br><span class="line">   &#x2F;&#x2F;var connStr &#x3D; &quot;server&#x3D;.;uid&#x3D;sa;pwd&#x3D;root;database&#x3D;test&quot;;</span><br><span class="line">   &#x2F;&#x2F;创建SqlConnection的实例</span><br><span class="line">    SqlConnection conn &#x3D; null;</span><br><span class="line">    try</span><br><span class="line">      &#123;</span><br><span class="line">         conn &#x3D; new SqlConnection(connStr);</span><br><span class="line">         conn.Open();</span><br><span class="line">         MessageBox.Show(&quot;数据库连接成功！&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">      catch (Exception ex)</span><br><span class="line">      &#123;</span><br><span class="line">           MessageBox.Show(&quot;数据库连接失败！&quot; + ex.Message);</span><br><span class="line">      &#125;</span><br><span class="line">      finally</span><br><span class="line">      &#123;</span><br><span class="line">         if (conn !&#x3D; null)</span><br><span class="line">         &#123;</span><br><span class="line">            &#x2F;&#x2F;关闭数据库</span><br><span class="line">            conn.Close();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-4-效果图"><a href="#5-1-4-效果图" class="headerlink" title="5.1.4 效果图"></a>5.1.4 效果图</h4><p><img src="https://images.pgzxc.com/csharp-sql-server-connection-scucess.gif" alt=""></p><h3 id="5-2-实例二-在上一实例的基础上使用-using-关键字释放资源。"><a href="#5-2-实例二-在上一实例的基础上使用-using-关键字释放资源。" class="headerlink" title="5.2 实例二 在上一实例的基础上使用 using 关键字释放资源。"></a>5.2 实例二 在上一实例的基础上使用 using 关键字释放资源。</h3><h4 id="5-2-1-代码"><a href="#5-2-1-代码" class="headerlink" title="5.2.1 代码"></a>5.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F;编写数据库连接串</span><br><span class="line">   &#x2F;&#x2F;string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;User ID&#x3D;sa;Password&#x3D;root&quot;;</span><br><span class="line">   &#x2F;&#x2F;string connStr &#x3D; &quot;Data source&#x3D;.;Initial Catalog&#x3D;test;Integrate Security &#x3D; True&quot;;</span><br><span class="line">   var connStr &#x3D; &quot;server&#x3D;.;uid&#x3D;sa;pwd&#x3D;root;database&#x3D;test&quot;;</span><br><span class="line">   &#x2F;&#x2F;创建SqlConnection的实例</span><br><span class="line">          </span><br><span class="line">   try</span><br><span class="line">      &#123;</span><br><span class="line">         using (SqlConnection conn&#x3D;new SqlConnection(connStr))</span><br><span class="line">         conn.Open();</span><br><span class="line">         MessageBox.Show(&quot;数据库连接成功！&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Exception ex)</span><br><span class="line">       &#123;</span><br><span class="line">          MessageBox.Show(&quot;数据库连接失败！&quot; + ex.Message);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;C#语言中Connection类是ADO.NET组件连接数据库时第一个要使用的类，也是通过编程访问数据库的第一步。接下也来我们来了解一下Connection类中的常用属性和方法，以及如何连接SQL Server数据库&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——V7.1.1升级到V7.8.0</title>
    <link href="http://pgzxc.github.io/posts/6cce2103.html"/>
    <id>http://pgzxc.github.io/posts/6cce2103.html</id>
    <published>2020-08-12T13:52:31.000Z</published>
    <updated>2020-08-12T14:07:39.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>旧版本存在博客数量过多编译时间过长现象，且可能因为文件过多存在编译时出现<code>JavaScript heap out of memory</code>问题，故本次升级到最新稳定版(V7.8.0)</p><ul><li>cole主题</li><li>安装npm依赖最新检测工具</li><li>修改项目下的_config.yml(与v7.1.1相比)</li><li>修改themes/next下的主题</li></ul><a id="more"></a><h2 id="二-cole主题"><a href="#二-cole主题" class="headerlink" title="二 cole主题"></a>二 cole主题</h2><h2 id="一-cole主题"><a href="#一-cole主题" class="headerlink" title="一  cole主题"></a>一  cole主题</h2><ul><li><p>打开<a href="https://images.pgzxc.com/hexo-git-clone-v780.png">hexo-theme-next</a>网址，查看说明向导</p></li><li><p>打开博客目录，执行git clone指令<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></p><p><img src="https://images.pgzxc.com/hexo-git-clone-v780.png" alt=""></p></li></ul><h2 id="三-安装npm依赖最新检测工具"><a href="#三-安装npm依赖最新检测工具" class="headerlink" title="三 安装npm依赖最新检测工具"></a>三 安装npm依赖最新检测工具</h2><ul><li><p>安装依赖工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure></li><li><p>查看最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu  </span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-ncu.png" alt=""></p></li><li><p>执行ncu -u进行升级，然后删除现有的node-modules，执行npm install安装新的依赖(由于hexo-renderer-marked 3.0.0版本有bug，使用2.0.0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-ncu-u.png" alt=""></p></li></ul><h2 id="四-修改项目下的-config-yml-与v7-1-1相比"><a href="#四-修改项目下的-config-yml-与v7-1-1相比" class="headerlink" title="四 修改项目下的_config.yml(与v7.1.1相比)"></a>四 修改项目下的_config.yml(与v7.1.1相比)</h2><h3 id="4-1-permalink-defaults"><a href="#4-1-permalink-defaults" class="headerlink" title="4.1 permalink_defaults"></a>4.1 permalink_defaults</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#add v7.8.0</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true </span><br><span class="line">  trailing_html: true </span><br></pre></td></tr></table></figure><h3 id="4-2-external-link"><a href="#4-2-external-link" class="headerlink" title="4.2 external_link"></a>4.2 external_link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#add v7.8.0</span><br><span class="line">external_link: </span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="4-3-hightlight、prismjs"><a href="#4-3-hightlight、prismjs" class="headerlink" title="4.3 hightlight、prismjs"></a>4.3 hightlight、prismjs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># add v7.8.0</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#39;&#39; </span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line">prismjs:  </span><br><span class="line">  enable: false</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="4-4-meta-generator"><a href="#4-4-meta-generator" class="headerlink" title="4.4 meta_generator"></a>4.4 meta_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta_generator: true  </span><br></pre></td></tr></table></figure><h3 id="4-5-updated-option"><a href="#4-5-updated-option" class="headerlink" title="4.5 updated_option"></a>4.5 updated_option</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updated_option: &#39;mtime&#39; </span><br></pre></td></tr></table></figure><h3 id="4-6-v7-1-1升级到v7-8-0后的默认效果"><a href="#4-6-v7-1-1升级到v7-8-0后的默认效果" class="headerlink" title="4.6 v7.1.1升级到v7.8.0后的默认效果"></a>4.6 v7.1.1升级到v7.8.0后的默认效果</h3><p><img src="https://images.pgzxc.com/hexo-update-v78-default.png" alt=""></p><h2 id="五-修改themes-next下的主题"><a href="#五-修改themes-next下的主题" class="headerlink" title="五 修改themes/next下的主题"></a>五 修改themes/next下的主题</h2><h3 id="5-1-config-yml"><a href="#5-1-config-yml" class="headerlink" title="5.1 _config.yml"></a>5.1 _config.yml</h3><h4 id="5-1-1-修改footer"><a href="#5-1-1-修改footer" class="headerlink" title="5.1.1 修改footer"></a>5.1.1 修改footer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  since: 2017 </span><br><span class="line">  icon:</span><br><span class="line">    name: heart </span><br><span class="line">    animated: false</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br><span class="line">  copyright: pgzxc   </span><br><span class="line">  powered: false</span><br></pre></td></tr></table></figure><h4 id="5-1-2-修改beian"><a href="#5-1-2-修改beian" class="headerlink" title="5.1.2 修改beian"></a>5.1.2 修改beian</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beian: </span><br><span class="line">    enable: true</span><br><span class="line">    icp: 京ICP备xxx</span><br><span class="line">    gongan_id:</span><br><span class="line">    gongan_num:</span><br><span class="line">    gongan_icon_url:</span><br></pre></td></tr></table></figure><h4 id="5-1-3-Schemes"><a href="#5-1-3-Schemes" class="headerlink" title="5.1.3 Schemes"></a>5.1.3 Schemes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><h4 id="5-1-4-menu"><a href="#5-1-4-menu" class="headerlink" title="5.1.4 menu"></a>5.1.4 menu</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu: </span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  comments: &#x2F;comments&#x2F; || fa fa-comments </span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true #modify 2020-08-12</span><br></pre></td></tr></table></figure><h4 id="5-1-5-avatar"><a href="#5-1-5-avatar" class="headerlink" title="5.1.5 avatar"></a>5.1.5 avatar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avatar: </span><br><span class="line">  url: &#x2F;https:&#x2F;&#x2F;images.pgzxc.com&#x2F;avatar.jpg</span><br><span class="line">  rounded: true</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure><h4 id="5-1-6-social"><a href="#5-1-6-social" class="headerlink" title="5.1.6 social"></a>5.1.6 social</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;PGzxc || fab fa-github</span><br><span class="line">  CSDN: http:&#x2F;&#x2F;blog.csdn.net&#x2F;calvin_zhou || fab fa-book</span><br><span class="line">  微博: http:&#x2F;&#x2F;weibo.com&#x2F;5582039920 || fab fa-weibo</span><br><span class="line">  简书: http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;c5cdcb4dc52b || fab fa-heartbeat</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure><h4 id="5-1-7-link"><a href="#5-1-7-link" class="headerlink" title="5.1.7 link"></a>5.1.7 link</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: 友情链接</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: inline</span><br><span class="line"></span><br><span class="line">links:</span><br><span class="line">  鸿洋: https:&#x2F;&#x2F;wanandroid.com&#x2F;</span><br></pre></td></tr></table></figure><h4 id="5-1-8-comment"><a href="#5-1-8-comment" class="headerlink" title="5.1.8 comment"></a>5.1.8 comment</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">livere_uid: MTAyMC8zMjQ1OC85Msxxx</span><br></pre></td></tr></table></figure><h4 id="5-1-9-leancloud-visitors"><a href="#5-1-9-leancloud-visitors" class="headerlink" title="5.1.9 leancloud_visitors"></a>5.1.9 leancloud_visitors</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors: </span><br><span class="line">  enable: false</span><br><span class="line">  app_id: xoStNXjq2xNoDRjTltoOztdq-gzGzoHsz</span><br><span class="line">  app_key: 6g89MPFNvTH2YHnKMAK1n1V8</span><br></pre></td></tr></table></figure><h4 id="5-1-10-busuanzi-count"><a href="#5-1-10-busuanzi-count" class="headerlink" title="5.1.10 busuanzi_count"></a>5.1.10 busuanzi_count</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure><h4 id="5-1-11-local-search"><a href="#5-1-11-local-search" class="headerlink" title="5.1.11 local_search"></a>5.1.11 local_search</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local_search: </span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  unescape: false</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure><h3 id="5-2-language-zh-CN-yml"><a href="#5-2-language-zh-CN-yml" class="headerlink" title="5.2 language/zh-CN.yml"></a>5.2 language/zh-CN.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:  </span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  comments: 留言板 #add 2020-08-12</span><br><span class="line">  schedule: 日程表</span><br><span class="line">  sitemap: 站点地图</span><br><span class="line">  commonweal: 公益 404</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;旧版本存在博客数量过多编译时间过长现象，且可能因为文件过多存在编译时出现&lt;code&gt;JavaScript heap out of memory&lt;/code&gt;问题，故本次升级到最新稳定版(V7.8.0)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cole主题&lt;/li&gt;
&lt;li&gt;安装npm依赖最新检测工具&lt;/li&gt;
&lt;li&gt;修改项目下的_config.yml(与v7.1.1相比)&lt;/li&gt;
&lt;li&gt;修改themes/next下的主题&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="http://pgzxc.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——SQL Server 2008无法连接错误(15.3)</title>
    <link href="http://pgzxc.github.io/posts/7264436a.html"/>
    <id>http://pgzxc.github.io/posts/7264436a.html</id>
    <published>2020-08-10T13:35:14.000Z</published>
    <updated>2020-08-10T13:36:27.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-现象"><a href="#一-现象" class="headerlink" title="一 现象"></a>一 现象</h2><p>打开Microsoft SQL Server Management Studio，连接服务器时，用户名和密码都正确，却显示连接服务器错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error:40-无法打开到SQL Server的连接(Microsoft SQL Server,错误2)</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://images.pgzxc.com/csharp-sql-server-login-error.png" alt=""></p><h2 id="二-解决办法"><a href="#二-解决办法" class="headerlink" title="二 解决办法"></a>二 解决办法</h2><h3 id="2-1-解决办法一"><a href="#2-1-解决办法一" class="headerlink" title="2.1 解决办法一"></a>2.1 解决办法一</h3><ul><li><p>右键计算机——&gt;管理，打开<code>计算机管理</code>，选择服务，找到<code>MSSQLSERVER</code>项</p><p><img src="https://images.pgzxc.com/csharp-sql-server-state-view.png" alt=""></p></li><li><p>双击<code>MSSQLSERVER</code>，设置启动类型为自动，并启动此选项</p><p><img src="https://images.pgzxc.com/csharp-sql-server-delegate-start-auto.png" alt=""></p></li></ul><h3 id="2-2-解决办法二"><a href="#2-2-解决办法二" class="headerlink" title="2.2 解决办法二"></a>2.2 解决办法二</h3><ul><li><p>在计算机程序中，找到<code>SQL Server配置管理器</code>，双击打开</p><p><img src="https://images.pgzxc.com/sql-server-config-manager.png" alt=""></p></li><li><p>找到SQL Server服务下的 SQL Server(MSSQLSERVEr)，将其启动</p><p><img src="https://images.pgzxc.com/sql-server-mssqlserver-start.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-现象&quot;&gt;&lt;a href=&quot;#一-现象&quot; class=&quot;headerlink&quot; title=&quot;一 现象&quot;&gt;&lt;/a&gt;一 现象&lt;/h2&gt;&lt;p&gt;打开Microsoft SQL Server Management Studio，连接服务器时，用户名和密码都正确，却显示连接服务器错误&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;error:40-无法打开到SQL Server的连接(Microsoft SQL Server,错误2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——SQL Server 2008R2 安装(15.2)</title>
    <link href="http://pgzxc.github.io/posts/483c6ba2.html"/>
    <id>http://pgzxc.github.io/posts/483c6ba2.html</id>
    <published>2020-08-10T13:32:34.000Z</published>
    <updated>2020-08-10T13:36:27.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>由于目前使用的电脑系统为windows 7 64位，官网提供的最新版本无法安装，故采用旧版本SQL Server进行安装，并演示以下内容</p><ul><li>软件的下载</li><li>软件的安装</li><li>软件的使用</li></ul><a id="more"></a><h2 id="二-软件下载"><a href="#二-软件下载" class="headerlink" title="二 软件下载"></a>二 软件下载</h2><ul><li><p>打开<a href="https://www.microsoft.com/en-us/download/details.aspx?id=30438">Microsoft® SQL Server® 2008 R2 SP2</a>官网地址，查看版本列表<br><img src="https://images.pgzxc.com/csharp-sql-server-2008-r2-webpage.png" alt=""></p></li><li><p>点击下载，从下载列中选择系统应的文件进行下载</p><p><img src="https://images.pgzxc.com/csharp-sql-server-x64-download.png" alt=""></p></li></ul><h2 id="三-软件安装"><a href="#三-软件安装" class="headerlink" title="三 软件安装"></a>三 软件安装</h2><ul><li><p>双击运行软件，弹出如图所示的安装界面<br><img src="https://images.pgzxc.com/csharp-sql-server-click-open.png" alt=""></p></li><li><p>选择<code>安装</code>选项卡对应的<code>全新安装或向现有安装添加功能</code><br><img src="https://images.pgzxc.com/csharp-sql-server-install-new.png" alt=""></p></li><li><p>在安装许可条例中，选择接受条款协议，点击下一步</p><p><img src="https://images.pgzxc.com/csharp-sql-server-install-agree.png" alt=""></p></li><li><p>安装程序支持文件<br><img src="https://images.pgzxc.com/csharp-sql-server-installing-support.png" alt=""></p></li><li><p>在功能选择页面，选择安装的功能组件和功能(默认全部)和安装位置，确认后，点击下一步<br> <img src="https://images.pgzxc.com/csharp-sql-server-install-position.png" alt=""></p></li><li><p>实例配置页面确认无需修改后，点击下一步</p><p><img src="https://images.pgzxc.com/csharp-sql-server-sql-config-default.png" alt=""></p></li><li><p>服务器配置页面检查服务器名称和启动类型</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-start-config.png" alt=""></p></li><li><p>数据库引擎配置(身份验证选择混合模式)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：sa</span><br><span class="line">密码：root</span><br></pre></td></tr></table></figure><p> <img src="https://images.pgzxc.com/csharp-sql-server-database-password.png" alt=""></p></li><li><p>Reporting Services配置，选择<code>安装本机模式默认配置</code></p><p> <img src="https://images.pgzxc.com/csharp-sql-server-reporting-service-config.png" alt=""></p></li><li><p>错误报告页面，根据需要选择是否发送错误报告</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-error-report.png" alt=""></p></li><li><p>显示安装进度</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-install-progress.png" alt=""></p></li><li><p>安装过程可能需要10-20分钟左右，出现 如图界面，安装完成</p><p> <img src="https://images.pgzxc.com/csharp-sql-server-install-finished.png" alt=""></p></li></ul><h2 id="三-软件使用"><a href="#三-软件使用" class="headerlink" title="三 软件使用"></a>三 软件使用</h2><ul><li><p>在Windows启动栏中找到<code>SQL Server Management Studio</code>点击启动</p><p><img src="https://images.pgzxc.com/sql-server-management-studio-open.png" alt=""></p></li><li><p>在弹出的<code>连接到服务器窗口</code>中，选择身份验证方式，输入用户名和密码，点击<code>连接</code></p><p><img src="https://images.pgzxc.com/sql-server-connect-server-username-password.png" alt=""></p></li><li><p>连接成功后的视图</p><p><img src="https://images.pgzxc.com/sql-server-connected-success-view.png" alt=""></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;由于目前使用的电脑系统为windows 7 64位，官网提供的最新版本无法安装，故采用旧版本SQL Server进行安装，并演示以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件的下载&lt;/li&gt;
&lt;li&gt;软件的安装&lt;/li&gt;
&lt;li&gt;软件的使用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——ADO.NET数据库操作及常用类概述(15.1)</title>
    <link href="http://pgzxc.github.io/posts/8f74b968.html"/>
    <id>http://pgzxc.github.io/posts/8f74b968.html</id>
    <published>2020-08-10T13:29:21.000Z</published>
    <updated>2020-08-10T13:36:27.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中ADO.NET是在ADO的基础上发展起来的，ADO(Active Data Object)是一个COM组件类库，用于访问数据库，而ADO.NET是在.NET平台上访问数据库的组件。</li><li>ADO.NET是以ODBC(Open Database Connectivity)技术的方式来访问数据库的一种技术</li></ul><a id="more"></a><h2 id="二-ADO-NET-中的常用命名空间"><a href="#二-ADO-NET-中的常用命名空间" class="headerlink" title="二  ADO.NET 中的常用命名空间"></a>二  ADO.NET 中的常用命名空间</h2><table><thead><tr><th align="center">命名空间</th><th align="center">数据库提供程序</th></tr></thead><tbody><tr><td align="center">System.Data.SqlClient</td><td align="center">Microsoft SQL Server</td></tr><tr><td align="center">System.Data.Odbc</td><td align="center">ODBC</td></tr><tr><td align="center">System.Data.OracleClient</td><td align="center">Oracle</td></tr><tr><td align="center">System.Data.OleDB</td><td align="center">OLE DB</td></tr></tbody></table><h2 id="三-数据库操作中常用的类"><a href="#三-数据库操作中常用的类" class="headerlink" title="三 数据库操作中常用的类"></a>三 数据库操作中常用的类</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul><li>在使用ADO.NET进行数据库操作时通常会用到5个类，分别是Connection类、Command类、DataReader类、DataAdapter类、DataSet类</li><li>在接下来的讲解中我们将以连接SQL Server为例介绍ADO.NET中的对象，引用的命名空间为System.Data.SqlClient</li><li>除了DataSet类以外，其他兑现的前面都加上Sql，即SqlConnection、SqlCommand、SqlDataReader、SqlDataAdapter</li></ul><h3 id="3-2-常用类介绍"><a href="#3-2-常用类介绍" class="headerlink" title="3.2  常用类介绍"></a>3.2  常用类介绍</h3><h4 id="3-2-1-Connection类"><a href="#3-2-1-Connection类" class="headerlink" title="3.2.1 Connection类"></a>3.2.1 Connection类</h4><ul><li>该类主要用于数据库中建议连接和断开连接的操作，并且能通过该类取当前数据库连接的状态</li><li>使用Connection类根据数据库的链接串能连接任意数据库，例如SQLServer、Oracle、MySQL等</li><li>但是在.NET平台下，由于提供了一个SQL Server数据库，并额外提供了一些操作菜单便于操作 ，所以推荐使用SQL Server数据库</li></ul><h4 id="3-2-2-Command类"><a href="#3-2-2-Command类" class="headerlink" title="3.2.2 Command类"></a>3.2.2 Command类</h4><ul><li>该类主要对数据库执行增加、删除、修改以及查询的操作</li><li>通过在Command类的对象中传入不同的SQL语句，并调用相应的方法来执行SQL语句</li></ul><h4 id="3-2-3-DataReader类"><a href="#3-2-3-DataReader类" class="headerlink" title="3.2.3 DataReader类"></a>3.2.3 DataReader类</h4><ul><li>该类用于读取从数据库中查询出来的数据，但在读取数据时能向前读不能向后读，并且不能修改该类对象中的值</li><li>在与数据库的链接中断时，该类对象中的值也随之被清除</li></ul><h4 id="3-2-4-DataAdapter类"><a href="#3-2-4-DataAdapter类" class="headerlink" title="3.2.4 DataAdapter类"></a>3.2.4 DataAdapter类</h4><ul><li>该类与DataSet联用，它主要用于将数据库的结果运送到DataSet中保存</li><li>DataAdapter可以看做是数控与DataSet的一个桥梁，不仅可以将数据库中的操作结果运送到DataSet中，也能将更改后的DataSet保存到数据库中</li></ul><h4 id="3-2-5-DataSet类"><a href="#3-2-5-DataSet类" class="headerlink" title="3.2.5 DataSet类"></a>3.2.5 DataSet类</h4><ul><li>该类与DataReader类似，都用于存放对数据库查询的结果</li><li>不同的是，DataSet类中的值不仅可以重复多次读取，还可以通过更改DataSet中的值更改数据库中的值</li><li>此外，DataSet类中的值在数据库断开连接的情况下依然可以保留原来的值</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中ADO.NET是在ADO的基础上发展起来的，ADO(Active Data Object)是一个COM组件类库，用于访问数据库，而ADO.NET是在.NET平台上访问数据库的组件。&lt;/li&gt;
&lt;li&gt;ADO.NET是以ODBC(Open Database Connectivity)技术的方式来访问数据库的一种技术&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——JavaScript heap out of memory</title>
    <link href="http://pgzxc.github.io/posts/3df1bea.html"/>
    <id>http://pgzxc.github.io/posts/3df1bea.html</id>
    <published>2020-08-06T13:34:42.000Z</published>
    <updated>2020-08-06T13:37:45.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>最近在写博客时，编译时经常出现错误，出现的错误提示信息为<code>JavaScript head out of memory</code>，刚开始认为是缓存过大引起的(博客占用空间已超过4G)，使用<code>hexo clean</code>指令和清除git缓存文件，问题依然存在</p><a id="more"></a><h2 id="二-现象"><a href="#二-现象" class="headerlink" title="二 现象"></a>二 现象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory</span><br><span class="line"> 1: 000000013FE1F04A v8::internal::GCIdleTimeHandler::GCIdleTimeHandler+5114</span><br><span class="line"> 2: 000000013FDFA0C6 node::MakeCallback+4518</span><br><span class="line"> 3: 000000013FDFAA30 node_module_register+2032</span><br><span class="line"> 4: 00000001400820EE v8::internal::FatalProcessOutOfMemory+846</span><br><span class="line"> 5: 000000014008201F v8::internal::FatalProcessOutOfMemory+639</span><br><span class="line"> 6: 00000001405A2BC4 v8::internal::Heap::MaxHeapGrowingFactor+9556</span><br><span class="line"> 7: 0000000140599C46 v8::internal::ScavengeJob::operator&#x3D;+24310</span><br><span class="line"> 8: 000000014059829C v8::internal::ScavengeJob::operator&#x3D;+17740</span><br><span class="line"> 9: 00000001405A0F87 v8::internal::Heap::MaxHeapGrowingFactor+2327</span><br><span class="line">10: 00000001405A1006 v8::internal::Heap::MaxHeapGrowingFactor+2454</span><br><span class="line">11: 000000014015CDB7 v8::internal::Factory::NewFillerObject+55</span><br><span class="line">12: 00000001401F2CC6 v8::internal::WasmJs::Install+29414</span><br><span class="line">13: 000001BEAF5DC5C1</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-error-heap-outof-memory.png" alt=""></p><h2 id="三-解决办法"><a href="#三-解决办法" class="headerlink" title="三 解决办法"></a>三 解决办法</h2><p> 在package.json文件的scripts中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;node --max_old_space_size&#x3D;4096 build&#x2F;dev-server.js&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;node --max_old_space_size&#x3D;4096 build&#x2F;build.js&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.pgzxc.com/hexo-script-space-size.png" alt=""></p><h2 id="四-结果"><a href="#四-结果" class="headerlink" title="四 结果"></a>四 结果</h2><p>执行<code>hexo g</code>编译项目，没有出现上述错误，执行<code>hexo s</code>运行项目，查看项目运行结果</p><p><img src="https://images.pgzxc.com/hexo-error-hexo-s.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;最近在写博客时，编译时经常出现错误，出现的错误提示信息为&lt;code&gt;JavaScript head out of memory&lt;/code&gt;，刚开始认为是缓存过大引起的(博客占用空间已超过4G)，使用&lt;code&gt;hexo clean&lt;/code&gt;指令和清除git缓存文件，问题依然存在&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Mutex(14.8)</title>
    <link href="http://pgzxc.github.io/posts/4999b511.html"/>
    <id>http://pgzxc.github.io/posts/4999b511.html</id>
    <published>2020-08-05T21:59:56.000Z</published>
    <updated>2020-08-05T22:00:50.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>C#中Mutex类也是用于线程同步操作的类，例如，当多个线程同时访问一个资源时保证一次只能有一个线程访问资源</li><li>在Mutex类中，WaitOne()方法用于等待资源被释放，ReleaseMutex()方法用于释放资源</li><li>WaitOne()方法在等待ReleaseMutex()方法执行结束后才会结束</li></ul><a id="more"></a><h2 id="二-实例-使用线程互斥实现每个车位每次只能停一辆车的功能"><a href="#二-实例-使用线程互斥实现每个车位每次只能停一辆车的功能" class="headerlink" title="二 实例    使用线程互斥实现每个车位每次只能停一辆车的功能 "></a>二 实例   <font size=5> 使用线程互斥实现每个车位每次只能停一辆车的功能 </font></h2><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a>2.1 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    private static Mutex mutex &#x3D; new Mutex();</span><br><span class="line">    public static void PakingSpace(object num)</span><br><span class="line">    &#123;</span><br><span class="line">        if (mutex.WaitOne())</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;车牌号&#123;0&#125;的车驶入！&quot;, num);</span><br><span class="line">                Thread.Sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;车牌号&#123;0&#125;的车离开！&quot;, num);</span><br><span class="line">                mutex.ReleaseMutex();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ParameterizedThreadStart ts &#x3D; new ParameterizedThreadStart(PakingSpace);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts);</span><br><span class="line">        t1.Start(&quot;冀A12345&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts);</span><br><span class="line">        t2.Start(&quot;京A00000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-结果"><a href="#2-2-结果" class="headerlink" title="2.2 结果"></a>2.2 结果</h3><p><img src="https://images.pgzxc.com/csharp-thread-mutex-console.png" alt=""></p><h3 id="2-3-说明"><a href="#2-3-说明" class="headerlink" title="2.3 说明"></a>2.3 说明</h3><p> 从上面的运行效果可以看出，每辆车驶入并离开后其他车才能占用停车位，即当一个线程占用资源时，其他线程是不使用该资源的 </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;C#中Mutex类也是用于线程同步操作的类，例如，当多个线程同时访问一个资源时保证一次只能有一个线程访问资源&lt;/li&gt;
&lt;li&gt;在Mutex类中，WaitOne()方法用于等待资源被释放，ReleaseMutex()方法用于释放资源&lt;/li&gt;
&lt;li&gt;WaitOne()方法在等待ReleaseMutex()方法执行结束后才会结束&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Monitor(14.7)</title>
    <link href="http://pgzxc.github.io/posts/a24642fb.html"/>
    <id>http://pgzxc.github.io/posts/a24642fb.html</id>
    <published>2020-08-05T21:58:16.000Z</published>
    <updated>2020-08-05T22:00:50.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在C#中Monitor类的命名空间是System.Threading，它的用法比lock的用法要复杂一些，但本质是一样的</p><a id="more"></a><h2 id="二-语法形式"><a href="#二-语法形式" class="headerlink" title="二 语法形式"></a>二 语法形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Monitor.Enter(object);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;临界区代码</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Exit(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这里，object的值与lock的值是一样的</li><li>简而言之，lock的写法是Monitor的一种简写</li></ul><h2 id="三-实例-将上一节C-lock实例中的-lock-关键字替换成-Monitor-类"><a href="#三-实例-将上一节C-lock实例中的-lock-关键字替换成-Monitor-类" class="headerlink" title="三  实例  将上一节C# lock实例中的 lock 关键字替换成 Monitor 类 "></a>三  实例 <font size=4> 将上一节C# lock实例中的 lock 关键字替换成 Monitor 类 </font></h2><h3 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        Monitor.Enter(this);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            Monitor.Exit(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void PrintOdd()</span><br><span class="line">    &#123;</span><br><span class="line">        Monitor.Enter(this);</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 1; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            Monitor.Exit(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Program program &#x3D; new Program();</span><br><span class="line">        ThreadStart ts1 &#x3D; new ThreadStart(program.PrintOdd);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts1);</span><br><span class="line">        t1.Name &#x3D; &quot;打印奇数的线程&quot;;</span><br><span class="line">        t1.Start();</span><br><span class="line">        ThreadStart ts2 &#x3D; new ThreadStart(program.PrintEven);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts2);</span><br><span class="line">        t2.Name &#x3D; &quot;打印偶数的线程&quot;;</span><br><span class="line">        t2.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-效果"><a href="#3-2-效果" class="headerlink" title="3.2 效果"></a>3.2 效果</h3><p><img src="https://images.pgzxc.com/csharp-thread-monitor-console.png" alt=""></p><h3 id="3-3-说明"><a href="#3-3-说明" class="headerlink" title="3.3 说明"></a>3.3 说明</h3><ul><li><p>Monitor类的用法虽然比lock关键字复杂，但其能添加等待获得锁定的超时值，这样就不会无限期等待获得对象锁</p></li><li><p>使用TryEnter()方法可以给它传送一个超时值，决定等待获得对象锁的最常时间</p></li><li><p>使用TryEnter()方法设置获得对象锁的时间的代码如下， 该方法能在指定的毫秒数内结束线程，这样能避免线程之间的死锁现象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Monitor.TryEnter(object, 毫秒数 );</span><br></pre></td></tr></table></figure></li><li><p>此外，还能使用 Monitor 类中的 Wait() 方法让线程等待一定的时间，使用 Pulse() 方法通知处于等待状态的线程 </p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;在C#中Monitor类的命名空间是System.Threading，它的用法比lock的用法要复杂一些，但本质是一样的&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——lock(14.6)</title>
    <link href="http://pgzxc.github.io/posts/ef125cbc.html"/>
    <id>http://pgzxc.github.io/posts/ef125cbc.html</id>
    <published>2020-08-05T21:56:30.000Z</published>
    <updated>2020-08-05T22:00:50.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>虽然Sleep方法能控制线程的暂停时间，从而改变多个线程之间的先后顺序，但每次调用线程的结果是随机的</li><li>线程同步的方法是将线程资源共享，允许控制每次执行一个线程，并交替执行每个线程</li><li>在C#语言中实现线程同步可以使用lock关键字和Monitor类、Mutex类来解决</li><li>对于线程同步操作最简单的一种方式就是使用lock关键字，通过lock关键字能保证加锁的线程只有在执行完成后才能执行其他线程</li></ul><a id="more"></a><h2 id="二-lock语法形式"><a href="#二-lock语法形式" class="headerlink" title="二 lock语法形式"></a>二 lock语法形式</h2><h3 id="2-1-语法形式"><a href="#2-1-语法形式" class="headerlink" title="2.1 语法形式"></a>2.1 语法形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock(object)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;临界区代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-说明"><a href="#2-2-说明" class="headerlink" title="2.2 说明"></a>2.2 说明</h3><ul><li><p>这里lock后面通常是一个Object类型的值，也可以使用this关键字来表示</p></li><li><p>最好是在lock中使用私有的非静态或负变量或私有的静态成员变量，即使用private或private static修饰的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Object obj &#x3D; new Object();</span><br><span class="line">lock (obj)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;临界区代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-实例-创建控制台应用程序，使用-lock-关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程"><a href="#三-实例-创建控制台应用程序，使用-lock-关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程" class="headerlink" title="三 实例  创建控制台应用程序，使用 lock 关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程 "></a>三 实例 <font size=5> 创建控制台应用程序，使用 lock 关键字控制打印奇数和偶数的线程，要求先执行奇数线程，再执行偶数线程 </font></h2><h3 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        lock (this)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void PrintOdd()</span><br><span class="line">    &#123;</span><br><span class="line">        lock (this)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 1; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Thread.CurrentThread.Name + &quot;--&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Program program &#x3D; new Program();</span><br><span class="line">        ThreadStart ts1 &#x3D; new ThreadStart(program.PrintOdd);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts1);</span><br><span class="line">        t1.Name &#x3D; &quot;打印奇数的线程&quot;;</span><br><span class="line">        t1.Start();</span><br><span class="line">        ThreadStart ts2 &#x3D; new ThreadStart(program.PrintEven);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts2);</span><br><span class="line">        t2.Name &#x3D; &quot;打印偶数的线程&quot;;</span><br><span class="line">        t2.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-效果"><a href="#3-2-效果" class="headerlink" title="3.2 效果"></a>3.2 效果</h3><p><img src="https://images.pgzxc.com/csharp-thread-print-lock.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虽然Sleep方法能控制线程的暂停时间，从而改变多个线程之间的先后顺序，但每次调用线程的结果是随机的&lt;/li&gt;
&lt;li&gt;线程同步的方法是将线程资源共享，允许控制每次执行一个线程，并交替执行每个线程&lt;/li&gt;
&lt;li&gt;在C#语言中实现线程同步可以使用lock关键字和Monitor类、Mutex类来解决&lt;/li&gt;
&lt;li&gt;对于线程同步操作最简单的一种方式就是使用lock关键字，通过lock关键字能保证加锁的线程只有在执行完成后才能执行其他线程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——ParameterizedThreadStart(14.4)</title>
    <link href="http://pgzxc.github.io/posts/ffc97c6c.html"/>
    <id>http://pgzxc.github.io/posts/ffc97c6c.html</id>
    <published>2020-08-05T21:54:59.000Z</published>
    <updated>2020-08-05T22:00:50.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在C#语言中使用ParameterizedThreadStart创建进程，首先需要创建ParameterizedThreadStart委托的实例，然后再创建Thread类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParameterizedThreadStart pts&#x3D;new ParameterizedThreadStart( 方法名 );</span><br><span class="line">Thread t&#x3D;new Thread(pts);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二-实例"><a href="#二-实例" class="headerlink" title="二 实例"></a>二 实例</h2><h3 id="2-1-实例一-创建一个方法输出0〜n的所有偶数，使用-ParameterizedThreadStart-委托调用该方法，并启动打印偶数的线程"><a href="#2-1-实例一-创建一个方法输出0〜n的所有偶数，使用-ParameterizedThreadStart-委托调用该方法，并启动打印偶数的线程" class="headerlink" title="2.1 实例一  创建一个方法输出0〜n的所有偶数，使用 ParameterizedThreadStart 委托调用该方法，并启动打印偶数的线程 "></a>2.1 实例一 <font size=5> 创建一个方法输出0〜n的所有偶数，使用 ParameterizedThreadStart 委托调用该方法，并启动打印偶数的线程 </font></h3><h4 id="2-1-1-代码"><a href="#2-1-1-代码" class="headerlink" title="2.1.1 代码"></a>2.1.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ParameterizedThreadStart pts &#x3D; new ParameterizedThreadStart(PrintEven);</span><br><span class="line">        Thread t &#x3D; new Thread(pts);</span><br><span class="line">        t.Start(10);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;打印0~n中的偶数</span><br><span class="line">    private static void PrintEven(Object n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;&#x3D;(int)n; i &#x3D; i + 2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-效果图"><a href="#2-1-2-效果图" class="headerlink" title="2.1.2 效果图"></a>2.1.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-parameterized-threadstart-even.png" alt=""></p><h4 id="2-1-3-说明"><a href="#2-1-3-说明" class="headerlink" title="2.1.3 说明"></a>2.1.3 说明</h4><ul><li>在使用ParameterizedThreadStart委托调用带参数的方法时，方法中的参数只能是object类型并且只能含有一个参数</li><li>在启动线程时要在线程的Start()方法中为委托的方法传递参数</li><li>如果需要通过ParameterizedThreadStart委托引用多个参数的方法，由于委托方法中的参数是object类型的，传递多个参数可以通过类的实例来实现</li></ul><h3 id="2-2-实例二-创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法"><a href="#2-2-实例二-创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法" class="headerlink" title="2.2 实例二  创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法 "></a>2.2 实例二 <font size=4> 创建一个方法输出指定范围内数值的偶数，并创建线程调用该方法 </font></h3><h4 id="2-2-1-代码"><a href="#2-2-1-代码" class="headerlink" title="2.2.1 代码"></a>2.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ParameterizedThreadStart pts &#x3D; new ParameterizedThreadStart(PrintEven);</span><br><span class="line">        ParameterTest pt &#x3D; new ParameterTest(1, 10);</span><br><span class="line">        Thread t &#x3D; new Thread(pts);</span><br><span class="line">        t.Start(pt);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void PrintEven(Object n)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;判断n是否为ParameterTest 类的对象</span><br><span class="line">        if(n is ParameterTest)</span><br><span class="line">        &#123;</span><br><span class="line">            int beginNum &#x3D; ((ParameterTest)n).beginNum;</span><br><span class="line">            int endNum &#x3D; ((ParameterTest)n).endNum;</span><br><span class="line">            for(int i &#x3D; beginNum; i &lt;&#x3D; endNum; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (i % 2 &#x3D;&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ParameterTest</span><br><span class="line">&#123;</span><br><span class="line">    public int beginNum;</span><br><span class="line">    public int endNum;</span><br><span class="line">    public ParameterTest(int a,int b)</span><br><span class="line">    &#123;</span><br><span class="line">        this.beginNum &#x3D; a;</span><br><span class="line">        this.endNum &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-效果图"><a href="#2-2-2-效果图" class="headerlink" title="2.2.2 效果图"></a>2.2.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-parameterized-threadstart-more-param.png" alt=""></p><h4 id="2-2-3-说明"><a href="#2-2-3-说明" class="headerlink" title="2.2.3 说明"></a>2.2.3 说明</h4><ul><li>运行该程序，在控制台上将输出 1〜10 的偶数，即2、4、6、8、10 </li><li>从代码可以看出，通过为 ParameterTest 类中的字段赋值，并将其通过线程的 Start 方法传递给委托引用的方法 PrintEven，即可实现在委托引用的方法中传递多个参数的操作 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;在C#语言中使用ParameterizedThreadStart创建进程，首先需要创建ParameterizedThreadStart委托的实例，然后再创建Thread类的实例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ParameterizedThreadStart pts&amp;#x3D;new ParameterizedThreadStart( 方法名 );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Thread t&amp;#x3D;new Thread(pts);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——ThreadStart(14.3)</title>
    <link href="http://pgzxc.github.io/posts/426c51be.html"/>
    <id>http://pgzxc.github.io/posts/426c51be.html</id>
    <published>2020-08-05T21:53:05.000Z</published>
    <updated>2020-08-05T22:00:50.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中使用线程时首先要创建线程，在使用Thread类的构造方法创建其实例时，需要用到ThreadStart委托或者ParameterizedThreadStart委托创建Thread类的实例</li><li>ThreadStart委托只能用于无返回值、无参数的方法，ParameterizedThreadStart委托则可以用于带参数的方法</li></ul><a id="more"></a><h2 id="二-创建过程"><a href="#二-创建过程" class="headerlink" title="二 创建过程"></a>二 创建过程</h2><p>使用ThreadStart创建线程首先需要创建ThreadStart委托的实例，然后再创建Thread类的实例。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadStart ts &#x3D; new ThreadStart( 方法名 );</span><br><span class="line">Thread t &#x3D; new Thread(ts);</span><br></pre></td></tr></table></figure><h2 id="三-实例"><a href="#三-实例" class="headerlink" title="三 实例"></a>三 实例</h2><h3 id="3-1-实例一-使用-ThreadStart-委托创建线程，并定义一个方法输出-0〜10-中所有的偶数"><a href="#3-1-实例一-使用-ThreadStart-委托创建线程，并定义一个方法输出-0〜10-中所有的偶数" class="headerlink" title="3.1 实例一  使用 ThreadStart 委托创建线程，并定义一个方法输出 0〜10 中所有的偶数 "></a>3.1 实例一 <font size=4> 使用 ThreadStart 委托创建线程，并定义一个方法输出 0〜10 中所有的偶数 </font></h3><h4 id="3-1-1-代码"><a href="#3-1-1-代码" class="headerlink" title="3.1.1 代码"></a>3.1.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadStart ts &#x3D; new ThreadStart(PrintEven);</span><br><span class="line">        Thread t &#x3D; new Thread(ts);</span><br><span class="line">        t.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义打印0~10中的偶数的方法</span><br><span class="line">    private static void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 10; i&#x3D;i+2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-效果"><a href="#3-1-2-效果" class="headerlink" title="3.1.2 效果"></a>3.1.2 效果</h4><p><img src="https://images.pgzxc.com/csharp-thread-start-evenum.png" alt=""></p><h4 id="3-1-3-说明"><a href="#3-1-3-说明" class="headerlink" title="3.1.3 说明"></a>3.1.3 说明</h4><p>从上面的运行效果可以看出，使用ThreadStart委托为PrintEvent方法创建了线程，通过线程的Start方法启动线程并调用了PrintEvent方法</p><h3 id="3-2-实例二-在上一实例的基础上添加一个打印-1〜10-中的奇数的方法，再分别使用两个-Thread-类的实例启动打印奇数和偶数的方法"><a href="#3-2-实例二-在上一实例的基础上添加一个打印-1〜10-中的奇数的方法，再分别使用两个-Thread-类的实例启动打印奇数和偶数的方法" class="headerlink" title="3.2 实例二  在上一实例的基础上添加一个打印 1〜10 中的奇数的方法，再分别使用两个 Thread 类的实例启动打印奇数和偶数的方法 "></a>3.2 实例二 <font size=5> 在上一实例的基础上添加一个打印 1〜10 中的奇数的方法，再分别使用两个 Thread 类的实例启动打印奇数和偶数的方法 </font></h3><h4 id="3-2-1-代码"><a href="#3-2-1-代码" class="headerlink" title="3.2.1 代码"></a>3.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadStart ts1 &#x3D; new ThreadStart(PrintEven);</span><br><span class="line">        Thread t1 &#x3D; new Thread(ts1);</span><br><span class="line">        ThreadStart ts2 &#x3D; new ThreadStart(PrintOdd);</span><br><span class="line">        Thread t2 &#x3D; new Thread(ts2);</span><br><span class="line">        t1.Start();</span><br><span class="line">        t2.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义打印0~10中的偶数的方法</span><br><span class="line">    private static void PrintEven()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; 10; i&#x3D;i+2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义打印1~10 中的奇数的方法</span><br><span class="line">    public static void PrintOdd()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; 10; i &#x3D; i + 2)</span><br><span class="line">        &#123;</span><br><span class="line">           Console.Write(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-效果"><a href="#3-2-2-效果" class="headerlink" title="3.2.2 效果"></a>3.2.2 效果</h4><p><img src="https://images.pgzxc.com/csharp-thread-print-eveandodd.png" alt=""></p><h4 id="3-2-3-说明"><a href="#3-2-3-说明" class="headerlink" title="3.2.3 说明"></a>3.2.3 说明</h4><ul><li>从上面的运行效果可以看出，两个线程分别打印了 1〜10 中的奇数和 0〜10 中的偶数，但并不是按照线程的调用顺序先打印出所有的偶数再打印奇数 </li><li>需要注意的是，由于没有对线程的执行顺序和操作做控制，所以运行该程序每次打印的值的顺序是不一样的 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中使用线程时首先要创建线程，在使用Thread类的构造方法创建其实例时，需要用到ThreadStart委托或者ParameterizedThreadStart委托创建Thread类的实例&lt;/li&gt;
&lt;li&gt;ThreadStart委托只能用于无返回值、无参数的方法，ParameterizedThreadStart委托则可以用于带参数的方法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Thread(14.2)</title>
    <link href="http://pgzxc.github.io/posts/81dbaacd.html"/>
    <id>http://pgzxc.github.io/posts/81dbaacd.html</id>
    <published>2020-08-05T21:51:44.000Z</published>
    <updated>2020-08-05T22:00:50.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中线程(Thread)是包含在进程中的，它位于System.Threading命名空间中</li><li>与线程有关的类同样也都在System.Threading命名空间中</li></ul><a id="more"></a><h2 id="二-主要的类"><a href="#二-主要的类" class="headerlink" title="二 主要的类"></a>二 主要的类</h2><table><thead><tr><th align="center">类名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Thread</td><td align="center">在初始的应用程序中创建其他的线程</td></tr><tr><td align="center">ThreadState</td><td align="center">指定Thread的执行状态，包括开始、运行、挂起等</td></tr><tr><td align="center">ThreadPrioity</td><td align="center">线程在调度时的优先级枚举值，包括Highest、AboveNormal、BelowNormal、Lowest</td></tr><tr><td align="center">ThreadPool</td><td align="center">提供一个线程池，用于执行任务、发送工作项、处理异步I/O等操作</td></tr><tr><td align="center">Monitor</td><td align="center">提供同步访问对象的机制</td></tr><tr><td align="center">Mutex</td><td align="center">用于线程间同步的操作</td></tr><tr><td align="center">ThreadAbortException</td><td align="center">调用Thread类中的Abort方法时出现的异常</td></tr><tr><td align="center">ThreadStateException</td><td align="center">Thread处于对方法调用无效的ThreadState时出现的异常</td></tr></tbody></table><h2 id="三-属性和方法"><a href="#三-属性和方法" class="headerlink" title="三 属性和方法"></a>三 属性和方法</h2><table><thead><tr><th align="center"><strong>属性或方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">Name</td><td align="center">属性，获取或设置线程的名称</td></tr><tr><td align="center">Priority</td><td align="center">属性，获取或设置线程的优先级</td></tr><tr><td align="center">ThreadState</td><td align="center">属性，获取线程当前的状态</td></tr><tr><td align="center">IsAlive</td><td align="center">属性，获取当前线程是否处于启动状态</td></tr><tr><td align="center">IsBackground</td><td align="center">属性，获取或设置值，表示该线程是否为后台线程</td></tr><tr><td align="center">CurrentThread</td><td align="center">属性，获取当前正在运行的线程</td></tr><tr><td align="center">Start()</td><td align="center">方法，启动线程</td></tr><tr><td align="center">Sleep(int millisecondsTImeout)</td><td align="center">方法，将当前线程暂停指定的毫秒数</td></tr><tr><td align="center">Suspend()</td><td align="center">方法，挂起当前线程(已经被弃用)</td></tr><tr><td align="center">Join()</td><td align="center">方法，阻塞调用线程，直到某个线程终止为止</td></tr><tr><td align="center">Interrupt()</td><td align="center">方法，中断当前线程</td></tr><tr><td align="center">Resume()</td><td align="center">方法，继续已经挂起的线程(已经被弃用)</td></tr><tr><td align="center">Abort()</td><td align="center">方法，终止线程</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中线程(Thread)是包含在进程中的，它位于System.Threading命名空间中&lt;/li&gt;
&lt;li&gt;与线程有关的类同样也都在System.Threading命名空间中&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Process(14.1)</title>
    <link href="http://pgzxc.github.io/posts/75f4f920.html"/>
    <id>http://pgzxc.github.io/posts/75f4f920.html</id>
    <published>2020-08-05T21:49:45.000Z</published>
    <updated>2020-08-05T22:00:50.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中进程类是指Process类，该类所在的命名空间是System.Diagnostics</li><li>Process类主要提供对本地和远程进程的访问，并提供对本地进程的启动、停止等操作</li></ul><a id="more"></a><h2 id="二-常用属性和方法"><a href="#二-常用属性和方法" class="headerlink" title="二 常用属性和方法"></a>二 常用属性和方法</h2><table><thead><tr><th align="center">属性或方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">MachineName</td><td align="center">属性，获取关联进程正在其上运行的计算机的名称</td></tr><tr><td align="center">Id</td><td align="center">属性，获取关联进程的唯一标识符</td></tr><tr><td align="center">ExitTime</td><td align="center">属性，获取该进程退出的时间</td></tr><tr><td align="center">ProcessName</td><td align="center">属性，获取该进程的名称</td></tr><tr><td align="center">StartTime</td><td align="center">属性，获取关联进程启动的时间</td></tr><tr><td align="center">Threads</td><td align="center">属性，获取在关联进程中运行的一组线程</td></tr><tr><td align="center">TotalProcessorTime</td><td align="center">属性，获取此进程的总的处理器时间</td></tr><tr><td align="center">UserProcessorTime</td><td align="center">属性，获取此进程的用户处理器时间</td></tr><tr><td align="center">Close()</td><td align="center">方法，释放与此组件关联的所有资源</td></tr><tr><td align="center">CloseMainWindow()</td><td align="center">方法，通过向进程的主窗口发送关闭消息来关闭拥有用户界面的进程</td></tr><tr><td align="center">Dispose()</td><td align="center">方法，释放由Component使用的所有资源</td></tr><tr><td align="center">GetCurrentProcess()</td><td align="center">方法，获取新的Process组件，并将其与当前活动的进程关联</td></tr><tr><td align="center">GetProcess()</td><td align="center">方法，为本地计算机上的每个进程创建一个新的Process组件</td></tr><tr><td align="center">GetProcess(String)</td><td align="center">方法，为指定计算机上的每个进程资源创建一个新的Process组件</td></tr><tr><td align="center">GetProcessesByName(String)</td><td align="center">方法，创建新的Process组件的数组，并将它们与本地计算机上 共享指定的进程名称的所有进程资源关联</td></tr><tr><td align="center">Kill()</td><td align="center">方法，立即停止关联的进程</td></tr><tr><td align="center">Start()</td><td align="center">方法，启动(或重用)此Process组件的Startinfo属性指定的进程资源，并将其余该组件关联</td></tr><tr><td align="center">Start(String)</td><td align="center">方法，通过指定文档或应用程序文件的名称来启动进程资源，并将资源与新的Process组件关联</td></tr></tbody></table><h2 id="三-操作进程"><a href="#三-操作进程" class="headerlink" title="三 操作进程"></a>三 操作进程</h2><ul><li>在实际应用中经常会用到获取本地的进程、启动进程、关闭进程等操作，下面分别以实际形式介绍其具体的操作方法</li><li>在获取当前操作系统中运行的进程时，如果要获取所有运行的进程的信息，可以使用表中的GetProcess()方法，如果要获取指定名称的进程可以使用GetProcessByName(String)方法</li></ul><h2 id="四-实例"><a href="#四-实例" class="headerlink" title="四 实例"></a>四 实例</h2><h3 id="4-1-实例一-创建-Windows-应用程序，在-RichTextBox-控件中显示所有当前系统中正在运行的进程"><a href="#4-1-实例一-创建-Windows-应用程序，在-RichTextBox-控件中显示所有当前系统中正在运行的进程" class="headerlink" title="4.1 实例一  创建 Windows 应用程序，在 RichTextBox 控件中显示所有当前系统中正在运行的进程 "></a>4.1 实例一 <font size=4> 创建 Windows 应用程序，在 RichTextBox 控件中显示所有当前系统中正在运行的进程 </font></h3><h4 id="4-1-1-代码"><a href="#4-1-1-代码" class="headerlink" title="4.1.1 代码"></a>4.1.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public partial class GetProcessesForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public GetProcessesForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;“查看所有进程”按钮的单击事件</span><br><span class="line">    private void btnOk_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Process[] processes &#x3D; Process.GetProcesses();</span><br><span class="line">        foreach(Process p in processes)</span><br><span class="line">        &#123;</span><br><span class="line">            richTextBox1.Text &#x3D; richTextBox1.Text + p.ProcessName + &quot;\r\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-效果"><a href="#4-1-2-效果" class="headerlink" title="4.1.2 效果"></a>4.1.2 效果</h4><p><img src="https://images.pgzxc.com/csharp-process-all-process.png" alt=""></p><h4 id="4-1-3-说明"><a href="#4-1-3-说明" class="headerlink" title="4.1.3 说明"></a>4.1.3 说明</h4><p>从上面的运行效果可以看出，已经将系统中运行的进程名称显示在RichTextBox中，由于在当前系统中运行的进程较多，所以需要滑动RichTextBox控件中的滚动条来查看， 我们可以观察当前任务管理器中的进程是否与下图中的进程相同 </p><h3 id="4-2-实例二-创建-Windows-应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程"><a href="#4-2-实例二-创建-Windows-应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程" class="headerlink" title="4.2 实例二  创建 Windows 应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程 "></a>4.2 实例二 <font size=5> 创建 Windows 应用程序，并在文本框中输入需要启动的进程名称，单击“启动进程”按钮启动该进程 </font></h3><h4 id="4-2-1-代码"><a href="#4-2-1-代码" class="headerlink" title="4.2.1 代码"></a>4.2.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public partial class ProcessForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public ProcessForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;“启动进程”按钮的单击事件</span><br><span class="line">    private void button1_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取进程名称</span><br><span class="line">        string ProcessName &#x3D; textBox1.Text;</span><br><span class="line">        &#x2F;&#x2F;创建Process 类的对象</span><br><span class="line">        Process p &#x3D; new Process();</span><br><span class="line">        &#x2F;&#x2F;设置进程名称</span><br><span class="line">        p.StartInfo.FileName &#x3D; ProcessName;</span><br><span class="line">        &#x2F;&#x2F;启动进程</span><br><span class="line">        p.Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-效果图"><a href="#4-2-2-效果图" class="headerlink" title="4.2.2 效果图"></a>4.2.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-process-start-process-mspaint.png" alt=""></p><h4 id="4-2-3-说明"><a href="#4-2-3-说明" class="headerlink" title="4.2.3 说明"></a>4.2.3 说明</h4><p> 从上面的运行效果可以看出，在文本框中输入“画图”的进程名称，单击“启动进程” 按钮即可显示出画图进程的界面 </p><h3 id="4-3-创建-Windows-应用程序，在-ListBox-控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭"><a href="#4-3-创建-Windows-应用程序，在-ListBox-控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭" class="headerlink" title="4.3  创建 Windows 应用程序，在 ListBox 控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭 "></a>4.3 <font size=4> 创建 Windows 应用程序，在 ListBox 控件中显示所有的进程名称，并右击选中的进程名称，通过弹出的右键菜单将其关闭 </font></h3><h4 id="4-3-1-代码"><a href="#4-3-1-代码" class="headerlink" title="4.3.1 代码"></a>4.3.1 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public partial class ListBoxForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public ListBoxForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;窗体加载事件</span><br><span class="line">    private void ListBoxForm_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取所有进程信息</span><br><span class="line">        Process[] processes &#x3D; Process.GetProcesses();</span><br><span class="line">        foreach(Process p in processes)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;将进程添加到ListBox中</span><br><span class="line">            lbProcess.Items.Add(p.ProcessName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&quot;停止进程&quot;命令的单击事件</span><br><span class="line">    private void 停止进程ToolStripMenuItem_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取进程名称</span><br><span class="line">        string ProcessName &#x3D; lbProcess.SelectedItem.ToString();</span><br><span class="line">        &#x2F;&#x2F;根据进程名称获取进程</span><br><span class="line">        Process[] processes &#x3D; Process.GetProcessesByName(ProcessName);</span><br><span class="line">        &#x2F;&#x2F;判断是否存在指定进程名称的进程</span><br><span class="line">        if (processes.Length &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                foreach(Process p in processes)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;判断进程是否处于运行状态</span><br><span class="line">                    if (!p.HasExited)</span><br><span class="line">                    &#123;</span><br><span class="line">                        &#x2F;&#x2F;关闭进程</span><br><span class="line">                        p.Kill();</span><br><span class="line">                        MessageBox.Show(p.ProcessName + &quot;已关闭！&quot;);</span><br><span class="line">                        &#x2F;&#x2F;获取所有进程信息</span><br><span class="line">                        processes &#x3D; Process.GetProcesses();</span><br><span class="line">                        &#x2F;&#x2F;清空ListBox中的项</span><br><span class="line">                        lbProcess.Items.Clear();</span><br><span class="line">                        foreach(Process p1 in processes)</span><br><span class="line">                        &#123;</span><br><span class="line">                            &#x2F;&#x2F;将进程添加到ListBox中</span><br><span class="line">                            lbProcess.Items.Add(p1.ProcessName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(&quot;该进程无法关闭！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-效果图"><a href="#4-3-2-效果图" class="headerlink" title="4.3.2 效果图"></a>4.3.2 效果图</h4><p><img src="https://images.pgzxc.com/csharp-process-kill-notepad.png" alt=""></p><h4 id="4-3-3-说明"><a href="#4-3-3-说明" class="headerlink" title="4.3.3 说明"></a>4.3.3 说明</h4><ul><li>运行该程序，则记事本程序被关闭 </li><li>需要注意的是，一些进程由于权限不够是无法关闭的，因此在关闭进程的代码中要做异常处理 </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中进程类是指Process类，该类所在的命名空间是System.Diagnostics&lt;/li&gt;
&lt;li&gt;Process类主要提供对本地和远程进程的访问，并提供对本地进程的启动、停止等操作&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——程序调试(13.5)</title>
    <link href="http://pgzxc.github.io/posts/28c6dd.html"/>
    <id>http://pgzxc.github.io/posts/28c6dd.html</id>
    <published>2020-08-03T12:49:42.000Z</published>
    <updated>2020-08-03T12:51:03.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p> 在 C#语言中程序调试主要指在 Visual Studio 2019 中调试程序，包括设置断点、监视断点，以及逐语句、逐过程、使用一些辅助窗口来调试程序 </p><a id="more"></a><h2 id="二-常用功能"><a href="#二-常用功能" class="headerlink" title="二 常用功能"></a>二 常用功能</h2><h3 id="2-1-设置断点"><a href="#2-1-设置断点" class="headerlink" title="2.1 设置断点"></a>2.1 设置断点</h3><h4 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1 概念"></a>2.1.1 概念</h4><ul><li>所谓断点是程序自动进入中断模式的标记，即当程序运行到此处时自动中断。</li><li>在断点所在行的前面用红色的圆圈标记，设置标记时直接用鼠标单击需要设置断点的行前面的灰色区域即可，或者直接按键盘上的 F9 键 </li></ul><h4 id="2-1-2-操作"><a href="#2-1-2-操作" class="headerlink" title="2.1.2 操作"></a>2.1.2 操作</h4><ul><li><p>例如在程序中设置断点，效果如下图 </p><p><img src="https://images.pgzxc.com/csharp-break-point-set.png" alt=""></p></li><li><p>在设置断点时单击齿轮图标进入断点设置界面，如下图所示( 在该界面中允许为断点设置条件或操作，条件是指在满足指定条件时才会命中该断点 )</p><p><img src="https://images.pgzxc.com/csharp-break-point-set-view.png" alt=""></p></li><li><p>此外，每个断点也允许设置多个条件，每个条件之间的关系是“与”的关系。界面如下图所示<br>在设置条件时可以设置条件表达式、命中次数以及筛选器 , 其中： </p><ul><li>条件表达式是指一个布尔类型的表达式，如果满足条件则触发断点 </li><li>命中次数若满足指定次数，则触发断点 </li><li>筛选器用于限制只在某些进程和线程中设置断点 </li></ul><p><img src="https://images.pgzxc.com/csharp-break-point-set-or-relate.png" alt=""></p></li><li><p>在上图所示的界面中还可以为断点设置操作，用于指定在命中断点时打印追踪信息，界面如下图所示</p><p><img src="https://images.pgzxc.com/csharp-break-point-view-track.png" alt=""></p></li><li><p>在该界面中，如果在“将消息记录到输出窗口”文本框中输出断点“string[] str = new string<a href="https://images.pgzxc.com/csharp-break-point-str-right-key.png">5</a>;”处，其中 str 的值，则可以写成“str={str}”的形式，在调试输出窗口中会发现“str=Null”的信息输出。此外，右击断点，弹出的右键菜单如下图所示</p><p><img src="https://images.pgzxc.com/csharp-break-point-str-right-key.png" alt=""></p></li><li><p>在该菜单中选择“条件”或“操作”命令也可以完成对断点的上述设置</p></li></ul><h3 id="2-2-管理断点"><a href="#2-2-管理断点" class="headerlink" title="2.2 管理断点"></a>2.2 管理断点</h3><p> 在断点设置完成后，还可以在上图所示的菜单中选择进行“删除断点”“禁用断点”“编辑标签”“导出”的操作 , 其中： </p><ul><li>“删除断点”操作是取消当前断点，也可以再次单击断点的红点取消 </li><li>禁用断点”操作是指暂时跳过该断点，将断点设置为禁用状态后，断点的右键菜单中的“禁用断点”选项更改为“启用断点”，在需要该断点时还可以选择“启用断点”恢复断点； </li><li>“编辑标签” 操作是为断点设置名称；</li><li>“导出”操作是将断点信息导出到一个 XML 文件中存放 </li></ul><h3 id="2-3-程序的调试过程"><a href="#2-3-程序的调试过程" class="headerlink" title="2.3 程序的调试过程"></a>2.3 程序的调试过程</h3><ul><li><p>在设置好断点后，调试程序可以直接按 F5 键，或者直接在菜单栏中选择“调试”→“开始调试”命令 </p></li><li><p>在调试程序的过程中，可以直接使用工具栏上的调试快捷键，如下图所示，或者直接在菜单栏中选择所需的调试命令 </p><p><img src="https://images.pgzxc.com/csharp-debug-f5-progress.png" alt=""></p></li><li><p>下面介绍常用的调试命令</p><ul><li>逐语句（<img src="http://c.biancheng.net/uploads/allimg/190403/4-1Z403101S5T9.gif" alt="逐语句">）：按 F11 键也可以，用于逐条语句运行 </li><li>逐过程（<img src="http://c.biancheng.net/uploads/allimg/190403/4-1Z403101ZK27.gif" alt="逐过程">）：按 F10 键也可以，过程是指可以将方法作为一个整体去执行，不会跳进方法中执行。</li><li>跳出（<img src="http://c.biancheng.net/uploads/allimg/190403/4-1Z403101944544.gif" alt="跳出">）：按 Shift+F11 组合键也可以，跳出是将程序的调试状态结束，并结束整个程序 </li></ul></li><li><p>此外，在调试过程中右击，会出现如下图所示的右键菜单</p><p><img src="https://images.pgzxc.com/csharp-debug-right-keyboard.png" alt=""></p><h3 id="2-4-监视器"><a href="#2-4-监视器" class="headerlink" title="2.4 监视器"></a>2.4 监视器</h3></li><li><p>在调试程序的过程中经常需要知道某些变量的值在运行过程发生的变化，以便发现其在何时发生错误 </p></li><li><p>将程序中的变量或某个表达式放入监视器中即可监视其变化状态 </p></li><li><p>假设将 for 循环中的循环变量 i 加入监视器，在程序中右击变量 i，在弹出的如上图所示的菜单中选择“添加监视”命令，效果如下图所示 </p><p><img src="https://images.pgzxc.com/csharp-debug-monitor-i.png" alt=""></p></li><li><p>从上图中可以看出，在监视器界面的“名称”列中是变量名、“值”列中是当前变量 i 的值，“类型”列中是当前变量的数据类型</p></li><li><p>在一个监视器中可以设置多个需要监视的变量或表达式</p></li><li><p>对于监视器中不需要再监视的变量，可以右击该变量，在弹出的右键菜单中选择“删除监视”命令，如下图所示</p><p><img src="https://images.pgzxc.com/csharp-debug-monitor-delete-monotor.png" alt=""></p><h3 id="2-5-快速监视"><a href="#2-5-快速监视" class="headerlink" title="2.5 快速监视"></a>2.5 快速监视</h3></li><li><p>在调试程序时，如果需要监视变量或表达式的值也可以使用快速监视 </p></li><li><p>例如仍然要监视变量 i 的值，右击变量 i，在弹出的右键菜单中选择“快速监视”命令，弹出如下图所示的对话框</p><p><img src="https://images.pgzxc.com/csharp-monitor-quiclly.png" alt=""> </p></li><li><p>通常，快速监视用于查看变量当前值的状态，与直接加入监视不同的是快速监视一次只能监视一个变量</p></li><li><p>此外，在“快速监视”对话框处于打开状态时程序是无法继续调试的，如果需要继续监视“快速监视”对话框中的变量，可以单击“添加监视”按钮将当前监视的变量加入到监视器界面中 </p></li></ul><h3 id="2-6-即时窗口"><a href="#2-6-即时窗口" class="headerlink" title="2.6 即时窗口"></a>2.6 即时窗口</h3><ul><li><p>在调试程序时，如果需要对变量或表达式做相关运算，在即时窗口中都可以实现，并显示当前状态下变量或表达式的值 </p></li><li><p>在调试时可以使用“调试”菜单中“窗口”下的命令，在“调试”菜单中单击“窗口”出现如下图所示的子菜单<br><img src="https://images.pgzxc.com/csharp-debug-im-windows-right.png" alt=""></p></li><li><p>在其中选择“即时”命令即可出现即时窗口， 如下图所<br><img src="https://images.pgzxc.com/csharp-debug-im-windows.png" alt=""></p></li><li><p>在即时窗口中输入变量 i 的值并按回车键，即出现当前 i 在程序运行到此时的值</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt; 在 C#语言中程序调试主要指在 Visual Studio 2019 中调试程序，包括设置断点、监视断点，以及逐语句、逐过程、使用一些辅助窗口来调试程序 &lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Debug和Trace(13.4)</title>
    <link href="http://pgzxc.github.io/posts/fe6e82a2.html"/>
    <id>http://pgzxc.github.io/posts/fe6e82a2.html</id>
    <published>2020-08-03T12:48:40.000Z</published>
    <updated>2020-08-03T12:51:03.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>在C#语言中允许在程序运行时输出程序的调试信息，类似于使用Console.WriteLine的方式向控制台输出信息</li><li>所谓调试信息是程序员在程序运行时需要获取的程序运行的过程，以便于程序员更好地解决程序中出现的问题，这种调试也被称为非中断调试</li></ul><a id="more"></a><h2 id="二-调试信息格式"><a href="#二-调试信息格式" class="headerlink" title="二 调试信息格式"></a>二 调试信息格式</h2><p>输出调试信息的类保存在System.Diagnostics命名空间中，通常用Debug类或Trace类实现调试时输出调试信息，具体的语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug.WriteLine();</span><br><span class="line">Trace.WriteLine();</span><br></pre></td></tr></table></figure><p>其中，Debug.WriteLine()是在调试模式下使用 ;Trace.WriteLine除了可以在调试模式下使用，还可以用于发布的程序中</p><h2 id="三-实例-创建一个字符串类型的数组，在数组中存入从控制台输入的值，并输出每次向数组中存入的值"><a href="#三-实例-创建一个字符串类型的数组，在数组中存入从控制台输入的值，并输出每次向数组中存入的值" class="headerlink" title="三 实例   创建一个字符串类型的数组，在数组中存入从控制台输入的值，并输出每次向数组中存入的值 "></a>三 实例  <font size=5> 创建一个字符串类型的数组，在数组中存入从控制台输入的值，并输出每次向数组中存入的值 </font></h2><h3 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3.1 代码"></a>3.1 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        string[] str &#x3D; new string[5];</span><br><span class="line">        Debug.WriteLine(&quot;开始向数组中存值：&quot;);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; str.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str[i] &#x3D; Console.ReadLine();</span><br><span class="line">            Debug.WriteLine(&quot;存入的第&#123;0&#125;个值为&#123;1&#125;&quot;, i, str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.WriteLine(&quot;向数组中存值结束！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Debug-类输出的信息-即时窗口"><a href="#3-2-Debug-类输出的信息-即时窗口" class="headerlink" title="3.2  Debug 类输出的信息(即时窗口)"></a>3.2  Debug 类输出的信息(即时窗口)</h3><p><img src="https://images.pgzxc.com/csharp-trace-debug-view.png" alt=""></p><h3 id="3-3-说明"><a href="#3-3-说明" class="headerlink" title="3.3 说明"></a>3.3 说明</h3><ul><li>从输出窗口的内容可以看出，通过Debug类所打印的内容全部显示在该窗口中</li><li>使用Trace类也能完成同样的效果，只需要将上述代码中的Debug类换成Trace类即可</li><li>提示：Trace 类的 WriteLine 方法中的参数不支持上述代码中 Debug 类的 WriteLine 方法的参数形式，只能传递字符串 </li><li>需要注意的是当程序在 Debug 状态下执行时使用 Debug 类打印的信息才会在输出窗口中显示，在 Release 状态下执行时只有 Trace 类输出的内容才会显示在输出窗口中 </li></ul><h2 id="四-切换Debug和Release"><a href="#四-切换Debug和Release" class="headerlink" title="四 切换Debug和Release"></a>四 切换Debug和Release</h2><p>默认情况下，visual studio 2019中的执行方式是Debug， 如果需要更改为其他状态, 可以在其下拉列表框中选择 Release 方式，并且在一个解决方案中不同的项目可以选择不同的执行方法 </p><p> 在上图中 Debug 处的下拉列表框中选择“配置管理器”选项，弹出如下图所示的对话框<br><img src="https://images.pgzxc.com/csharp-debug-trace-change.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在C#语言中允许在程序运行时输出程序的调试信息，类似于使用Console.WriteLine的方式向控制台输出信息&lt;/li&gt;
&lt;li&gt;所谓调试信息是程序员在程序运行时需要获取的程序运行的过程，以便于程序员更好地解决程序中出现的问题，这种调试也被称为非中断调试&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——自定义异常(13.3)</title>
    <link href="http://pgzxc.github.io/posts/5b9d0a70.html"/>
    <id>http://pgzxc.github.io/posts/5b9d0a70.html</id>
    <published>2020-08-03T12:47:34.000Z</published>
    <updated>2020-08-03T12:51:03.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>虽然在C#语言中已经提供了很多异常处理类，但在实际编程中还是会遇到未涉及的一些异常处理</li><li>例如想将数据的验证放置到异常处理中，即判断所输入的年龄必须为18~45，此时需要自定义异常类来实现</li></ul><a id="more"></a><h2 id="二-自定义异常"><a href="#二-自定义异常" class="headerlink" title="二 自定义异常"></a>二 自定义异常</h2><p> 自定义异常类必须要继承 Exception 类 </p><h3 id="2-1-声明异常的语句"><a href="#2-1-声明异常的语句" class="headerlink" title="2.1 声明异常的语句"></a>2.1 声明异常的语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 异常类名 :Exception</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-抛出自己的异常，语句"><a href="#2-2-抛出自己的异常，语句" class="headerlink" title="2.2  抛出自己的异常，语句"></a>2.2  抛出自己的异常，语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw( 异常类名 );</span><br></pre></td></tr></table></figure><h2 id="三-实例-自定义异常类，判断从文本框中输入的年龄值处于-18〜45"><a href="#三-实例-自定义异常类，判断从文本框中输入的年龄值处于-18〜45" class="headerlink" title="三 实例 自定义异常类，判断从文本框中输入的年龄值处于 18〜45 "></a>三 实例 <font size=5>自定义异常类，判断从文本框中输入的年龄值处于 18〜45 </font></h2><h3 id="3-1-自定义异常类"><a href="#3-1-自定义异常类" class="headerlink" title="3.1 自定义异常类"></a>3.1 自定义异常类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyException :Exception</span><br><span class="line">&#123;</span><br><span class="line">    public MyException(string message) : base(message)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-验证按钮"><a href="#3-2-验证按钮" class="headerlink" title="3.2 验证按钮"></a>3.2 验证按钮</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        int age &#x3D; int.Parse(textBox1.Text);</span><br><span class="line">        if (age &lt; 18 || age &gt; 45)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new MyException(&quot;年龄必须在18~45岁之间！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;输入的年龄正确！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(MyException myException)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(myException.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-效果图"><a href="#3-3-效果图" class="headerlink" title="3.3 效果图"></a>3.3 效果图</h3><p><img src="https://images.pgzxc.com/csharp-winform-define-exception-view.gif" alt=""></p><h3 id="3-4-说明"><a href="#3-4-说明" class="headerlink" title="3.4 说明"></a>3.4 说明</h3><ul><li>从运行效果可以看出，若在文本框中输入的年龄不在18~45岁即会抛出自定义的异常</li><li>自定义异常也继承自Exception类，因此如果不能直接处理MyException异常，也可以直接使用Exception来来处理该异常</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虽然在C#语言中已经提供了很多异常处理类，但在实际编程中还是会遇到未涉及的一些异常处理&lt;/li&gt;
&lt;li&gt;例如想将数据的验证放置到异常处理中，即判断所输入的年龄必须为18~45，此时需要自定义异常类来实现&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——异常处理(13.2)</title>
    <link href="http://pgzxc.github.io/posts/dfc501a2.html"/>
    <id>http://pgzxc.github.io/posts/dfc501a2.html</id>
    <published>2020-08-03T12:46:00.000Z</published>
    <updated>2020-08-03T12:51:03.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在C#语言中异常与异常处理语句包括三种形式，即try catch、try finally、try catch finally。在上述三种异常处理的形式中所用到的关键字其含义如下：</p><ul><li>try：用于检查发生的异常，并帮助发送任何可能的异常</li><li>catch：以控制权更大的方式处理错误，可以有多个catch子句</li><li>finally：无论是否引发了异常，finally的代码块都将被执行</li></ul><a id="more"></a><h2 id="二-三种异常形式"><a href="#二-三种异常形式" class="headerlink" title="二 三种异常形式"></a>二 三种异常形式</h2><h3 id="2-1-try-catch"><a href="#2-1-try-catch" class="headerlink" title="2.1  try catch"></a>2.1  try catch</h3><h4 id="2-1-1-说明"><a href="#2-1-1-说明" class="headerlink" title="2.1.1 说明"></a>2.1.1 说明</h4><ul><li>在try语句中放置可能出现异常的语句，而在catch语句中放置异常时处理异常的语句，通常在catch语句中输出异常信息或者发送邮件给开发人员等</li><li>下面通过实例来演示try catch的应用，另外，在处理异常时，catch语句是允许多次使用的，相当于多分支的if语句，仅能执行其中一个分支</li></ul><h4 id="2-1-2-实例一-在文本框中输入一个整数，并判断其是否大于100-根据题目要求，如果在文本框中输入的是一个字符串或者浮点数，就会出现类型转换错误"><a href="#2-1-2-实例一-在文本框中输入一个整数，并判断其是否大于100-根据题目要求，如果在文本框中输入的是一个字符串或者浮点数，就会出现类型转换错误" class="headerlink" title="2.1.2 实例一 在文本框中输入一个整数，并判断其是否大于100( 根据题目要求，如果在文本框中输入的是一个字符串或者浮点数，就会出现类型转换错误 )"></a>2.1.2 实例一 在文本框中输入一个整数，并判断其是否大于100( 根据题目要求，如果在文本框中输入的是一个字符串或者浮点数，就会出现类型转换错误 )</h4><h5 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h5><p><img src="https://images.pgzxc.com/csharp-exception-trycatch-layout.png" alt=""></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public partial class tryCatchForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public tryCatchForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;“确认”按钮单击事件</span><br><span class="line">    private void button1_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取文本框中的值</span><br><span class="line">        string str &#x3D; textBox1.Text;</span><br><span class="line">        &#x2F;&#x2F;将字符串装换为整数</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            int num &#x3D; int.Parse(str);</span><br><span class="line">            MessageBox.Show(&quot;您输入的数字是：&quot; + num);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="未加异常处理前"><a href="#未加异常处理前" class="headerlink" title="未加异常处理前"></a>未加异常处理前</h5><p><img src="https://images.pgzxc.com/csharp-exception-try-catch-not-do.png" alt=""></p><h5 id="异常处理后"><a href="#异常处理后" class="headerlink" title="异常处理后"></a>异常处理后</h5><p><img src="https://images.pgzxc.com/csharp-exception-trycatch-done.png" alt=""></p><h4 id="2-1-3-实例二-使用多个-catch-语句对程序做异常处理"><a href="#2-1-3-实例二-使用多个-catch-语句对程序做异常处理" class="headerlink" title="2.1.3 实例二   使用多个 catch 语句对程序做异常处理"></a>2.1.3 实例二   使用多个 catch 语句对程序做异常处理</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>从控制台输入 5 个数存入整数数组中，首先判断输入的值是否为数值，再判断数组元素是否越界， 根据题目要求，创建控制台应用程序完成该实例 </p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;定义存放5个整数的数组</span><br><span class="line">        int[] a &#x3D; new int[5];</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; a.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i] &#x3D; int.Parse(Console.ReadLine());</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; a.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(a[i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(FormatException f)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;输入的数字格式不正确！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(OverflowException o)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;输入的值已经超出 int 类型的最大值！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IndexOutOfRangeException r)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;数组越界异常！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p><img src="https://images.pgzxc.com/csharp-exception-trycatch-sample-2.png" alt=""></p><h3 id="2-2-try-finally"><a href="#2-2-try-finally" class="headerlink" title="2.2 try finally"></a>2.2 try finally</h3><h4 id="2-2-1-说明"><a href="#2-2-1-说明" class="headerlink" title="2.2.1 说明"></a>2.2.1 说明</h4><p>在try finally形式中没有单独对出现异常时处理的代码，finally语句无论是try中的语句是否正确执行都会执行的语句，通常在finally中编写的代码是关闭流、关闭数据库连接等操作，以免造成资源的浪费</p><h4 id="2-2-2-实例一-验证-finally-语句的使用"><a href="#2-2-2-实例一-验证-finally-语句的使用" class="headerlink" title="2.2.2 实例一   验证 finally 语句的使用"></a>2.2.2 实例一   验证 finally 语句的使用</h4><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public partial class tryCatchForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public tryCatchForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;“确认”按钮单击事件</span><br><span class="line">    private void button1_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取文本框中的值</span><br><span class="line">        string str &#x3D; textBox1.Text;</span><br><span class="line">        &#x2F;&#x2F;将字符串装换为整数</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            int num &#x3D; int.Parse(str);</span><br><span class="line">            MessageBox.Show(&quot;您输入的数字是：&quot; + num);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;finally 语句&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-实例二-从文本框中输入当天的天气情况，并将其写入文件中，无论写入是否成功都将文件流关闭"><a href="#2-2-3-实例二-从文本框中输入当天的天气情况，并将其写入文件中，无论写入是否成功都将文件流关闭" class="headerlink" title="2.2.3 实例二   从文本框中输入当天的天气情况，并将其写入文件中，无论写入是否成功都将文件流关闭"></a>2.2.3 实例二   从文本框中输入当天的天气情况，并将其写入文件中，无论写入是否成功都将文件流关闭</h4><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public partial class TryFinallyForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public TryFinallyForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&quot;确认&quot;按钮的单击事件</span><br><span class="line">    private void button1_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取文本框</span><br><span class="line">        string city &#x3D; txtCity.Text;</span><br><span class="line">        string msg &#x3D; txtMsg.Text;</span><br><span class="line">        string min &#x3D; txtMin.Text;</span><br><span class="line">        string max &#x3D; txtMax.Text;</span><br><span class="line">        &#x2F;&#x2F;将文本框中的内容组成一个字符串</span><br><span class="line">        string message &#x3D; city + &quot;：&quot; + msg + &quot;：&quot; + min + &quot;~&quot; + max;</span><br><span class="line">        &#x2F;&#x2F;定义文件路径</span><br><span class="line">        string path &#x3D; &quot;D:\\C#_test\\weather.txt&quot;;</span><br><span class="line">        FileStream fileStream &#x3D; null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;创建fileSteam类的对象</span><br><span class="line">            fileStream &#x3D; new FileStream(path, FileMode.OpenOrCreate);</span><br><span class="line">            &#x2F;&#x2F;将字符串转换成字节数组</span><br><span class="line">            byte[] bytes &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">            &#x2F;&#x2F;向文件中写入字节数组</span><br><span class="line">            fileStream.Write(bytes, 0, bytes.Length);</span><br><span class="line">            &#x2F;&#x2F;刷新缓冲区</span><br><span class="line">            fileStream.Flush();</span><br><span class="line">            &#x2F;&#x2F;弹出录入成功的消息框</span><br><span class="line">            MessageBox.Show(&quot;天气信息录入成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            if (fileStream !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;关闭流</span><br><span class="line">                fileStream.Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h5><p><img src="https://images.pgzxc.com/csharp-exception-tryfinally-weather.png" alt=""></p><h3 id="2-3-try-catch-finally"><a href="#2-3-try-catch-finally" class="headerlink" title="2.3 try catch finally"></a>2.3 try catch finally</h3><h4 id="2-3-1-说明"><a href="#2-3-1-说明" class="headerlink" title="2.3.1 说明"></a>2.3.1 说明</h4><p>try catch finally形式语句是使用最多的一种异常处理语句，在出现异常时能提供相应的异常处理，并能在finally语句中保证资源的回收</p><h4 id="2-3-2-实例-使用-try-catch-finally-形式完成实例-4-的题目要求"><a href="#2-3-2-实例-使用-try-catch-finally-形式完成实例-4-的题目要求" class="headerlink" title="2.3.2 实例  使用 try catch finally 形式完成实例 4 的题目要求"></a>2.3.2 实例  使用 try catch finally 形式完成实例 4 的题目要求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public partial class TryFinallyForm : Form</span><br><span class="line">&#123;</span><br><span class="line">    public TryFinallyForm()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&quot;确认&quot;按钮的单击事件</span><br><span class="line">    private void button1_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取文本框</span><br><span class="line">        string city &#x3D; txtCity.Text;</span><br><span class="line">        string msg &#x3D; txtMsg.Text;</span><br><span class="line">        string min &#x3D; txtMin.Text;</span><br><span class="line">        string max &#x3D; txtMax.Text;</span><br><span class="line">        &#x2F;&#x2F;将文本框中的内容组成一个字符串</span><br><span class="line">        string message &#x3D; city + &quot;：&quot; + msg + &quot;：&quot; + min + &quot;~&quot; + max;</span><br><span class="line">        &#x2F;&#x2F;定义文件路径</span><br><span class="line">        string path &#x3D; &quot;D:\\C#_test\\weather.txt&quot;;</span><br><span class="line">        FileStream fileStream &#x3D; null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;创建fileSteam类的对象</span><br><span class="line">            fileStream &#x3D; new FileStream(path, FileMode.OpenOrCreate);</span><br><span class="line">            &#x2F;&#x2F;将字符串转换成字节数组</span><br><span class="line">            byte[] bytes &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">            &#x2F;&#x2F;向文件中写入字节数组</span><br><span class="line">            fileStream.Write(bytes, 0, bytes.Length);</span><br><span class="line">            &#x2F;&#x2F;刷新缓冲区</span><br><span class="line">            fileStream.Flush();</span><br><span class="line">            &#x2F;&#x2F;弹出录入成功的消息框</span><br><span class="line">            MessageBox.Show(&quot;天气信息录入成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(&quot;出现错误！&quot; + ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            if (fileStream !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;关闭流</span><br><span class="line">                fileStream.Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;在C#语言中异常与异常处理语句包括三种形式，即try catch、try finally、try catch finally。在上述三种异常处理的形式中所用到的关键字其含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;try：用于检查发生的异常，并帮助发送任何可能的异常&lt;/li&gt;
&lt;li&gt;catch：以控制权更大的方式处理错误，可以有多个catch子句&lt;/li&gt;
&lt;li&gt;finally：无论是否引发了异常，finally的代码块都将被执行&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#开发之——Exception(13.1)</title>
    <link href="http://pgzxc.github.io/posts/8f328483.html"/>
    <id>http://pgzxc.github.io/posts/8f328483.html</id>
    <published>2020-08-03T12:44:19.000Z</published>
    <updated>2020-08-03T12:51:03.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>.NET Framework类库中的所有异常都派生于Exception类，异常包括系统异常和应用异常</li><li>默认所有系统异常都派生于System.SystemException，所有的应用程序异常派生于System.ApplicationException</li><li>系统异常包括OutOfMemmoryException、IOException、NullReferenceException</li></ul><a id="more"></a><h2 id="二-异常类图"><a href="#二-异常类图" class="headerlink" title="二 异常类图"></a>二 异常类图</h2><p><img src="https://images.pgzxc.com/csharp-exception-struct.png" alt=""></p><h2 id="三-常用系统异常表"><a href="#三-常用系统异常表" class="headerlink" title="三 常用系统异常表"></a>三 常用系统异常表</h2><table><thead><tr><th align="center"><strong>异常类</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">System.OutOfMemoryException</td><td align="center">用 new 分配内存失败</td></tr><tr><td align="center">System.StackOverflowException</td><td align="center">递归过多、过深</td></tr><tr><td align="center">System.NullReferenceException</td><td align="center">对象为空</td></tr><tr><td align="center">Syetem.IndexOutOfRangeException</td><td align="center">数组越界</td></tr><tr><td align="center">System.ArithmaticException</td><td align="center">算术操作异常的基类</td></tr><tr><td align="center">System.DivideByZeroException</td><td align="center">除零错误</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;.NET Framework类库中的所有异常都派生于Exception类，异常包括系统异常和应用异常&lt;/li&gt;
&lt;li&gt;默认所有系统异常都派生于System.SystemException，所有的应用程序异常派生于System.ApplicationException&lt;/li&gt;
&lt;li&gt;系统异常包括OutOfMemmoryException、IOException、NullReferenceException&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="桌面开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    
    <category term="C#" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/C/"/>
    
    
    <category term="C#" scheme="http://pgzxc.github.io/tags/C/"/>
    
  </entry>
  
</feed>
