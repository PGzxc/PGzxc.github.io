<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PGzxc</title>
  
  <subtitle>纸上得来终觉浅 绝知此事要躬行</subtitle>
  <link href="http://pgzxc.github.io/atom.xml" rel="self"/>
  
  <link href="http://pgzxc.github.io/"/>
  <updated>2020-10-29T15:37:35.149Z</updated>
  <id>http://pgzxc.github.io/</id>
  
  <author>
    <name>PGzxc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序开发之——调查问卷-表单数据绑定(2.2.4)</title>
    <link href="http://pgzxc.github.io/posts/9d5fd9b5.html"/>
    <id>http://pgzxc.github.io/posts/9d5fd9b5.html</id>
    <published>2020-10-26T14:40:58.000Z</published>
    <updated>2020-10-29T15:37:35.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>表单数据绑定的实际需求</li><li>将data数据替换表单默认数据</li><li>服务器返回data数据给微信小程序</li></ul><a id="more"></a><h2 id="二-实际需求"><a href="#二-实际需求" class="headerlink" title="二 实际需求"></a>二 实际需求</h2><p>前面的小节中，表单是完全编写在WXML中的，然而在实际开发中，会经常需要对表单的默认值进行变更。例如，用户发现已经提交的调查问卷中有些内容填写错误，需要进行修改，希望程序提供一个修改的表单，该表单默认已经填写了上次提交的内容，这就需要从服务器获取已经提交的数据，然后将数据填入到表单中</p><h2 id="三-将data数据替换表单默认数据"><a href="#三-将data数据替换表单默认数据" class="headerlink" title="三 将data数据替换表单默认数据"></a>三 将data数据替换表单默认数据</h2><h3 id="3-1-修改的数据"><a href="#3-1-修改的数据" class="headerlink" title="3.1 修改的数据"></a>3.1 修改的数据</h3><ul><li>针对上述需求，可以通过表单数据绑定来实现。</li><li>首先在pages/index/index.js文件的data数据中保存表单的默认数据</li></ul><h3 id="3-2-index-js中data数据"><a href="#3-2-index-js中data数据" class="headerlink" title="3.2 index.js中data数据"></a>3.2 index.js中data数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">   name:&#39;张三&#39;,</span><br><span class="line">   gender:[</span><br><span class="line">     &#123;name:&#39;男&#39;,value:&#39;0&#39;,checked:true&#125;,</span><br><span class="line">     &#123;name:&#39;女&#39;,value:&#39;1&#39;,checked:false&#125;</span><br><span class="line">   ],</span><br><span class="line">   skills:[</span><br><span class="line">     &#123;name:&#39;HTML&#39;,value:&#39;html&#39;,checked:true&#125;,</span><br><span class="line">     &#123;name:&#39;CSS&#39;,value:&#39;css&#39;,checked:false&#125;,</span><br><span class="line">     &#123;name:&#39;JavaScript&#39;,value:&#39;js&#39;,checked:false&#125;,</span><br><span class="line">     &#123;name:&#39;Photoshop&#39;,value:&#39;ps&#39;,checked:false&#125;</span><br><span class="line">   ],</span><br><span class="line">   opinion:&#39;测试&#39;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="3-3-index-wxml中代码-预览画面已有数值"><a href="#3-3-index-wxml中代码-预览画面已有数值" class="headerlink" title="3.3 index.wxml中代码(预览画面已有数值)"></a>3.3 index.wxml中代码(预览画面已有数值)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">&lt;form bindsubmit&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;姓名：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;&#123;&#123;name&#125;&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;性别：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;radio-group name&#x3D;&quot;gender&quot;&gt;</span><br><span class="line">&lt;label wx:for&#x3D;&quot;&#123;&#123;gender&#125;&#125;&quot; wx:key&#x3D;&quot;value&quot;&gt;</span><br><span class="line">  &lt;radio value&#x3D;&quot;&#123;&#123;item.value&#125;&#125;&quot; checked&#x3D;&quot;&#123;&#123;item.checked&#125;&#125;&quot;&#x2F;&gt;</span><br><span class="line">  &#123;&#123;item.name&#125;&#125;</span><br><span class="line">&lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;radio-group&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text&gt;专业技能：&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;checkbox-group name&#x3D;&quot;skills&quot;&gt;</span><br><span class="line">    &lt;label wx:for&#x3D;&quot;&#123;&#123;skills&#125;&#125;&quot; wx:key&#x3D;&quot;value&quot;&gt;</span><br><span class="line">      &lt;checkbox value&#x3D;&quot;&#123;&#123;item.value&#125;&#125;&quot; checked&#x3D;&quot;&#123;&#123;item.checked&#125;&#125;&quot; &#x2F;&gt;&#123;&#123;item.name&#125;&#125;</span><br><span class="line">    &lt;&#x2F;label&gt;</span><br><span class="line">  &lt;&#x2F;checkbox-group&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text&gt;您的意见：&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;textarea name&#x3D;&quot;opinion&quot; value&#x3D;&quot;&#123;&#123;opinion&#125;&#125;&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;button form-type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><h3 id="3-4-说明"><a href="#3-4-说明" class="headerlink" title="3.4 说明"></a>3.4 说明</h3><p>上述代码中，</p><ul><li>wx:for列表渲染，用于根据给定的数组重复渲染该组件。</li><li>在列表渲染标签内，可以使用item表示数组的当前项，使用index表示当前项的下标。</li><li>wx:key表示每一项的唯一标识，值为value表示将每一项的value属性作为唯一标识，也可以用保留关键字*this表示将每一项本身作为唯一标识</li><li>在列表渲染中，设置wx:key可以在数据改变后在页面中重新渲染时，使原有的组件保持自身的状态，而不是重新创建，并且提高了列表渲染时的效率</li></ul><h2 id="四-服务器返回data数据给微信小程序"><a href="#四-服务器返回data数据给微信小程序" class="headerlink" title="四 服务器返回data数据给微信小程序"></a>四 服务器返回data数据给微信小程序</h2><h3 id="4-1-说明"><a href="#4-1-说明" class="headerlink" title="4.1 说明"></a>4.1 说明</h3><p>通过以上操作，实现了将表单中的数据分离出来，就可以通过程序控制表单的各项的选中状态。下面在服务器端项目index.js文件的app.listen()前面增加代码，将data中的数据放入服务器端，由服务器将data返回给小程序</p><h3 id="4-2-服务器端index-js"><a href="#4-2-服务器端index-js" class="headerlink" title="4.2 服务器端index.js"></a>4.2 服务器端index.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const express&#x3D;require(&#39;express&#39;)</span><br><span class="line">const bodyParser&#x3D;require(&#39;body-parser&#39;)</span><br><span class="line">const app&#x3D;express()</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line">&#x2F;&#x2F;处理POST请求</span><br><span class="line">app.post(&#39;&#x2F;&#39;,(req,res)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(req.body)</span><br><span class="line">    res.json(req.body)</span><br><span class="line">&#125;)</span><br><span class="line">var data&#x3D;&#123;</span><br><span class="line">    name:&#39;张三&#39;,</span><br><span class="line">    gender:[</span><br><span class="line">        &#123;name:&#39;男&#39;,value:&#39;0&#39;,checked:true&#125;,</span><br><span class="line">        &#123;name:&#39;女&#39;,value:&#39;1&#39;,checked:false&#125;</span><br><span class="line">    ],</span><br><span class="line">    skills:[</span><br><span class="line">        &#123;name:&#39;HTML&#39;,value:&#39;html&#39;,checked:true&#125;,</span><br><span class="line">        &#123;name:&#39;CSS&#39;,value:&#39;css&#39;,checked:false&#125;,</span><br><span class="line">        &#123;name:&#39;JavaScript&#39;,value:&#39;js&#39;,checked:false&#125;,</span><br><span class="line">        &#123;name:&#39;Photoshop&#39;,value:&#39;ps&#39;,checked:false&#125;</span><br><span class="line">      ],</span><br><span class="line">      opinion:&#39;测试&#39;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">app.get(&#39;&#x2F;&#39;,(req,res)&#x3D;&gt;&#123;</span><br><span class="line">    res.json(data)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;监听300接口</span><br><span class="line">app.listen(3000,()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;server running at http:&#x2F;&#x2F;localhost:3000&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码，用于实现GET请求方式，将data以JSON格式返回</p><h3 id="4-3-小程序-index-js"><a href="#4-3-小程序-index-js" class="headerlink" title="4.3 小程序 index.js"></a>4.3 小程序 index.js</h3><p>完成服务器端代码后，在小程序pages/index/index.js文件的onLoad事件函数中实现页面打开后自动向服务器发送请求，获取表单中的初始数据，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">   var that&#x3D;this</span><br><span class="line">   wx.request(&#123;</span><br><span class="line">     url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;,</span><br><span class="line">     success:function(res)&#123;</span><br><span class="line">       that.setData(res.data)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="4-4-that和this"><a href="#4-4-that和this" class="headerlink" title="4.4 that和this"></a>4.4 that和this</h3><p>上述代码中，success的回调函数中，this的指向发生了变化，因此需要通过代码将this保存为that后使用。除了这种方式，还可以利用ES6的箭头函数语法来更好地解决这个问题，无需再用that保存ths，具体代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">   wx.request(&#123;</span><br><span class="line">     url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;,</span><br><span class="line">     success:res&#x3D;&gt;&#123;</span><br><span class="line">       this.setData(res.data)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>值得一提的是，由于wx.request()参数中的method属性的默认值为GET，因此在发送GET请求时可以省略method属性</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;表单数据绑定的实际需求&lt;/li&gt;
&lt;li&gt;将data数据替换表单默认数据&lt;/li&gt;
&lt;li&gt;服务器返回data数据给微信小程序&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——调查问卷-服务器数据交互(2.2.3)</title>
    <link href="http://pgzxc.github.io/posts/691184aa.html"/>
    <id>http://pgzxc.github.io/posts/691184aa.html</id>
    <published>2020-10-26T14:40:10.000Z</published>
    <updated>2020-10-29T15:37:35.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>小程序与服务器交互说明</li><li>利用Express框架，快速搭建HTTP服务器</li><li>小程序端编写代码响应HTTP请求</li></ul><a id="more"></a><h2 id="二-小程序与服务器交互说明"><a href="#二-小程序与服务器交互说明" class="headerlink" title="二 小程序与服务器交互说明"></a>二 小程序与服务器交互说明</h2><p>将用户提交的表单提交到服务器，可以通过小程序中的网络API wx.request()来实现。需要注意的是，对于正式上线的项目，小程序要求服务器域名必须在小程序管理后台中添加，域名必须经过ICP备案，且只支持HTTPS和WSS协议</p><p>对于开发人员来说，为了方便学习，可以在微信开发者工具中关闭这些验证，从而利用本地网络来测试网络功能。单击工具栏中的详情按钮，选中下图所示的选项：</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-question-network-not-check.png" loading="lazy"></p><h2 id="三-利用Express框架，快速搭建HTTP服务器"><a href="#三-利用Express框架，快速搭建HTTP服务器" class="headerlink" title="三 利用Express框架，快速搭建HTTP服务器"></a>三 利用Express框架，快速搭建HTTP服务器</h2><h3 id="3-1-搭建说明"><a href="#3-1-搭建说明" class="headerlink" title="3.1 搭建说明"></a>3.1 搭建说明</h3><p>本节利用Node.js+express在本地搭建一个HTTP服务器</p><ul><li>Express 是一个简洁而灵活的 node.js Web应用框架, 提供一系列强大特性帮助你创建各种Web应用</li><li>将Node.js安装成功后，创建一个空目录作为项目目录，稍后执行搭建命令</li></ul><h3 id="3-2-搭建过程"><a href="#3-2-搭建过程" class="headerlink" title="3.2 搭建过程"></a>3.2 搭建过程</h3><ul><li><p>初始化项目，将会自动创建package.json配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>安装Express框架，用于快速搭建HTTP服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure></li><li><p>安装nodemon监控文件修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nodemon -g</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-编写接口文件，并启动服务"><a href="#3-3-编写接口文件，并启动服务" class="headerlink" title="3.3 编写接口文件，并启动服务"></a>3.3 编写接口文件，并启动服务</h3><ul><li><p>在项目目录下创建index.js文件，编写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const express&#x3D;require(&#39;express&#39;)</span><br><span class="line">const bodyParser&#x3D;require(&#39;body-parser&#39;)</span><br><span class="line">const app&#x3D;express()</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line">&#x2F;&#x2F;处理POST请求</span><br><span class="line">app.post(&#39;&#x2F;&#39;,(req,res)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(req.body)</span><br><span class="line">    res.json(req.body)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;监听300接口</span><br><span class="line">app.listen(3000,()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;server running at http:&#x2F;&#x2F;localhost:3000&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码用于搭建一个监听3000端口的HTTP服务器，支持POST请求，<code> console.log</code>用于将接收到的数据输出到命令行，<code>res.json</code>用于将收到的数据响应给客户端</p></li><li><p>在命令行执行如下命令，启动服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure><p>上述命令执行后，如果看到server running at <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTozMDAw77yM6KGo56S65ZCv5Yqo5oiQ5Yqf">http://127.0.0.1:3000，表示启动成功<i class="fa fa-external-link-alt"></i></span></p></li></ul><h2 id="四-小程序端编写代码响应HTTP请求"><a href="#四-小程序端编写代码响应HTTP请求" class="headerlink" title="四 小程序端编写代码响应HTTP请求"></a>四 小程序端编写代码响应HTTP请求</h2><h3 id="4-1-搭建说明"><a href="#4-1-搭建说明" class="headerlink" title="4.1 搭建说明"></a>4.1 搭建说明</h3><p>将服务器搭建完成后，在小程序pages/index/index.js文件中编写表单提交的事件处理函数，利用wx.request()向本地HTTP服务器发送POST请求</p><h3 id="4-2-小程序端POST请求代码"><a href="#4-2-小程序端POST请求代码" class="headerlink" title="4.2 小程序端POST请求代码"></a>4.2 小程序端POST请求代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">submit:function(e)</span><br><span class="line">&#123;</span><br><span class="line">   wx.request(&#123;</span><br><span class="line">     method:&#39;post&#39;,</span><br><span class="line">     url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;,</span><br><span class="line">     data:e.detail.value,</span><br><span class="line">     success:function(res)</span><br><span class="line">     &#123;</span><br><span class="line">       console.log(res)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-小程序代码说明"><a href="#4-3-小程序代码说明" class="headerlink" title="4.3 小程序代码说明"></a>4.3 小程序代码说明</h3><ul><li>method：表示请求方法</li><li>url：表示服务器接口地址</li><li>data：表示请求的参数</li><li>success：表示接口调用成功的回调函数，其参数res表示服务器响应信息</li></ul><h3 id="4-4-点击按钮，提交请求"><a href="#4-4-点击按钮，提交请求" class="headerlink" title="4.4 点击按钮，提交请求"></a>4.4 点击按钮，提交请求</h3><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-question-http-response.png" loading="lazy"></p><ul><li>data：服务器的响应数据</li><li>errorMsg：成功或失败的信息</li><li>header：服务器的响应头</li><li>statusCode：服务器的响应状态码</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;小程序与服务器交互说明&lt;/li&gt;
&lt;li&gt;利用Express框架，快速搭建HTTP服务器&lt;/li&gt;
&lt;li&gt;小程序端编写代码响应HTTP请求&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——调查问卷-编写表单页面(2.2.2)</title>
    <link href="http://pgzxc.github.io/posts/ae563df8.html"/>
    <id>http://pgzxc.github.io/posts/ae563df8.html</id>
    <published>2020-10-26T14:38:54.000Z</published>
    <updated>2020-10-29T15:37:35.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本节介绍表单页面相关的内容：</p><ul><li>编写调查问卷表单页面</li><li>编写调查问卷样式</li><li>设置导航栏标题</li></ul><a id="more"></a><h2 id="二-编写调查问卷表单页面"><a href="#二-编写调查问卷表单页面" class="headerlink" title="二 编写调查问卷表单页面"></a>二 编写调查问卷表单页面</h2><p>在微信开发者工具中创建一个新项目，然后在项目中创建pages/index/index页面，在该页面的index.wxml文件中编写调查问卷的表单，具体代码如下。</p><h3 id="2-1-index-wxml"><a href="#2-1-index-wxml" class="headerlink" title="2.1 index.wxml"></a>2.1 index.wxml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">&lt;form bindsubmit&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;姓名：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;性别：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;radio-group name&#x3D;&quot;gender&quot;&gt;</span><br><span class="line">&lt;label&gt;&lt;radio value&#x3D;&quot;0&quot; checked&#x2F;&gt;男&lt;&#x2F;label&gt;</span><br><span class="line">&lt;label&gt;&lt;radio value&#x3D;&quot;1&quot;&#x2F;&gt;女&lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;radio-group&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text&gt;专业技能：&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;checkbox-group name&#x3D;&quot;skills&quot;&gt;</span><br><span class="line">    &lt;label&gt;&lt;checkbox value&#x3D;&quot;html&quot; &#x2F;&gt;HTML&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;label&gt;&lt;checkbox value&#x3D;&quot;css&quot;&#x2F;&gt;CSS&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;label&gt;&lt;checkbox value&#x3D;&quot;js&quot;&#x2F;&gt;JavaScript&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;label&gt;&lt;checkbox value&#x3D;&quot;ps&quot;&#x2F;&gt;Photoshop&lt;&#x2F;label&gt;</span><br><span class="line">  &lt;&#x2F;checkbox-group&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text&gt;您的意见：&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;textarea name&#x3D;&quot;opinion&quot; value&#x3D;&quot;测试&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;button form-type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-代码说明"><a href="#2-2-代码说明" class="headerlink" title="2.2 代码说明"></a>2.2 代码说明</h3><p>在上述代码中：</p><ul><li>&lt;radio-group&gt;性别标签标示将其包裹的所有&lt;radio&gt;标签当成一个单选框组，组内只有一个&lt;radio&gt;标签可以被选中。</li><li>&lt;checkbox-group&gt;标签标示将其包裹的所有&lt;checkbox&gt;标签当成一个复选框组，&lt;label&gt;标签的作用类似于HTML中的同名标签，用于单击文本时也可以选中对应的单选或复选框。</li><li>在&lt;radio&gt;和&lt;checkbox&gt;标签中，value属性表示该项选中时提交的值，checked属性表示该项为选中状态</li></ul><h2 id="三-编写调查问卷样式"><a href="#三-编写调查问卷样式" class="headerlink" title="三 编写调查问卷样式"></a>三 编写调查问卷样式</h2><p>在pages/index/index.wxss文件中编写样式，具体代码如下：</p><h3 id="3-1-样式代码"><a href="#3-1-样式代码" class="headerlink" title="3.1 样式代码"></a>3.1 样式代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;margin: 50rpx;&#125; </span><br><span class="line">view&#123;margin-bottom: 30rpx;&#125;</span><br><span class="line">input&#123;width: 600rpx; margin-top: 10rpx;border: 2rpx solid #ccc;&#125;</span><br><span class="line">label&#123;display: block;margin: 8rpx;&#125;</span><br><span class="line">textarea&#123;width: 600rpx;height: 100rpx;margin-top: 10rpx;border: 2rpx solid #eee;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-样式代码说明"><a href="#3-2-样式代码说明" class="headerlink" title="3.2 样式代码说明"></a>3.2 样式代码说明</h3><p>在上述代码中，display:block将&lt;label&gt;标签设为块元素，用于使单选框和复选框的每一项都独占一行</p><h2 id="四-设置导航栏标题"><a href="#四-设置导航栏标题" class="headerlink" title="四 设置导航栏标题"></a>四 设置导航栏标题</h2><p>最后在pages/index/index.json文件中设置导航栏标题，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;navigationBarTitleText&quot;: &quot;调查问卷&quot;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本节介绍表单页面相关的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写调查问卷表单页面&lt;/li&gt;
&lt;li&gt;编写调查问卷样式&lt;/li&gt;
&lt;li&gt;设置导航栏标题&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——调查问卷-案例分析(2.2.1)</title>
    <link href="http://pgzxc.github.io/posts/13b46f62.html"/>
    <id>http://pgzxc.github.io/posts/13b46f62.html</id>
    <published>2020-10-26T14:37:53.000Z</published>
    <updated>2020-10-29T15:37:35.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本节通过开发一个“调查问卷”的案例来学习常用表单组件的使用，以及如何收集用户填写的表单信息提交给服务器，或者从服务器获取数据后显示在表单中</p><a id="more"></a><h2 id="二-原型图"><a href="#二-原型图" class="headerlink" title="二 原型图"></a>二 原型图</h2><h3 id="2-1-原型图"><a href="#2-1-原型图" class="headerlink" title="2.1 原型图"></a>2.1 原型图</h3><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-questionnaire-view-yuanxing.png" loading="lazy"></p><h3 id="2-2-原型图说明"><a href="#2-2-原型图说明" class="headerlink" title="2.2 原型图说明"></a>2.2 原型图说明</h3><p>上图中，有单行文本框、单选框、复选框、文本域，以及一个提交按钮。用户单击“提交”按钮后，会将表单中填写的值提交给服务器。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本节通过开发一个“调查问卷”的案例来学习常用表单组件的使用，以及如何收集用户填写的表单信息提交给服务器，或者从服务器获取数据后显示在表单中&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客开发之——Markdown中出现“{{”号解析报错</title>
    <link href="http://pgzxc.github.io/posts/93d61cfd.html"/>
    <id>http://pgzxc.github.io/posts/93d61cfd.html</id>
    <published>2020-10-26T14:17:37.000Z</published>
    <updated>2020-10-29T15:37:34.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-现象描述"><a href="#一-现象描述" class="headerlink" title="一 现象描述"></a>一 现象描述</h2><p>最近写了一篇文章，在执行<code>hexo g</code>指令时生成文章预览时，会发生错误，错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unhandled rejection Nunjucks Error: _posts&#x2F;xxxxxxxxxxx.md [Line 27, Column 114] unexpected token: &#125;&#125;</span><br><span class="line">    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;               Context Dump               &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    &#x3D;&#x3D;&#x3D; (line number probably different from source) &#x3D;&#x3D;&#x3D;</span><br><span class="line">  22 | &lt;!--code￼3--&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-hexo/hexo-error-unhandled-nunjucks-info.png" loading="lazy"></p><h2 id="二-原因分析"><a href="#二-原因分析" class="headerlink" title="二 原因分析"></a>二 原因分析</h2><h3 id="2-1-分析过程"><a href="#2-1-分析过程" class="headerlink" title="2.1 分析过程"></a>2.1 分析过程</h3><ul><li>将本篇文章删除后，hexo g 能正常执行，说明是本篇文章引起的问题</li><li>将本篇文章的内容删除后，hexo指令能正常执行，说明不是头部categories和tags引起的问题</li><li>确定是文章内容引起的问题，根据错误信息，逐步缩小查找范围，最终确定是"{{"引起的错误</li></ul><h3 id="2-3-原因搜索"><a href="#2-3-原因搜索" class="headerlink" title="2.3 原因搜索"></a>2.3 原因搜索</h3><ul><li>复制错误信息<code>Unhandled rejection Nunjucks Error</code>搜索</li><li>确定上步"{{"引起的hexo指令错误进行搜索</li><li>根据错误信息给出的地址<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">https://hexo.io/docs/troubleshooting.html<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="2-4-原因解释-hexo-troubleshooting"><a href="#2-4-原因解释-hexo-troubleshooting" class="headerlink" title="2.4 原因解释(hexo troubleshooting)"></a>2.4 原因解释(hexo troubleshooting)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Escape Contents</span><br><span class="line">Hexo uses Nunjucks to render posts (Swig was used in older version, which share a similar syntax). Content wrapped with &#123;&#123; &#125;&#125; or &#123;% %&#125; will get parsed and may cause problems. You can skip the parsing by wrapping it with the raw tag plugin, single backtick &#96;&#123;&#123; &#125;&#125;&#96; or triple backtick.</span><br><span class="line">Alternatively, Nunjucks tags can be disabled through the renderer’s option (if supported), API or front-matter.</span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;</span><br><span class="line">Hello &#123;&#123; world &#125;&#125;</span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">Hello &#123;&#123; world &#125;&#125;</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><h2 id="三-解决办法"><a href="#三-解决办法" class="headerlink" title="三 解决办法"></a>三 解决办法</h2><ul><li><p>修改前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#123;&#123;&#125;&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;&quot;&#123;&#123;&#125;&#125;&quot;&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四-参考"><a href="#四-参考" class="headerlink" title="四 参考"></a>四 参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">https://hexo.io/docs/troubleshooting.html<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-现象描述&quot;&gt;&lt;a href=&quot;#一-现象描述&quot; class=&quot;headerlink&quot; title=&quot;一 现象描述&quot;&gt;&lt;/a&gt;一 现象描述&lt;/h2&gt;&lt;p&gt;最近写了一篇文章，在执行&lt;code&gt;hexo g&lt;/code&gt;指令时生成文章预览时，会发生错误，错误信息如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Unhandled rejection Nunjucks Error: _posts&amp;#x2F;xxxxxxxxxxx.md [Line 27, Column 114] unexpected token: &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;               Context Dump               &amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x3D;&amp;#x3D;&amp;#x3D; (line number probably different from source) &amp;#x3D;&amp;#x3D;&amp;#x3D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  22 | &amp;lt;!--code￼3--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/categories/%E5%B7%A5%E5%85%B7/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="http://pgzxc.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——UITabBarViewController控制器加载(63)</title>
    <link href="http://pgzxc.github.io/posts/efa3afd7.html"/>
    <id>http://pgzxc.github.io/posts/efa3afd7.html</id>
    <published>2020-10-25T15:23:24.000Z</published>
    <updated>2020-10-29T15:37:34.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本文介绍以下内容：</p><ul><li>UITabBarViewController的TabBar设置控制器，并重写控制器中的方法，观察控制器切换时的方法执行</li><li>程序启动后，方法执行的先后顺序</li></ul><a id="more"></a><h2 id="二-UITabBarViewController的TabBar控制器的执行"><a href="#二-UITabBarViewController的TabBar控制器的执行" class="headerlink" title="二 UITabBarViewController的TabBar控制器的执行"></a>二 UITabBarViewController的TabBar控制器的执行</h2><h3 id="2-1-过程描述"><a href="#2-1-过程描述" class="headerlink" title="2.1 过程描述"></a>2.1 过程描述</h3><ul><li>给TabBar的每个控制器重新ViewController方法，并重写ViewController中的方法，并给每个重写的方法添加打印输出</li><li>在Main.stroyboard布局文件中，给每个TabBar绑定相应的自定义ViewController</li><li>切换TabBar，观察方法的打印输出</li></ul><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><ul><li><p>分别添加MessageViewController，QworldViewController，ContactViewController，SettingViewController(每个中都重写了viewDidLoad，viewWillAppear，viewDidAppear，viewWillDisappear，viewDidDisappear)</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/ios-uitabbarviewcontroller-viewcontroller-define-log.png" loading="lazy"></p></li><li><p>打开<code>Main.storyboard</code>，找到对应的TabBar绑定自定义ViewController</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/ios-uitabbarviewcontroller-mainstoryboard-bing-viewcontroller.png" loading="lazy"></p></li><li><p>切换UITabBar查看打印消息</p><ul><li><p>第一次显示时打印消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[MessageViewController viewDidLoad]</span><br><span class="line">-[MessageViewController viewWillAppear:]</span><br><span class="line">-[MessageViewController viewDidAppear:]</span><br></pre></td></tr></table></figure></li><li><p>切换到第二个UITabBar时，显示消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-[ContactViewController viewDidLoad]</span><br><span class="line">-[ContactViewController viewWillAppear:]</span><br><span class="line">-[MessageViewController viewWillDisappear:]</span><br><span class="line">-[MessageViewController viewDidDisappear:]</span><br><span class="line">-[ContactViewController viewDidAppear:]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><ul><li>当页面要显示时，会先后执行viewDidLoad，viewWillAppear，viewDidAppear</li><li>当切换到第二个页面时：先执行第二个页面的viewDidLoad，viewWillAppear，再执行第一个页面的viewWillDisappear，viewDidDisappear，最后执行第二个页面的viewDidAppear</li><li><strong>viewDidLoad</strong>：在视图加载后被调用，如果是在代码中创建的视图加载器，他将会在loadView方法后被调用，如果是从nib视图页面输出，他将会在视图设置好后后被调用</li><li><strong>viewWillAppear</strong>：当收到视图在视窗将可见时的通知会呼叫的方法。默认情况下不执行任何操作</li><li><strong>viewDidAppear</strong>:当收到视图在视窗已可见时的通知会呼叫的方法，（视图已完全过渡到屏幕上时调用）</li><li><strong>viewWillDisappear</strong>:当收到视图将去除、被覆盖或隐藏于视窗时的通知会呼叫的方法。默认情况下不执行任何操作loadView;这是当他们没有正在使用nib视图页面，子类将会创建自己的自定义视图层。绝不能直接调用</li><li><strong>viewDidDisappear</strong>：当收到视图已去除、被覆盖或隐藏于视窗时的通知会呼叫的方法</li></ul><h2 id="三-程序启动后，方法执行的先后顺序"><a href="#三-程序启动后，方法执行的先后顺序" class="headerlink" title="三 程序启动后，方法执行的先后顺序"></a>三 程序启动后，方法执行的先后顺序</h2><h3 id="3-1-程序第一次启动后"><a href="#3-1-程序第一次启动后" class="headerlink" title="3.1 程序第一次启动后"></a>3.1 程序第一次启动后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate application:didFinishLaunchingWithOptions:]</span><br><span class="line">-[SceneDelegate scene:willConnectToSession:options:]</span><br><span class="line">-[SceneDelegate sceneWillEnterForeground:]</span><br><span class="line">-[SceneDelegate sceneDidBecomeActive:]</span><br></pre></td></tr></table></figure><h3 id="3-2-切换到后台后"><a href="#3-2-切换到后台后" class="headerlink" title="3.2 切换到后台后"></a>3.2 切换到后台后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[SceneDelegate sceneWillResignActive:]</span><br><span class="line">-[SceneDelegate sceneDidEnterBackground:]</span><br></pre></td></tr></table></figure><h3 id="3-3-再次回到前台"><a href="#3-3-再次回到前台" class="headerlink" title="3.3 再次回到前台"></a>3.3 再次回到前台</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[SceneDelegate sceneWillEnterForeground:]</span><br><span class="line">-[SceneDelegate sceneDidBecomeActive:]</span><br></pre></td></tr></table></figure><h3 id="3-4-从后台退出程序时"><a href="#3-4-从后台退出程序时" class="headerlink" title="3.4 从后台退出程序时"></a>3.4 从后台退出程序时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[SceneDelegate sceneDidDisconnect:]</span><br><span class="line">-[AppDelegate application:didDiscardSceneSessions:]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本文介绍以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UITabBarViewController的TabBar设置控制器，并重写控制器中的方法，观察控制器切换时的方法执行&lt;/li&gt;
&lt;li&gt;程序启动后，方法执行的先后顺序&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="移动开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="IOS" scheme="http://pgzxc.github.io/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——比较数字大小-实现比较功能(2.1.7)</title>
    <link href="http://pgzxc.github.io/posts/bb231598.html"/>
    <id>http://pgzxc.github.io/posts/bb231598.html</id>
    <published>2020-10-25T14:11:55.000Z</published>
    <updated>2020-10-29T15:37:35.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在小程序中实现两个数值的大小比较，可以通过逻辑判断和页面展示来实现。功能的实现有多种方式</p><ul><li>为两个input组件绑定不同事件处理函数</li><li>为两个input组件绑定相同事件处理函数</li><li>在页面中直接进行比较</li><li>通过条件渲染显示不同结果</li><li>通过表单获取input组件的值</li></ul><a id="more"></a><h2 id="二-为两个input组件绑定不同事件处理函数"><a href="#二-为两个input组件绑定不同事件处理函数" class="headerlink" title="二 为两个input组件绑定不同事件处理函数"></a>二 为两个input组件绑定不同事件处理函数</h2><h3 id="2-1-页面"><a href="#2-1-页面" class="headerlink" title="2.1 页面"></a>2.1 页面</h3><p>input组件提供了change事件，会在输入框中内容发生改变后触发，通过该事件可以获取用户输入的数字。下面在pages/index/index.wxml文件中为两个input组件的change事件绑定不同事件处理函数，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第1个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;num1change&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第2个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;num2change&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-功能"><a href="#2-2-功能" class="headerlink" title="2.2 功能"></a>2.2 功能</h3><p>然后在pages/index/index.js文件中编写事件处理函数，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num1:0,</span><br><span class="line">num2:0,</span><br><span class="line">num1change:function(e)</span><br><span class="line">&#123;</span><br><span class="line">   this.num1&#x3D;Number(e.detail.value)</span><br><span class="line">   console.log(&#39;第1个数字为&#39;+this.num1)</span><br><span class="line">&#125;,</span><br><span class="line">num2change:function(e)</span><br><span class="line">&#123;</span><br><span class="line">   this.num2&#x3D;Number(e.detail.value)</span><br><span class="line">   console.log(&#39;第2个数字为&#39;+this.num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，e.detail.value用于获取用户输入的值，Number()用于将字符串转换为数字类型。this.num1和this.num2用于保存获取到的数字，在后面的步骤中将会用到。</p><p>保存上述代码后，运行程序，在输入框中输入数字，然后点击页面中的其他位置触发change事件，就可以在控制台中看到用户输入的值。</p><p>当用户单击“比较”按钮时，对this.num1和this.num2进行比较即可。为了将比较结果显示在页面中，可以通过数据绑定来实现。在pages/index/index.wxml文件中为“比较”按钮添加tap事件，然后在&quot;比较结果&quot;的显示位置绑定一个名称为result的变量，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bindtap&#x3D;&quot;compare&quot;&gt;比较&lt;&#x2F;button&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;比较结果：&#123;&#123;result&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>在pages/index/index.js文件中，找到页面的初始数据data，在data中添加result属性，属性值为空字符串，表示当前未进行比较，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;result:&#39;&#39; &#125;</span><br></pre></td></tr></table></figure><p>然后继续在pages/index/index.js文件中编写compare函数，实现比较功能，将比较结果通过this.setData()显示在页面中，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compare:function(e)</span><br><span class="line">&#123;</span><br><span class="line">   var str&#x3D;&#39;两数相等&#39;</span><br><span class="line">   if(this.num1&gt;this.num2)</span><br><span class="line">   &#123;</span><br><span class="line">     str&#x3D;&#39;第1个数大&#39;</span><br><span class="line">   &#125;else if(this.num1&lt;this.num2)</span><br><span class="line">   &#123;</span><br><span class="line">     str&#x3D;&#39;第2个数大&#39;</span><br><span class="line">   &#125;</span><br><span class="line">   this.setData(&#123;result:str&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="2-3-效果"><a href="#2-3-效果" class="headerlink" title="2.3 效果"></a>2.3 效果</h3><p>保存上述代码后，运行程序，输入数字进行比较，结果如下图<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-input-bind.png" loading="lazy"></p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>通过以上操作可以看出，在WXML中使用双大括号"{{}}"可以实现数据绑定，这种语法又称为Mustache语法。双大括号中可以写一个变量名，如"{{result}}"，在页面打开后，就会到Page({data:{result:&#39;&#39;},...})中读取result的值，显示在页面中</p><p>需要注意的是，当页面打开后，如果想要改变页面中的{{result}}的值，不能通过直接赋值的方式来实现。例如，在compare()函数中，使用this.data.result=str这种方式无法改变页面中的{{result}}的值，而是需要通过this.setData()方法来实现，该方法的参数是一个对象，传入{result:str}就表示将页面中{{result}}的值改变为变量str的值</p><h2 id="三-为两个input组件绑定相同事件处理函数"><a href="#三-为两个input组件绑定相同事件处理函数" class="headerlink" title="三 为两个input组件绑定相同事件处理函数"></a>三 为两个input组件绑定相同事件处理函数</h2><p>对于页面中只有两个input组件的情况，为它们绑定不同事件处理函数的方式非常简单，但不适合页面中又大量input组件的情况。因此，可以为多个input组件绑定相同事件处理函数，然后再为不同input组件设置不同的id或dataset即可，下面进行详细讲解。</p><h3 id="3-1-通过id区分元素"><a href="#3-1-通过id区分元素" class="headerlink" title="3.1 通过id区分元素"></a>3.1 通过id区分元素</h3><p>在pages/index/index.wxml文件中修改input组件的代码，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第1个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;num1&quot; type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;change&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第2个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;num2&quot; type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;change&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>上述代码为两个input组件设置了不同的id属性，分别是num1和num2，然后将bindchange属性的值改为change</p><p>接下来在pages/index/index.js文件中编写change函数，具体代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">change:function(e)</span><br><span class="line">&#123;</span><br><span class="line">   this[e.currentTarget.id]&#x3D;Number(e.detail.value)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>上述代码中，e.currentTarget.id的值为触发当前事件的input组件的id属性值，可能是num1或num2，然后通过this[]语法设置this.num1或this.num2的值。e.detail.value用于获取用户输入的数字。</p><h3 id="3-2-通过dataset区分元素"><a href="#3-2-通过dataset区分元素" class="headerlink" title="3.2 通过dataset区分元素"></a>3.2 通过dataset区分元素</h3><p>在pages/index/index.wxml文件中修改input组件的代码，具体如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第1个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input data-id&#x3D;&quot;num1&quot; type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;change2&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第2个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input data-id&#x3D;&quot;num2&quot; type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;change2&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>在上述代码中，删除了原来的id属性，然后增加了data-id属性。原来绑定的change函数改为了change2，从而和id方式进行区分</p><p>接下来在pages/index/index.js文件中编写change2函数，具体代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">change2:function(e)</span><br><span class="line">&#123;</span><br><span class="line">   this[e.target.dataset.id]&#x3D;Number(e.detail.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，e.target.dataset.id表示触发当前事件的input组件的data-id属性值。从上述代码可以看出，通过&quot;e.target.dataset.名称&quot;的方式即可获取&quot;data-名称&quot;的值。</p><h3 id="3-3-在页面中直接进行比较"><a href="#3-3-在页面中直接进行比较" class="headerlink" title="3.3 在页面中直接进行比较"></a>3.3 在页面中直接进行比较</h3><p>前面讲解的两种方式都哦是在按下“比较”按钮后，在事件处理函数中进行比较，实际上，使用XML中的“{{}}”语法可以直接比较两个变量的大小，具体代码如下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第1个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input data-id&#x3D;&quot;num1&quot; type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;change3&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第2个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input data-id&#x3D;&quot;num2&quot; type&#x3D;&quot;number&quot; bindchange&#x3D;&quot;change3&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;button bindtap&#x3D;&quot;compare&quot;&gt;比较&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;比较结果：&#123;&#123;num1&gt;num2?&#39;第一个数大&#39;:(num1&lt;num2)?&#39;第二个数大&#39;:&#39;两数相等&#39;&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>上述代码中，原来绑定的change2函数改为change3，并且显示结果代码在"{{}}"中使用三元运算符比较num1和num2的大小，显示比较结果</p><p>在pages/index/index.js文件中增加change3函数和绑定的变量，具体代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">   num1:0,</span><br><span class="line">   num2:0,</span><br><span class="line">   result:&#39;&#39; </span><br><span class="line"> &#125;,</span><br><span class="line">change3:function(e)</span><br><span class="line"> &#123;</span><br><span class="line">   var data&#x3D;&#123;&#125;</span><br><span class="line">   data[e.target.dataset.id]&#x3D;Number(e.detail.value)</span><br><span class="line">   this.setData(data)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，上面的this.setData()用于设置页面中的num1或num2的值，运行程序测试，在页面打开时，num1和num2的值都为0，因此比较结果为“两数相等”。输入数字后，单击其他位置触发change事件，就会显示比较结果。由此可见，当执行this.setData()时，页面中绑定的变量就会发生改变，如果"{{}}"中有运算符，则会进行运算，并显示运算结果。另外，在"{{}}"中不仅可以使用三元运算符，还可以使用算术运算符、逻辑运算符等各种常见的运算符</p><h2 id="四-通过条件渲染显示不同结果"><a href="#四-通过条件渲染显示不同结果" class="headerlink" title="四 通过条件渲染显示不同结果"></a>四 通过条件渲染显示不同结果</h2><p>在"{{}}"中使用三元运算符判断虽然方便，但是不够灵活，如果希望根据判断结果显示不同的标签，则可以使用条件渲染来实现，下面进行操作演示在pages/index/index.wxml文件中修改显示比较结果的代码，具体如下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text wx:if&#x3D;&quot;&#123;&#123;num1&gt;num2&#125;&#125;&quot;&gt;比较结果：第1个数大&lt;&#x2F;text&gt;</span><br><span class="line">&lt;text wx:if&#x3D;&quot;&#123;&#123;num1&lt;num2&#125;&#125;&quot;&gt;比较结果：第2个数大&lt;&#x2F;text&gt;</span><br><span class="line">&lt;text wx:if&#x3D;&quot;&#123;&#123;num1&#x3D;&#x3D;num2&#125;&#125;&quot;&gt;比较结果：两数相等&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>在上述代码中，有3个\<text>标签用于显示结果，通过wx:if属性判断哪一个标签会在WXML结构中出现(而不是利用样式控制标签的显示或隐藏)，如果"{{}}"中的运算结果为true则出现，运算结果为false则不会出现。</p><p>此外，条件渲染还支持类似于if...else...或if...else if...else结构语法，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text wx:if&#x3D;&quot;&#123;&#123;num1&gt;num2&#125;&#125;&quot;&gt;比较结果：第1个数大&lt;&#x2F;text&gt;</span><br><span class="line">&lt;text wx:elif&#x3D;&quot;&#123;&#123;num1&lt;num2&#125;&#125;&quot;&gt;比较结果：第2个数大&lt;&#x2F;text&gt;</span><br><span class="line">&lt;text wx:else&#x3D;&quot;&#123;&#123;num1&#x3D;&#x3D;num2&#125;&#125;&quot;&gt;比较结果：两数相等&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>以上两种方式在控制某一个标签时会比较方便，但如果希望控制一块区域是否出现则使用&lt;block&gt;标签会更加方便，示例代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;block wx:if&#x3D;&quot;&#123;&#123;num1&gt;num2&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;text&gt;比较结果：第1个数大&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br><span class="line">&lt;block wx:elif&#x3D;&quot;&#123;&#123;num1&lt;num2&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;text&gt;比较结果：第2个数大&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br><span class="line">&lt;block wx:else&gt;</span><br><span class="line">&lt;text&gt;比较结果：两数相等&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，&lt;block&gt;标签并不是一个组件，它仅仅是一个包装元素，不会再页面中做任何渲染，只接受控制属性。</p><h2 id="五-通过表单获取input组件的值"><a href="#五-通过表单获取input组件的值" class="headerlink" title="五 通过表单获取input组件的值"></a>五 通过表单获取input组件的值</h2><p>在进行HTML开发时，经常会使用&lt;form&gt;标签创建一个表单，从而提交数据。小程序也提供了类似的form组件，通过它可以方便地获取各种表单组件的值。</p><p>在pages/index/index.wxml文件中修改原来的代码，具体如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;form bindsubmit&#x3D;&quot;formCompare&quot;&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第1个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input name&#x3D;&quot;num1&quot; type&#x3D;&quot;number&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第2个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input name&#x3D;&quot;num2&quot; type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;button form-type&#x3D;&quot;submit&quot;&gt;比较&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;比较结果：&#123;&#123;result&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>在上述代码中，form组件的bindsubmit属性用于绑定表单提交事件。在表单中，为两个input组件加上name属性，表单提交时就会自动收集带有name属性的组件的值。button按钮添加了form-type属性，值为submit表示该按钮用于提交表单，此外，还可以设为reset表示重置表单。</p><p>接下来在pages/index/index.js文件中编写formCompare()函数，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">formCompare:function(e)</span><br><span class="line">  &#123;</span><br><span class="line">    var str&#x3D;&#39;相等&#39;</span><br><span class="line">    var num1&#x3D;Number(e.detail.value.num1)</span><br><span class="line">    var num2&#x3D;Number(e.detail.value.num2)</span><br><span class="line">    if(num1&gt;num2)</span><br><span class="line">    &#123;</span><br><span class="line">      str&#x3D;&#39;第1个数大&#39;</span><br><span class="line">    &#125;else if(num1&lt;num2)</span><br><span class="line">    &#123;</span><br><span class="line">      str&#x3D;&#39;第2个数大&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setData(&#123;result:str&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，通过e.detail.value获取表单中的值，获取后比较即可</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;在小程序中实现两个数值的大小比较，可以通过逻辑判断和页面展示来实现。功能的实现有多种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为两个input组件绑定不同事件处理函数&lt;/li&gt;
&lt;li&gt;为两个input组件绑定相同事件处理函数&lt;/li&gt;
&lt;li&gt;在页面中直接进行比较&lt;/li&gt;
&lt;li&gt;通过条件渲染显示不同结果&lt;/li&gt;
&lt;li&gt;通过表单获取input组件的值&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——比较数字大小-注册程序(2.1.6)</title>
    <link href="http://pgzxc.github.io/posts/cc82f582.html"/>
    <id>http://pgzxc.github.io/posts/cc82f582.html</id>
    <published>2020-10-23T14:48:06.000Z</published>
    <updated>2020-10-29T15:37:35.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>若要在小程序启动、显示、隐藏时执行某些操作，可以通过App()函数来实现。</li><li>App()函数用于注册小程序，它接受一个对象参数，通过参数指定小程序的声明周期回调等。</li><li>App()函数必须在app.js中调用，且只能调用一次，不然会出现无法预期的后果</li></ul><a id="more"></a><h2 id="二-App函数"><a href="#二-App函数" class="headerlink" title="二 App函数"></a>二 App函数</h2><h3 id="2-1-函数"><a href="#2-1-函数" class="headerlink" title="2.1 函数"></a>2.1 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onLaunch: function (options) &#123;</span><br><span class="line">    console.log(&#39;onLaunch执行&#39;)</span><br><span class="line">    console.log(options)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 当小程序启动，或从后台进入前台显示，会触发 onShow</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onShow: function (options) &#123;</span><br><span class="line">    console.log(&#39;onShow执行&#39;)</span><br><span class="line">    console.log(options)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 当小程序从前台进入后台，会触发 onHide</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onHide: function () &#123;</span><br><span class="line">    console.log(&#39;onHide执行&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onError: function (error) &#123;</span><br><span class="line">    console.log(&#39;onError执行&#39;)</span><br><span class="line">    console.log(error) </span><br><span class="line">  &#125;,</span><br><span class="line">  onPageNotFound:function(options)</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(&#39;options执行&#39;)</span><br><span class="line">    console.log(error) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行程序，在控制台中查看输出结果<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-app-start-view.png" loading="lazy"></p><h3 id="2-2-程序输出说明"><a href="#2-2-程序输出说明" class="headerlink" title="2.2 程序输出说明"></a>2.2 程序输出说明</h3><ul><li>path：打开小程序的路径，一般情况下是app.json中的第一个路径，也可以通过自定义编译条件指定启动页面</li><li>query：打开小程序的query，一般情况下是空对象，也可以通过自定义编译条件指定启动参数</li><li>scene：打开小程序的场景值，一般情况下是1001，也可以通过自定义编译条件指定进入场景</li><li>shareTicket：当小程序被转发出去时(如群发到群聊)，如果此转发卡被其它用户打卡，可以获取到shareTicket(如群的标识)。通常搭配wx.showShareMenu()使用，并且需要在该方法的参数对象中设置withShareTicket为true</li><li>referrerInfo：当场景为从另一个小程序、公众号或APP打开时，可以通过它获取来源于小程序、公众号的AppId等，scene为1037或1038时支持传递附加数据</li></ul><h2 id="三-实例"><a href="#三-实例" class="headerlink" title="三 实例"></a>三 实例</h2><p>值得一提的是，利用App()函数还可以保存一些在所有页面中共享的数据，下面通过代码演示，在app.js中，为App()函数的参数对象增加一些属性和方法，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  num:123,</span><br><span class="line">  test:function()</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(&#39;test&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在pages/index/index.js的onReady函数中编写代码，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onReady: function () &#123;</span><br><span class="line">var app&#x3D;getApp()</span><br><span class="line">console.log(app.num)</span><br><span class="line">app.test()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在上述代码中，getApp()函数用于获取小程序App实例，获取后即可访问app.js中定义的num属性和test()方法</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;若要在小程序启动、显示、隐藏时执行某些操作，可以通过App()函数来实现。&lt;/li&gt;
&lt;li&gt;App()函数用于注册小程序，它接受一个对象参数，通过参数指定小程序的声明周期回调等。&lt;/li&gt;
&lt;li&gt;App()函数必须在app.js中调用，且只能调用一次，不然会出现无法预期的后果&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——比较数字大小-页面逻辑(2.1.5)</title>
    <link href="http://pgzxc.github.io/posts/6a61941.html"/>
    <id>http://pgzxc.github.io/posts/6a61941.html</id>
    <published>2020-10-23T14:46:59.000Z</published>
    <updated>2020-10-29T15:37:35.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在项目中，pages/index/index.js文件用于编写页面逻辑，打开该文件，会看到里面已经保存了一些代码，这些代码是微信开发者工具自动生成的，具体代码如下</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; pages&#x2F;index&#x2F;index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 页面的初始数据</span><br><span class="line">   *&#x2F;</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onLoad: function (options) &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面初次渲染完成</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onReady: function () &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面显示</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onShow: function () &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面隐藏</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onHide: function () &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面卸载</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onUnload: function () &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 页面相关事件处理函数--监听用户下拉动作</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onPullDownRefresh: function () &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 页面上拉触底事件的处理函数</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onReachBottom: function () &#123;&#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 用户点击右上角分享</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onShareAppMessage: function () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述代码中，Page()函数用来注册一个页面，该函数的参数是一个对象，通过该对象可以指定页面的初始数据、生命周期函数、事件处理函数等，具体说明如下表：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">data</td><td align="center">Object</td><td align="center">页面的初始数据</td></tr><tr><td align="center">onLoad</td><td align="center">Function</td><td align="center">生命周期回调函数，监听页面加载</td></tr><tr><td align="center">onReady</td><td align="center">Function</td><td align="center">生命周期回调函数，监听页面初次渲染完成</td></tr><tr><td align="center">onShow</td><td align="center">Function</td><td align="center">生命周期回调函数，监听页面显示</td></tr><tr><td align="center">onHide</td><td align="center">Function</td><td align="center">声明周期回调函数，监听页面隐藏</td></tr><tr><td align="center">onUpload</td><td align="center">Function</td><td align="center">生命周期回调函数，监听页面卸载</td></tr><tr><td align="center">onPullDownRefresh</td><td align="center">Function</td><td align="center">页面事件处理函数，页面下拉动作</td></tr><tr><td align="center">onReachBottom</td><td align="center">Function</td><td align="center">页面事件处理函数，页面上拉触底</td></tr><tr><td align="center">onShareAppMessage</td><td align="center">Function</td><td align="center">页面事件处理函数，用户点击右上角的分享按钮</td></tr><tr><td align="center">onPageScroll</td><td align="center">Function</td><td align="center">页面事件处理函数，页面滚动会连续触发</td></tr><tr><td align="center">其他</td><td align="center">Any</td><td align="center">开发者可以添加任意的函数或者数据，在页面的函数中通过this.*来访问</td></tr></tbody></table><p>data的作用将会在后面进行讲解，接下来将针对声明周期函数，页面事件处理函数、组件事件处理函数的使用分别进行演示。</p><h2 id="二-Function函数"><a href="#二-Function函数" class="headerlink" title="二 Function函数"></a>二 Function函数</h2><h3 id="2-1-声明周期回调函数"><a href="#2-1-声明周期回调函数" class="headerlink" title="2.1 声明周期回调函数"></a>2.1 声明周期回调函数</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>下面以onLoad、onReady、onShow函数为例进行演示，在pages/index/index.js中找到这三个函数，通过console.log()输出调试信息，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">  console.log(&#39;页面加载&#39;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 生命周期函数--监听页面初次渲染完成</span><br><span class="line"> *&#x2F;</span><br><span class="line">onReady: function () &#123;</span><br><span class="line">  console.log(&#39;页面初次渲染完成&#39;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 生命周期函数--监听页面显示</span><br><span class="line"> *&#x2F;</span><br><span class="line">onShow: function () &#123;</span><br><span class="line">  console.log(&#39;页面显示&#39;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>保存上述代码后，在控制台中可以看到输出结果，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-function-log.png" loading="lazy"></p><p>从上图可以看出，这3个函数的执行顺序为onLoad——&gt;onShow——&gt;onReady</p><h4 id="回调函数说明"><a href="#回调函数说明" class="headerlink" title="回调函数说明"></a>回调函数说明</h4><p>接下来针对生命周期回调函数的区别进行分析，具体如下：</p><ul><li>onLoad：页面加载时触发，一个页面只会调用一次。通过参数options可以获取打开当前页面路径中的参数</li><li>onReady：页面初次渲染完成的时候调用。一个页面只会调用一次，代表页面已经准备妥当，此时可以与视图层进行交互</li><li>onShow：当页面显示时触发。例如，从后台切入前台时触发</li><li>onHide：当页面隐藏时触发。例如，从前台切入后台时触发</li><li>onUnLoad：当页面卸载时触发。例如，使用路由API中的wx.redirectTo()或wx.navigateBack()跳转其他页面时触发</li></ul><h4 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h4><p>在小程序的导航栏中，页面标题的右边有两个按钮，即“...”和“◎”。单击“...”会在底部弹出一个菜单，在菜单中有一项&quot;转发&quot;，单击转发就会触发onShareAppMessage事件。单击&quot;◎&quot;可以在前台、后台之间切换，通过此按钮可以测试onShow和OnHide事件，单击后会弹出一个“查找场景值”的菜单，通过场景值可以感知用户的使用场景，如1001表示&quot;发现栏小程序主入口&quot;</p><h4 id="页面说明"><a href="#页面说明" class="headerlink" title="页面说明"></a>页面说明</h4><p>在onLoad函数中，有一个参数options，表示打开当前页面路径中的参数，它可以在当前页面被其它页面打开的情况下接收一些参数。例如，在ap.json中添加一个测试页面pages/test/test，然后在pages/index/index.js的onReady函数中编写代码，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onReady: function () &#123;</span><br><span class="line">  console.log(&#39;页面初次渲染完成&#39;)</span><br><span class="line">  wx.navigateTo(&#123;</span><br><span class="line">    url: &#39;&#x2F;pages&#x2F;test&#x2F;test?name1&#x3D;value1&amp;name2&#x3D;value2&#39;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>上述代码用于当onReady函数执行时，通过wx.navigateTo()方法打开一个新页面，在该方法的参数中，url表示要打开的页面路径。在/pages/test/test的右边，可以添加类似于URL中的查询字符串?name1=value1&amp;name2=value2，表示传递名称为name1和name2的参数，对应的值分别为value1和value2</p><p>在pages/test/test.js的onLoad函数中输出options参数的值，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">   console.log(options)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>查看控制台中的输出结果，可以看到{name1:&quot;value1&quot;,name2:&quot;value2&quot;}，说明当前页面成功接收到了参数</p><h3 id="2-2-页面事件处理函数"><a href="#2-2-页面事件处理函数" class="headerlink" title="2.2 页面事件处理函数"></a>2.2 页面事件处理函数</h3><p>下面以onPullDownRefresh、onReachBottom、onPageScroll函数为例进行演示，其中,onPullDownRefresh需要在配置文件中将enablePullDownRefresh设为true才会有效，onReachBottom需要在配置文件中将onReachBottomDistance设为true才会有效。由于开发者工具没有自动生成onPageScroll函数，因此需要手动添加该函数，并且为了使该函数触发还需要确保页面的内容高度超过了显示区域，使页面中出现滚动条。</p><p>下面在pages/index/index.js中使用这3个页面处理函数，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onPullDownRefresh: function () &#123;</span><br><span class="line"> console.log(&#39;此时用户下拉触发&#39;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 页面上拉触底事件的处理函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">onReachBottom: function () &#123;</span><br><span class="line">  console.log(&#39;此时用户上拉触底&#39;)</span><br><span class="line">&#125;,</span><br><span class="line">onPageScroll:function(options)</span><br><span class="line">&#123;</span><br><span class="line">  console.log(&#39;此时用户正在滚动页面&#39;)</span><br><span class="line">  console.log(&#39;滚动距离：&#39;+options.scrollTop)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>添加上述代码后，读者可以在pages/index/index.wxml中多添加一些内容出现滚动条，然后通过拉动页面触发函数，观察运行结果</p><h3 id="2-3-页面事件处理函数"><a href="#2-3-页面事件处理函数" class="headerlink" title="2.3 页面事件处理函数"></a>2.3 页面事件处理函数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>组件事件处理函数用于为组件绑定事件，例如，在pages/index/index.wxml文件中给button组件绑定tap事件，事件处理函数为compare，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bindtap&#x3D;&quot;compare&quot;&gt;比较&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>在pages/index/index.js中增加compare函数，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  compare:function(e)</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(&#39;compare&#39;)</span><br><span class="line">    console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述代码中，函数的参数e表示事件对象，通过它可以获取事件发生时的一些相关信息。运行程序，单击&quot;比较&quot;按钮，查看控制台中的输出结果</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-button-log.png" loading="lazy"></p><p>从上图可以看出，通过事件对象e，可以获取type(事件类型)、timestamp(事件生成时的时间戳)、target(触发事件的组件的一些属性值集合)、currentTarget(当前事件的一些属性值集合)、detail(额外的信息)等信息</p><h4 id="对比e-target和e-currentTarget"><a href="#对比e-target和e-currentTarget" class="headerlink" title="对比e.target和e.currentTarget"></a>对比e.target和e.currentTarget</h4><p>对于初学者来说，可能无法理解事件对象中的e.target和e.currentTarget的区别，下面通过代码来演示。在pages/index/index.wxml文件中添加如下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view bindtap&#x3D;&quot;viewtap&quot; id&#x3D;&quot;outer&quot;&gt;</span><br><span class="line">outer</span><br><span class="line">&lt;view id&#x3D;&quot;inner&quot;&gt;inner&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>添加代码后，页面中就会出现outer和inner，父元素outer绑定了viewtap事件，而子元素没有绑定，但由于子元素是父元素的一部分，因此单击子元素也会触发viewtap事件。</p><p>接下来在pages/index/index.js文件中添加viewtap函数，具体代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewtap:function(e)</span><br><span class="line">&#123;</span><br><span class="line">   console.log(e.target.id+&quot;-&quot;+e.currentTarget.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，使用e.target.id或e.currentTarget.id可以获取发生事件的组件的id，由于outer和inner的id不同，就可以区分这两个组件。</p><p>运行程序测试，当单击outer时，控制台中的输出结果为outer-outer，而单击inner时，控制台中的输出结果为inner-outer。由此可见，e.target获取到的是子元素的属性值集合，而e.currentTarget获取到的是父元素的属性值集合。</p><h4 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h4><p>通过前面的学习可知，小程序中有明确的视图层和逻辑层的划分，视图层使用WXML和WXSS编写，由组件来进行展示；逻辑层使用JavaScript编写，但由于小程序并非运行在浏览器环境中，不能使用BOM和DOM。前面使用的tap事件是视图层中的事件之一，通过这类事件可以实现以视图层到逻辑层的通信。</p><p>在视图层中，组件可以绑定多种事件，常用事件如下表：</p><table><thead><tr><th align="center">事件类型</th><th align="center">触发条件</th></tr></thead><tbody><tr><td align="center">touchstart</td><td align="center">手指触摸动作开始</td></tr><tr><td align="center">touchmove</td><td align="center">手指触摸后移动</td></tr><tr><td align="center">touchcancel</td><td align="center">手指触发动作被打断，如来电提醒、弹窗</td></tr><tr><td align="center">touchend</td><td align="center">手指触摸动作结束</td></tr><tr><td align="center">tap</td><td align="center">手指触摸后马上离开</td></tr><tr><td align="center">longpress</td><td align="center">手指触摸后，超过35Cms再离开。如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td></tr></tbody></table><p>值得一提的是，上表中列举的事件属于冒泡事件。冒泡事件是指当一个组件上的事件被触发后，事件会向父节点传递，而非冒泡事件不会向父节点传递。另外，除了表中列举的事件之外，一些组件还拥有一些专门的事件，如form组件的submit事件、input组件的input事件等</p><h4 id="事件绑定和冒泡"><a href="#事件绑定和冒泡" class="headerlink" title="事件绑定和冒泡"></a>事件绑定和冒泡</h4><p>在为组件绑定事件时，有两种方式，分别是&quot;bind事件类型&quot;和&quot;catch事件类型&quot;(以下简称为bind和catch)。bind方式在前面已经用过，如bindtap，它的特点是不会阻止冒泡事件向上冒泡，而catch可以阻止冒泡事件向上冒泡。下面通过代码对比它们的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;view bindtap&#x3D;&quot;outerTap&quot;&gt;</span><br><span class="line">outer</span><br><span class="line">&lt;view catchtap&#x3D;&quot;middleTap&quot;&gt;</span><br><span class="line">  middle</span><br><span class="line">&lt;view bindtap&#x3D;&quot;innerTap&quot;&gt;</span><br><span class="line">  inner</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果单击inner，会先后触发innerTap和middleTap，由于middletap使用catch阻止了事件冒泡，因此不会执行outerTap。同理，如果单击middle，则只会触发middleTap。如果单击outer，则只会触发outerTap</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;在项目中，pages/index/index.js文件用于编写页面逻辑，打开该文件，会看到里面已经保存了一些代码，这些代码是微信开发者工具自动生成的，具体代码如下&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——比较数字大小-配置文件(2.1.4)</title>
    <link href="http://pgzxc.github.io/posts/cc011891.html"/>
    <id>http://pgzxc.github.io/posts/cc011891.html</id>
    <published>2020-10-23T14:46:02.000Z</published>
    <updated>2020-10-29T15:37:35.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>小程序的每一个页面均可以使用json文件对页面的效果进行配置。页面配置分为页面级和应用级，在本项目中，pages/index/index.json是页面级配置文件，而app.json是应用级配置文件</p><a id="more"></a><h2 id="二-页面级配置文件"><a href="#二-页面级配置文件" class="headerlink" title="二 页面级配置文件"></a>二 页面级配置文件</h2><p>在页面级配置文件中可以更改页面的导航样式，控制页面是否允许上下滚动等。下面通过表2-5列举常用的页面级配置</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">navigationBarBackgroundColor</td><td align="center">导航栏背景颜色，默认为#000000</td></tr><tr><td align="center">navigationBarTextStyle</td><td align="center">导航栏标题颜色，仅支持black、white(默认)</td></tr><tr><td align="center">navigationBarTitleText</td><td align="center">导航栏的标题文字内容</td></tr><tr><td align="center">backgroundColor</td><td align="center">窗口的背景色，默认为#ffffff</td></tr><tr><td align="center">backgroundTextStyle</td><td align="center">下拉loading的样式，仅支持dark(默认)、light</td></tr><tr><td align="center">enablePullDownRefresh</td><td align="center">是否全局开启下拉刷新，默认为false</td></tr><tr><td align="center">onReachBottomDistance</td><td align="center">页面上拉触底时页面底部距离(单位为px)，默认为50</td></tr><tr><td align="center">disableScrol</td><td align="center">默认为false。设置为true时，页面整体不能上下移动</td></tr></tbody></table><p>在上表中，若将enablePullDownRefresh设为true，页面可以下拉刷新，当下拉刷新操作执行时，就会触发下拉刷新时间onPushDownRefresh，在pages/index/index.js文件中可以找到该事件的处理函数。</p><p>onReachBottomDistance主要用于开发自动加载更多的功能，也就是页面中的内容非常长的时候，为了加快加载速度，并不是一次性加载所有的数据，而是先加载一部分数据将页面填满，直到出现滚动条，页面可以向上滚动。当用户上拉时，如果快要到达底部了，就立即加载后面的数据。因此，onReachBottomDistance的值越大，加载的时机越提前。如果达到了给定的值，就会触发上拉触底事件onReachBottom，在pages/index/indes.s文件中可以找到该事件的处理函数。</p><p>接下来演示页面级配置的使用，打开pages/index/index.json文件，编写代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;navigationBarTitleText&quot;: &quot;数值比较&quot;,</span><br><span class="line">  &quot;navigationBarBackgroundColor&quot;: &quot;#369&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码设置了导航栏标题为&quot;数值比较&quot;，颜色为蓝色。运行结果为：</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-appjson-navigation.png" loading="lazy"></p><h2 id="三-应用级配置文件"><a href="#三-应用级配置文件" class="headerlink" title="三 应用级配置文件"></a>三 应用级配置文件</h2><p>项目根目录下app.json就是应用级配置文件，其常用配置如下表：</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pages</td><td align="center">页面路径列表</td></tr><tr><td align="center">window</td><td align="center">全局的默认窗口表现</td></tr><tr><td align="center">tabBar</td><td align="center">底部tab栏的表现</td></tr><tr><td align="center">networkTimeOut</td><td align="center">网络超时时间</td></tr><tr><td align="center">debug</td><td align="center">是否开启调试模式，默认为false</td></tr><tr><td align="center">requireBackgroundModes</td><td align="center">需要在后台使用的能力，如音乐播放</td></tr><tr><td align="center">plugins</td><td align="center">使用到的插件</td></tr></tbody></table><p>在上述属性中，pages在前面已经用过；window的值是一个对象，可以将表中的配置写在window中，作为应用级配置使用，从而一次设置多个页面，且优先级低于页面级配置；tabBar、plugins和requiredBackgroundModes会在后面的章节进行讲解；debug开启后可以在控制台中输出调试信息，帮助开发者快速定位到一些常见的问题。</p><p>networkTimeout可以设置网络请求过程中的超时时间，详细内容如下表：</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">request</td><td align="center">Number</td><td align="center">wx.request()的超时时间(ms)，默认为60000</td></tr><tr><td align="center">connectSocket</td><td align="center">Number</td><td align="center">wx.connectSocket()的超时时间(ms)，默认为6000</td></tr><tr><td align="center">uploadFile</td><td align="center">Number</td><td align="center">wx.uploadFile()的超时时间(ms)，默认为60000</td></tr><tr><td align="center">downloadFile</td><td align="center">Number</td><td align="center">wx.downloadFile()的超时时间(ms)，默认为6000</td></tr></tbody></table><p>在上表中，以wx.开头的是小程序中的API，如wx.request()用于发送网络请求，关于这些API的具体使用方法会在后面的章节中讲解</p><p>接下来演示应用级配置的使用，修改app.json文件，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;: [</span><br><span class="line">    &quot;pages&#x2F;index&#x2F;index&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;window&quot;: &#123;</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;数值比较&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#369&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;debug&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，navigationBarTitleText和navigationBarBackgroundColor配置了导航栏的标题和样式，如果将pages/index/index.json文件中的相同配置删除，则应用级配置会生效；debug开启了调试，运行程序后，会在控制台中输出调试信息。下图中可以看到小程序启动过程的信息</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-debug-console-info.png" loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;小程序的每一个页面均可以使用json文件对页面的效果进行配置。页面配置分为页面级和应用级，在本项目中，pages/index/index.json是页面级配置文件，而app.json是应用级配置文件&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——比较数字大小-页面样式(2.1.3)</title>
    <link href="http://pgzxc.github.io/posts/5f2bddd6.html"/>
    <id>http://pgzxc.github.io/posts/5f2bddd6.html</id>
    <published>2020-10-23T14:44:30.000Z</published>
    <updated>2020-10-29T15:37:35.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式。WXSS具有CSS大部分特性，并在CSS基础上做了一些扩充和修改。</p><a id="more"></a><h2 id="二-选择器"><a href="#二-选择器" class="headerlink" title="二 选择器"></a>二 选择器</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>WXSS支持使用选择器来为某个元素设置样式，其使用方法和CSS选择器基本相同，常用的选择器如下表：</p><table><thead><tr><th align="center">选择器</th><th align="center">示例</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.class</td><td align="center">.container</td><td align="center">选择所有class=&quot;container&quot;的组件</td></tr><tr><td align="center">#id</td><td align="center">#id</td><td align="center">选择id=&quot;#id&quot;的组件</td></tr><tr><td align="center">element</td><td align="center">view</td><td align="center">选择所有view组件</td></tr><tr><td align="center">element,element</td><td align="center">view,text</td><td align="center">选择所有view组件和所有text组件</td></tr><tr><td align="center">::after</td><td align="center">view::after</td><td align="center">在view组件内容的后面插入内容</td></tr><tr><td align="center">::before</td><td align="center">view::before</td><td align="center">在view组件内容的前面插入内容</td></tr></tbody></table><h3 id="2-2-选择器的使用"><a href="#2-2-选择器的使用" class="headerlink" title="2.2 选择器的使用"></a>2.2 选择器的使用</h3><p>接下来演示element、.class和::after选择器的使用，其他选择器的使用类似</p><h4 id="2-2-1-element选择器"><a href="#2-2-1-element选择器" class="headerlink" title="2.2.1 element选择器"></a>2.2.1 element选择器</h4><p>在pages/index/index.wxss文件中为view组件设置样式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">view</span><br><span class="line">&#123;</span><br><span class="line">  margin: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行后，就会为view组件设置上、下、左、右外边距，皆为20px</p><p>值得一提的是，在WXML中可以直接通过标签的style属性设置样式，相当于网页中的行内样式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;view style&#x3D;&quot;margin:20px&quot;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-class选择器"><a href="#2-2-2-class选择器" class="headerlink" title="2.2.2 .class选择器"></a>2.2.2 .class选择器</h4><p>在用.class选择器前，需要先给标签加上class属性，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><p>在pages/index/index.wxss文件中编写样式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container</span><br><span class="line">&#123;</span><br><span class="line">margin:20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-after选择器"><a href="#2-2-3-after选择器" class="headerlink" title="2.2.3 ::after选择器"></a>2.2.3 ::after选择器</h4><p>在pages/index/index.wxss文件中编写样式，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">view::after</span><br><span class="line">&#123;</span><br><span class="line">  content:&#39;测试&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码运行后，会在view组件内的后面插入&quot;测试&quot;文本</p><h2 id="三-尺寸单位"><a href="#三-尺寸单位" class="headerlink" title="三 尺寸单位"></a>三 尺寸单位</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>在使用CSS进行移动端的网页开发时，由于不同手机设备的屏幕有不同的宽度和设备像素比，在换算像素单位时会遇到很多麻烦。为了方便开发人员适配各种手机屏幕，微信小程序在WXSS中加入了新的尺寸单位rpx(responsive pixel，响应式像素)</p><p>移动端网页像素单位的换算难点在于它有物理像素和逻辑像素两种单位，物理像素是指屏幕上实际有多少个像素，而逻辑像素是指在CSS中使用的像素单位。例如，iPhone 6手机的物理分辨率为750pxX1334px，逻辑分别率为375pxX667px，经过换算可知，1个逻辑像素需要2x2个物理像素来显示</p><h3 id="3-2-尺寸换算"><a href="#3-2-尺寸换算" class="headerlink" title="3.2 尺寸换算"></a>3.2 尺寸换算</h3><p>为了方便换算，rpx单位规定了任何手机屏幕的宽度都为750rpx(逻辑像素)，由小程序内部负责将逻辑像素转换为当前手机中的物理像素。也就是说，在绘制设计图时，按照750px的宽度进行绘制，然后在小程序中使用rpx为单位，就无需担心不同手机之间宽度不同的问题了。下面列举了不同手机rpx与px的换算方式</p><table><thead><tr><th align="center">设备</th><th align="center">屏幕宽度(px)</th><th align="center">rpx换算px(屏幕宽度/750)</th><th align="center">px换算rpx(750/屏幕宽度)</th></tr></thead><tbody><tr><td align="center">iphone 5</td><td align="center">320</td><td align="center">1rpx~0.42px</td><td align="center">1px~2.34rpx</td></tr><tr><td align="center">iphone 6</td><td align="center">375</td><td align="center">1rpx=0.5px</td><td align="center">1px=2rpx</td></tr><tr><td align="center">iphone 6 Plus</td><td align="center">414</td><td align="center">1rpx~0.552px</td><td align="center">1px~1.81rpx</td></tr></tbody></table><h3 id="3-3-尺寸修改"><a href="#3-3-尺寸修改" class="headerlink" title="3.3 尺寸修改"></a>3.3 尺寸修改</h3><p>为了更直观地对比WXSS中的rpx与px这两种单位的区别，下面通过代码进行演示，在pages/index/index.wxss文件中编写样式，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">view</span><br><span class="line">&#123;</span><br><span class="line">  margin: 50rpx;</span><br><span class="line">&#125;</span><br><span class="line">input</span><br><span class="line">&#123;</span><br><span class="line">   width: 600rpx;</span><br><span class="line">   margin-top:20rpx;</span><br><span class="line">   border-bottom: 2rpx solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">button</span><br><span class="line">&#123;</span><br><span class="line">   margin: 50rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存上述代码后，在模拟器中切换iPhone 5 和iPhone 6，对比这两个设备上的显示效果，可以看到非常接近</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-chicun-iphone5-6-compare-view.png" loading="lazy"></p><p>接下来将input组件的宽度改为px单位，也就是将原来的600rpx改为300px，从而对比px单位在不同设备上的差异，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input</span><br><span class="line">&#123;</span><br><span class="line">   width: 300px;&#x2F;*此处将原来的600rpx改为300px *&#x2F;</span><br><span class="line">   margin-top:20rpx;</span><br><span class="line">   border-bottom: 2rpx solid #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存上述代码后，再次对比iPhone 5和iPhone 6的显示效果，可以看到input组件在iPhone6中与之前的600rpx效果一样，而iPhone5中出现了问题，宽度已经延伸到了最右边</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-chicun-rpx-px-diff-after.png" loading="lazy"></p><h2 id="四-样式导入"><a href="#四-样式导入" class="headerlink" title="四 样式导入"></a>四 样式导入</h2><p>在WXSS中可以使用@import语句导入外联样式表，在@import后面写上需要导入的外联样式表的路径即可，用“;”表示语句结束。下面样式@import的使用</p><p>首先在pages/index目录下创建test.wxss文件，作为外联的样式表，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button</span><br><span class="line">&#123;</span><br><span class="line">  color:#fff;</span><br><span class="line">  background: #369;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在index.wxss文件中导入test.wxss文件，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;test.wxss&quot;;</span><br></pre></td></tr></table></figure><p>上述代码表示导入目前目录下的test.wxss文件</p><p>保存代码后，运行程序，可以看到button组件的样式发生了改变，说明test.wxss文件导入成功</p><h2 id="五-全局样式"><a href="#五-全局样式" class="headerlink" title="五 全局样式"></a>五 全局样式</h2><p>当编写了多个页面，多个页面经常会有一些相同的样式，如果在每一个页面样式文件中都编写重复的代码，会给修改和维护带来不便。因此，可以在项目根目录下创建全局样式文件app.wxss，将公共的样式写在全局样式文件中。下面演示全局样式的使用</p><p>创建app.wxss文件，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button</span><br><span class="line">&#123;</span><br><span class="line">  letter-spacing: 12rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在index.wxss文件中导入app.wxss文件，具体代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;..&#x2F;..&#x2F;app.wxss&quot;;</span><br></pre></td></tr></table></figure><p>运行程序，可以看到字符的间距发生了改变，说明全局样式生效</p><p>值得一提的是，当公共样式文件(app.wxss)和页面样式文件(pages/index/index.wxss)发生样式冲突时，页面的样式的优先级高，会覆盖功能样式</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;WXSS(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式。WXSS具有CSS大部分特性，并在CSS基础上做了一些扩充和修改。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——UITabBarController-Storyboard(62)</title>
    <link href="http://pgzxc.github.io/posts/b85fd741.html"/>
    <id>http://pgzxc.github.io/posts/b85fd741.html</id>
    <published>2020-10-21T15:35:12.000Z</published>
    <updated>2020-10-29T15:37:34.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>上一篇文章介绍如何通过代码创建UITabBarController，本文主要介绍</p><ul><li>如何使用Storyboard创建UITabBarController</li><li>如何添加ViewController</li><li>给BarItem设置Badge,Title,Image,Selected Image</li></ul><a id="more"></a><h2 id="二-如何通过storyboard创建UITabBarController"><a href="#二-如何通过storyboard创建UITabBarController" class="headerlink" title="二 如何通过storyboard创建UITabBarController"></a>二 如何通过storyboard创建UITabBarController</h2><ul><li><p>新创建一个项目，并将Main.storyboard中默认的ViewController删除<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-uitabbar-viewcontroller-delete-mainstory-view.png" loading="lazy"></p></li><li><p>点击Xcode右上方的“+”，从下拉组件中，选择TabBarController(默认带两个Controller)<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-uitabbar-viewcontroller-add-tabbar.png" loading="lazy"></p></li><li><p>将页面缩放到指定大小，另外添加2个ViewController<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-tabbar-viewcontroller-add-controller.png" loading="lazy"></p></li><li><p>在UITabBarController上右键，找到右方的“+”号，链接到另外的两个ViewController上<br>  <img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-tabbar-viewcontroller-connect-viewcontroller.png" loading="lazy"></p></li><li><p>确认项目右侧的“Is Initial VIew Controller”是否勾选<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-tabbar-viewcontroller-isinitial-select.png" loading="lazy"></p></li><li><p>点击ViewController中的BarItem分别设置Badge,Title,Image,Selected Image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Badge:消息数</span><br><span class="line">Title:标题</span><br><span class="line">Image:未选中时图片</span><br><span class="line">Selected Image：选中时图片</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-tabbar-viewcontroller-baritem-setting.png" loading="lazy"></p></li></ul><h2 id="三-效果图"><a href="#三-效果图" class="headerlink" title="三 效果图"></a>三 效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-uitabbar-viewcontroller-storyboard-view.gif" loading="lazy"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;上一篇文章介绍如何通过代码创建UITabBarController，本文主要介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用Storyboard创建UITabBarController&lt;/li&gt;
&lt;li&gt;如何添加ViewController&lt;/li&gt;
&lt;li&gt;给BarItem设置Badge,Title,Image,Selected Image&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="移动开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="IOS" scheme="http://pgzxc.github.io/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——UITabBarController空项目(61)</title>
    <link href="http://pgzxc.github.io/posts/8bd5a825.html"/>
    <id>http://pgzxc.github.io/posts/8bd5a825.html</id>
    <published>2020-10-19T15:49:15.000Z</published>
    <updated>2020-10-29T15:37:34.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>跟UINavigationController类似，UITabBarController也可以轻松地管理多个控制器，轻松完成控制器之间的切换，典型的例子就是QQ、微信等应用</p><a id="more"></a><h2 id="二-UITabBarController的简单实用"><a href="#二-UITabBarController的简单实用" class="headerlink" title="二 UITabBarController的简单实用"></a>二 UITabBarController的简单实用</h2><h3 id="2-1-UITabBarController的使用步骤"><a href="#2-1-UITabBarController的使用步骤" class="headerlink" title="2.1 UITabBarController的使用步骤"></a>2.1 UITabBarController的使用步骤</h3><ul><li><p>初始化UITabBarController</p></li><li><p>设置UIWindow的rootViewController为UITabBarController</p></li><li><p>根据具体情况，通过addChildViewController方法添加对应个数的子控制器</p><h3 id="2-2-UITabBar"><a href="#2-2-UITabBar" class="headerlink" title="2.2 UITabBar"></a>2.2 UITabBar</h3></li><li><p>如果UITabBarController有N个子控制器，那么UITabBar内部就会有N个UITabBarButton作为子控件</p></li><li><p>如果UITabBarController有4个子控制器，那么UITabBar的结构大致如下图</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-uitablebar-uitabbarbutton-relate.png" loading="lazy"></p><h3 id="2-3-UITabBarButton"><a href="#2-3-UITabBarButton" class="headerlink" title="2.3 UITabBarButton"></a>2.3 UITabBarButton</h3></li><li><p>UITabBarButton里面显示什么内容，由对应子控制器的tabBarItem属性决定</p></li><li><p>UITabBarItem有以下属性影响着UITabBarButton的内容：</p><ul><li>标题文字：@property(nonatomic,copy) NSString *title;</li><li>图标：@property(nonatomic,retain) UIImage *image;</li><li>选中时的图标：@property(nonatomic,retain) UIImage *selectedImage;</li><li>提醒数字：@property(nonatomic,copy) NSString *badgeValue;</li></ul></li></ul><h3 id="2-4-在何处初始化UITabBarController"><a href="#2-4-在何处初始化UITabBarController" class="headerlink" title="2.4 在何处初始化UITabBarController"></a>2.4 在何处初始化UITabBarController</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>之前在AppDelegate.m中的didFinishLaunchingWithOptions方法初始</li><li>Xcode11之后，在SceneDelegate.m中初始化</li></ul><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>Xcode 11 建新工程默认会创建通过 UIScene 管理多个 UIWindow 的应用，工程中除了 AppDelegate 外还会有一个 SceneDelegate，这是为了实现iPadOS支持多窗口的结果</li><li>AppDelegate.h不再有window属性，window属性被定义在了SceneDelegate.h中，AppDelegate中有新增的关于scene的代理方法，SceneDelegate中也有相应的代理方法</li></ul><h2 id="三-代码-SceneDelegate-m—-gt-willConnectToSession方法"><a href="#三-代码-SceneDelegate-m—-gt-willConnectToSession方法" class="headerlink" title="三 代码(SceneDelegate.m—&gt;willConnectToSession方法)"></a>三 代码(SceneDelegate.m—&gt;willConnectToSession方法)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    UITabBarController *tb&#x3D;[[UITabBarController alloc]init];</span><br><span class="line">    &#x2F;&#x2F;设置控制器为Window的根控制器</span><br><span class="line">    self.window.rootViewController&#x3D;tb;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;b.创建子控制器</span><br><span class="line">    UIViewController *c1&#x3D;[[UIViewController alloc]init];</span><br><span class="line">    c1.view.backgroundColor&#x3D;[UIColor grayColor];</span><br><span class="line">    c1.view.backgroundColor&#x3D;[UIColor greenColor];</span><br><span class="line">    c1.tabBarItem.title&#x3D;@&quot;消息&quot;;</span><br><span class="line">    c1.tabBarItem.image&#x3D;[UIImage imageNamed:@&quot;tab_recent_nor&quot;];</span><br><span class="line">    c1.tabBarItem.selectedImage&#x3D;[UIImage imageNamed:@&quot;tab_recent_select&quot;];</span><br><span class="line">    c1.tabBarItem.badgeValue&#x3D;@&quot;123&quot;;</span><br><span class="line">    </span><br><span class="line">    UIViewController *c2&#x3D;[[UIViewController alloc]init];</span><br><span class="line">    c2.view.backgroundColor&#x3D;[UIColor brownColor];</span><br><span class="line">    c2.tabBarItem.title&#x3D;@&quot;联系人&quot;;</span><br><span class="line">    c2.tabBarItem.image&#x3D;[UIImage imageNamed:@&quot;tab_buddy_nor&quot;];</span><br><span class="line">    c2.tabBarItem.selectedImage&#x3D;[UIImage imageNamed:@&quot;tab_buddy_select&quot;];</span><br><span class="line">    </span><br><span class="line">    UIViewController *c3&#x3D;[[UIViewController alloc]init];</span><br><span class="line">    c3.view.backgroundColor&#x3D;[UIColor greenColor];</span><br><span class="line">    c3.tabBarItem.title&#x3D;@&quot;动态&quot;;</span><br><span class="line">    c3.tabBarItem.image&#x3D;[UIImage imageNamed:@&quot;tab_qworld_nor&quot;];</span><br><span class="line">    c3.tabBarItem.selectedImage&#x3D;[UIImage imageNamed:@&quot;tab_qworld_select&quot;];</span><br><span class="line">    </span><br><span class="line">    UIViewController *c4&#x3D;[[UIViewController alloc]init];</span><br><span class="line">    c4.view.backgroundColor&#x3D;[UIColor blueColor];</span><br><span class="line">    c4.tabBarItem.title&#x3D;@&quot;设置&quot;;</span><br><span class="line">    c4.tabBarItem.image&#x3D;[UIImage imageNamed:@&quot;tab_me_nor&quot;];</span><br><span class="line">    c4.tabBarItem.selectedImage&#x3D;[UIImage imageNamed:@&quot;tab_me_select&quot;];</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;c.添加子控制器到ITabBarController中</span><br><span class="line">    &#x2F;&#x2F;c.1第一种方式</span><br><span class="line">&#x2F;&#x2F;    [tb addChildViewController:c1];</span><br><span class="line">&#x2F;&#x2F;    [tb addChildViewController:c2];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;c.2第二种方式</span><br><span class="line">    tb.viewControllers&#x3D;@[c1,c2,c3,c4];</span><br></pre></td></tr></table></figure><h2 id="四-效果图"><a href="#四-效果图" class="headerlink" title="四 效果图"></a>四 效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-uitabbar-controller-yanshi.gif" loading="lazy"></p><h2 id="五-参考"><a href="#五-参考" class="headerlink" title="五 参考"></a>五 参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82ZDY1NzNmYmQ2MGI=">Xcode11 新建工程中的SceneDelegate<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;跟UINavigationController类似，UITabBarController也可以轻松地管理多个控制器，轻松完成控制器之间的切换，典型的例子就是QQ、微信等应用&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="移动开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="IOS" scheme="http://pgzxc.github.io/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——私人通讯录编辑样式(60)</title>
    <link href="http://pgzxc.github.io/posts/68b4dce2.html"/>
    <id>http://pgzxc.github.io/posts/68b4dce2.html</id>
    <published>2020-10-17T15:46:45.000Z</published>
    <updated>2020-10-29T15:37:34.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本文主要介绍一下内容：</p><ul><li>导航条右侧(已有添加按钮)添加一个删除按钮</li><li>点击删除按钮，删除tableview条目</li><li>tableview编辑之前调用，切换tableview中编辑模式(添加、删除模式)</li></ul><a id="more"></a><h2 id="二-效果图"><a href="#二-效果图" class="headerlink" title="二 效果图"></a>二 效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-sirentongxunlu-baritem-delete.gif" loading="lazy"></p><h2 id="三-导航条右侧-已有添加按钮-添加一个删除按钮"><a href="#三-导航条右侧-已有添加按钮-添加一个删除按钮" class="headerlink" title="三 导航条右侧(已有添加按钮)添加一个删除按钮"></a>三 导航条右侧(已有添加按钮)添加一个删除按钮</h2><h3 id="3-1-通过Main-storyboard添加"><a href="#3-1-通过Main-storyboard添加" class="headerlink" title="3.1 通过Main.storyboard添加"></a>3.1 通过Main.storyboard添加</h3><ul><li><p>点击Xcode上方的“+”，选择BarButtonItem，System item选择Trash</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-ios/ios-xirentongxunlu-baritem-trash-add-mainstorey.png" loading="lazy"></p></li></ul><h3 id="3-2-通过代码添加"><a href="#3-2-通过代码添加" class="headerlink" title="3.2 通过代码添加"></a>3.2 通过代码添加</h3><h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><ul><li>现获取布局中的“add”按钮</li><li>通过代码新建一个“delete”按钮</li><li>通过avigationItem.rightBarButtonItems将上面的两个按钮添加进来</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取+按钮</span><br><span class="line">UIBarButtonItem *add&#x3D;self.navigationItem.rightBarButtonItem;</span><br><span class="line">   </span><br><span class="line">&#x2F;&#x2F;添加一个垃圾箱按钮</span><br><span class="line">UIBarButtonItem *trash&#x3D;[[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemTrash    target:self action:@selector(delete)];</span><br><span class="line">self.navigationItem.rightBarButtonItems&#x3D;@[add,trash];</span><br></pre></td></tr></table></figure><h2 id="四-点击删除按钮，删除tableview条目"><a href="#四-点击删除按钮，删除tableview条目" class="headerlink" title="四 点击删除按钮，删除tableview条目"></a>四 点击删除按钮，删除tableview条目</h2><h3 id="4-1-逻辑说明"><a href="#4-1-逻辑说明" class="headerlink" title="4.1 逻辑说明"></a>4.1 逻辑说明</h3><ul><li>给tableview设置编辑模式，点击删除按钮时，切换tableview的编辑模式</li><li>当编辑模式为删除时，会调用到commitEditingStyle方法更新数据和布局的操作</li></ul><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><h4 id="delete方法"><a href="#delete方法" class="headerlink" title="delete方法"></a>delete方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.tableView setEditing:!self.tableView.editing animated:YES];</span><br></pre></td></tr></table></figure><h4 id="commitEditingStyle"><a href="#commitEditingStyle" class="headerlink" title="commitEditingStyle"></a>commitEditingStyle</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除数据</span><br><span class="line">[self.contacts removeObjectAtIndex:indexPath.row];</span><br><span class="line">&#x2F;&#x2F;刷新界面</span><br><span class="line">&#x2F;&#x2F;[self.tableView reloadData];&#x2F;&#x2F;全局刷新</span><br><span class="line">[self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];&#x2F;&#x2F;删除局部</span><br></pre></td></tr></table></figure><h2 id="五-切换tableview中编辑模式-添加、删除模式"><a href="#五-切换tableview中编辑模式-添加、删除模式" class="headerlink" title="五 切换tableview中编辑模式(添加、删除模式)"></a>五 切换tableview中编辑模式(添加、删除模式)</h2><h3 id="5-1-逻辑说明"><a href="#5-1-逻辑说明" class="headerlink" title="5.1 逻辑说明"></a>5.1 逻辑说明</h3><ul><li>tableview在编辑之前会调用editingStyleForRowAtIndexPath方法，可以给tableview中的条目设置样式</li><li>如条目0位UITableViewCellEditingStyleInsert，其他为UITableViewCellEditingStyleDelete</li><li>给相应的样式，添加对应的功能</li></ul><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><h4 id="editingStyleForRowAtIndexPath"><a href="#editingStyleForRowAtIndexPath" class="headerlink" title="editingStyleForRowAtIndexPath"></a>editingStyleForRowAtIndexPath</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    if (indexPath.row&#x3D;&#x3D;0) &#123;</span><br><span class="line">        return UITableViewCellEditingStyleInsert;</span><br><span class="line">    &#125;</span><br><span class="line">    return UITableViewCellEditingStyleDelete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UITableViewCellEditingStyleInsert"><a href="#UITableViewCellEditingStyleInsert" class="headerlink" title="UITableViewCellEditingStyleInsert"></a>UITableViewCellEditingStyleInsert</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Contact *contact&#x3D;[Contact contactWithName:@&quot;grace&quot; phone:@&quot;123&quot;];</span><br><span class="line">&#x2F;&#x2F;[self.contacts addObject:contact];&#x2F;&#x2F;添加到最后一行</span><br><span class="line">[self.contacts insertObject:contact atIndex:indexPath.row+1];</span><br><span class="line">[self.tableView reloadData];</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本文主要介绍一下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导航条右侧(已有添加按钮)添加一个删除按钮&lt;/li&gt;
&lt;li&gt;点击删除按钮，删除tableview条目&lt;/li&gt;
&lt;li&gt;tableview编辑之前调用，切换tableview中编辑模式(添加、删除模式)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="移动开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="IOS" scheme="http://pgzxc.github.io/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——比较数字大小-页面组件(2.1.2)</title>
    <link href="http://pgzxc.github.io/posts/4a8b5010.html"/>
    <id>http://pgzxc.github.io/posts/4a8b5010.html</id>
    <published>2020-10-16T14:44:38.000Z</published>
    <updated>2020-10-29T15:37:35.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ul><li>小程序使用WXML(WeiXin Markup Language)来实现页面的结构</li><li>例如，&lt;view&gt;标签用于定义试图容器，与HTML中的&lt;div&gt;标签的作用类似。</li><li>除此之外，小程序中还有很多类似的标签，用于创建页面组件</li></ul><a id="more"></a><h2 id="二-常见的页面组件"><a href="#二-常见的页面组件" class="headerlink" title="二 常见的页面组件"></a>二 常见的页面组件</h2><table><thead><tr><th align="center">标签</th><th align="center">功能</th><th align="center">标签</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&lt;view&gt;</td><td align="center">试图容器</td><td align="center">&lt;icon&gt;</td><td align="center">图标文件</td></tr><tr><td align="center">&lt;text&gt;</td><td align="center">文本域</td><td align="center">&lt;checkbox&gt;</td><td align="center">复选框</td></tr><tr><td align="center">&lt;button&gt;</td><td align="center">按钮</td><td align="center">&lt;radio&gt;</td><td align="center">单选框</td></tr><tr><td align="center">&lt;image&gt;</td><td align="center">图片</td><td align="center">&lt;input&gt;</td><td align="center">输入框</td></tr><tr><td align="center">&lt;form&gt;</td><td align="center">表单</td><td align="center">&lt;progress&gt;</td><td align="center">进度条</td></tr></tbody></table><h2 id="三-常用组件的使用"><a href="#三-常用组件的使用" class="headerlink" title="三 常用组件的使用"></a>三 常用组件的使用</h2><h3 id="3-1-wxml页面的代码结构"><a href="#3-1-wxml页面的代码结构" class="headerlink" title="3.1 wxml页面的代码结构"></a>3.1 wxml页面的代码结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第1个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;请输入第2个数字：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;number&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;button&gt;比较&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text&gt;比较结果：&lt;&#x2F;text&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-代码说明"><a href="#3-2-代码说明" class="headerlink" title="3.2 代码说明"></a>3.2 代码说明</h3><ul><li><p>上述代码中，&lt;view&gt;和text属于双边标签，由开始标签和结束标签两部分构成，&lt;input&gt;属于单边标签，只有开始标签，且结尾用&quot;/&gt;&quot;表示。值得一提的是，&lt;input&gt;也可以写成双边标签，如&lt;input&gt;&lt;/input&gt;</p></li><li><p>第2、6、11行将文本写在了&lt;text&gt;标签中，表示一段文本。实际上，&lt;view&gt;标签内可以写入文本，如&lt;view&gt;文本&lt;/view&gt;，但多行文本在显示时没有换行效果，而&lt;text&gt;标签内的文本可以换行。另外，在&lt;text&gt;标签中，还可以嵌套&lt;text&gt;标签，例如，将一段文本中的某些字改变字体颜色，就可以给这些字加上&lt;text&gt;标签，从而单独设置样式</p></li><li><p>第3、7行的&lt;input&gt;标签的type属性表示输入的类型，如文本、数字、身份证等，有多个可选值</p><table><thead><tr><th align="center">可选值</th><th align="center">说明</th><th align="center">默认</th></tr></thead><tbody><tr><td align="center">text</td><td align="center">文本输入键盘</td><td align="center">√</td></tr><tr><td align="center">number</td><td align="center">数字输入键盘</td><td align="center">—</td></tr><tr><td align="center">idcard</td><td align="center">身份证输入键盘</td><td align="center">—</td></tr><tr><td align="center">digit</td><td align="center">带小数点的数字键盘</td><td align="center">—</td></tr></tbody></table></li><li><p>图中的input组件显示为空白，这是因为它的默认样式没有任何边框，显示效果与HTML中的文本框不同。单击input组件，会看到光标闪烁，此时就可以输入内容了</p></li></ul><h2 id="四-页面结构"><a href="#四-页面结构" class="headerlink" title="四 页面结构"></a>四 页面结构</h2><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-struct.png" loading="lazy"></p><ul><li>从图中可以看出，index.wxml中的代码被包裹在了&lt;page&gt;标签中。&lt;page&gt;标签是最外层的标签，它是一个根节点，用户编写的所有结构代码都在根节点的下面</li></ul><h2 id="五-预览错误及解决办法"><a href="#五-预览错误及解决办法" class="headerlink" title="五 预览错误及解决办法"></a>五 预览错误及解决办法</h2><ul><li><p>接下来单击微信开发者工具中的&quot;预览&quot;按钮，程序会提示缺少app.js文件</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-preview-app-error.png" loading="lazy"></p></li><li><p>在项目目录中创建该文件，文件内容为空即可，然后再次单击&quot;预览&quot;按钮，会得到一个二维码。使用手机中的微信扫描该二维码，在手机中预览程序</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-appjs-build.png" loading="lazy"></p></li><li><p>单击input组件后，下方弹出的输入法是数字键盘。如果把input组件的type属性更改为文本，则会弹出标准键盘，可以输入中文或英文字符</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;小程序使用WXML(WeiXin Markup Language)来实现页面的结构&lt;/li&gt;
&lt;li&gt;例如，&amp;lt;view&amp;gt;标签用于定义试图容器，与HTML中的&amp;lt;div&amp;gt;标签的作用类似。&lt;/li&gt;
&lt;li&gt;除此之外，小程序中还有很多类似的标签，用于创建页面组件&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——比较数字大小-创建项目(2.1.1)</title>
    <link href="http://pgzxc.github.io/posts/61a603d3.html"/>
    <id>http://pgzxc.github.io/posts/61a603d3.html</id>
    <published>2020-10-16T14:42:54.000Z</published>
    <updated>2020-10-29T15:37:35.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本文通过比较数字大小的案例，来学习小程序中的一些基础知识，包括页面组件、页面样式、页面逻辑的编写，了解配置文件中常见配置的含义，利用事件、数据绑定、条件渲染、表单等方式实现小程序的页面交互</p><a id="more"></a><h2 id="二-创建项目"><a href="#二-创建项目" class="headerlink" title="二 创建项目"></a>二 创建项目</h2><h3 id="2-1-小程序开发语言选择"><a href="#2-1-小程序开发语言选择" class="headerlink" title="2.1 小程序开发语言选择"></a>2.1 小程序开发语言选择</h3><p>小程序的开发语言有：JavaScript和Typescript</p><ul><li>JavaScript：简称js，文件后缀名是.js，是一种轻量级的解释性脚本语言</li><li>Typescript：简称ts，文件后缀名是.ts，是微软开发和维护的一款面向对象的编程语言。它是 JavaScript 的超集，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，并扩展了 JavaScript 的语法。</li></ul><h3 id="2-2-创建项目"><a href="#2-2-创建项目" class="headerlink" title="2.2 创建项目"></a>2.2 创建项目</h3><ul><li><p>打开微信开发者工具，依次点击：项目——&gt;新建项目打开新建项目对话框(语言选择JavaScript)<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-create-info.png" loading="lazy"></p></li><li><p>填写新建项目信息后，进入项目将除<code>project.config.json</code>的文件全部删除，点击“+”添加app.json文件<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-delete-files.png" loading="lazy"></p></li><li><p>app.json创建后，文件中添加如下代码，新增一个index页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;:[</span><br><span class="line">    &quot;pages&#x2F;index&#x2F;index&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按Ctrl+S保存文件后，开发者工具会自动创建pages/index目录和index.js、index.json、index.wxml、index.wxss这4个文件<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-compare-page-ctrl-s-process.png" loading="lazy"></p></li><li><p>模拟器显示信息<br>模拟器预览结果显示的页面路径为pages/index/index.wxml，打开该文件，即可查看或编辑该文件中的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages&#x2F;index&#x2F;index.wxml--&gt;</span><br><span class="line">&lt;text&gt;pages&#x2F;index&#x2F;index.wxml&lt;&#x2F;text&gt;</span><br></pre></td></tr></table></figure><h2 id="三-参考"><a href="#三-参考" class="headerlink" title="三 参考"></a>三 参考</h2></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI1NDIxMTk2">TypeScript 和 JavaScript 的区别？-知乎<i class="fa fa-external-link-alt"></i></span> </p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFuZ3ppYW5hbi9wLzg0MDMzMzIuaHRt">Typescript 和 Javascript之间的区别-博客园<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本文通过比较数字大小的案例，来学习小程序中的一些基础知识，包括页面组件、页面样式、页面逻辑的编写，了解配置文件中常见配置的含义，利用事件、数据绑定、条件渲染、表单等方式实现小程序的页面交互&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——项目设置(1.9)</title>
    <link href="http://pgzxc.github.io/posts/e608439c.html"/>
    <id>http://pgzxc.github.io/posts/e608439c.html</id>
    <published>2020-10-15T15:06:06.000Z</published>
    <updated>2020-10-29T15:37:35.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本文主要介绍项目设置，包含以下内容：</p><ul><li>如何打开项目设置</li><li>项目设置中设置的具体含义</li></ul><a id="more"></a><h2 id="二-如何打开项目设置"><a href="#二-如何打开项目设置" class="headerlink" title="二 如何打开项目设置"></a>二 如何打开项目设置</h2><ol><li>执行菜单栏中的：“设置”——&gt;“项目设置”命令</li><li>工具栏上的详情(右侧)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-detail-view.png" loading="lazy"></p><h2 id="三-项目设置中设置的具体含义"><a href="#三-项目设置中设置的具体含义" class="headerlink" title="三 项目设置中设置的具体含义"></a>三 项目设置中设置的具体含义</h2><ul><li>项目设置：对当前的项目进行设置</li><li>域名信息：显示小程序的安全域名信息，合法域名可在管理后台进行设置</li><li>调试基础库：选择基础库版本，用于在对应版本的微信客户端上运行。高版本的基础库无法兼容低版本的微信客户端。右侧的77.25%表示该版本的用户占比</li><li>ES6转ES5：将JavaScript代码的ES6语法转换为ES5语法</li><li>上传代码时样式自动补全：自动检测并补全缺失样式</li><li>上传代码时自动压缩：压缩代码，缩小代码体积</li><li>使用npm模块：在小程序中使用npm安装第三方包</li><li>启用自定义处理命令：指定编译前、预览前、上传前需要预处理的命令</li><li>不校验合法域名、web-view(业务域名)、TLS版本以及HTTPS证书：在真实环境中会对这些信息进行校验，如果在开发环境中不进行校验，可选中此项</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本文主要介绍项目设置，包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何打开项目设置&lt;/li&gt;
&lt;li&gt;项目设置中设置的具体含义&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——目录结构(1.8)</title>
    <link href="http://pgzxc.github.io/posts/46b8f90f.html"/>
    <id>http://pgzxc.github.io/posts/46b8f90f.html</id>
    <published>2020-10-15T15:05:04.000Z</published>
    <updated>2020-10-29T15:37:35.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本文以Hello World为例，讲解</p><ul><li>小程序的目录结构</li><li>小程序的文件组成</li></ul><a id="more"></a><h2 id="二-小程序的目录结构"><a href="#二-小程序的目录结构" class="headerlink" title="二 小程序的目录结构"></a>二 小程序的目录结构</h2><table><thead><tr><th align="center">路径</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">project.config.json</td><td align="center">项目配置文件</td></tr><tr><td align="center">app.js</td><td align="center">应用程序的逻辑文件</td></tr><tr><td align="center">app.json</td><td align="center">应用程序的配置文件</td></tr><tr><td align="center">app.wxss</td><td align="center">应用的程序的公共样式文件</td></tr><tr><td align="center">pages/</td><td align="center">存储页面文件的目录</td></tr><tr><td align="center">pages/index/</td><td align="center">存放index页面的目录</td></tr><tr><td align="center">pages/index/index.js</td><td align="center">index页面的逻辑文件</td></tr><tr><td align="center">pages/index/index.wxml</td><td align="center">index页面的结构文件</td></tr><tr><td align="center">pages/index/index.wxss</td><td align="center">index页面的样式文件</td></tr><tr><td align="center">pages/logs/</td><td align="center">存放logs页面的目录</td></tr><tr><td align="center">pages/logs/logs.js</td><td align="center">logs页面的逻辑文件</td></tr><tr><td align="center">pages/logs/logs.json</td><td align="center">logs页面的配置文件</td></tr><tr><td align="center">pages/logs/logs.wxml</td><td align="center">logs页面的结构文件</td></tr><tr><td align="center">pages/logs/logs.wxss</td><td align="center">logs页面的样式文件</td></tr><tr><td align="center">utils/</td><td align="center">存放公共脚本文件的目录</td></tr><tr><td align="center">utils/utils.js</td><td align="center">公共脚本文件，保存一些工具代码</td></tr></tbody></table><p>上表中，小程序一共有两个页面，分别是page/index(首页)和pages/logs(登录日志页)。首页就是之前在模拟器中看到的页面，在该页面中单击“获取头像”按钮，获取后会显示当前登录用户的微信头像，单击头像即可进入登入日志页，查看用户登录的历史记录</p><h2 id="三-小程序的组成"><a href="#三-小程序的组成" class="headerlink" title="三 小程序的组成"></a>三 小程序的组成</h2><p>在微信小程序中，每个页面由wxml、wxss、js和json文件组成，其中wxml和js文件必须存在，wxss和json文件可以省略。wxml和wxss文件类似于网页开发中的html和css文件，但是他们有所区别</p><h2 id="四-页面间的关系"><a href="#四-页面间的关系" class="headerlink" title="四 页面间的关系"></a>四 页面间的关系</h2><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-struct.png" loading="lazy"></p><h3 id="4-1-app-json"><a href="#4-1-app-json" class="headerlink" title="4.1 app.json"></a>4.1 app.json</h3><p>对于有一定编程功底的读者，可以通过阅读代码来分析页面之间的关系。首先打开app.json文件，在文件中找到如下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;:[</span><br><span class="line">    &quot;pages&#x2F;index&#x2F;index&quot;,</span><br><span class="line">    &quot;pages&#x2F;logs&#x2F;logs&quot;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，pages开头的表示页面路径，例如，pages/index/index表示pages/index目录下的index.*文件。由于一个页面由多个不同扩展名的文件组成，这里是把它们看成一个整体，因此无须加上扩展名。此处定义了两个页面，分别是Index和log，顺序排在前面的index将作为小程序打开后的初始页面</p><h3 id="4-2-pages-index-index-wxml"><a href="#4-2-pages-index-index-wxml" class="headerlink" title="4.2 pages/index/index.wxml"></a>4.2 pages/index/index.wxml</h3><p>接下来打开pages/index/index.wxml，查看小程序首页的结构，找到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;view class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;userinfo&quot;&gt;</span><br><span class="line">    &lt;button wx:if&#x3D;&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot; open-type&#x3D;&quot;getUserInfo&quot; bindgetuserinfo&#x3D;&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;block wx:else&gt;</span><br><span class="line">      &lt;image bindtap&#x3D;&quot;bindViewTap&quot; class&#x3D;&quot;userinfo-avatar&quot; src&#x3D;&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; mode&#x3D;&quot;cover&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;text class&#x3D;&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">    &lt;&#x2F;block&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;usermotto&quot;&gt;</span><br><span class="line">    &lt;text class&#x3D;&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，&lt;image&gt;标签用于显示用户头像，该标签的属性bindtap表示当用户单击该组件时，执行相应的事件处理函数，即bingViewTap。因此，当用户单击头像时，就会执行bingViewTap函数。</p><p>在pages/index/index.js中找到bindViewTap事件处理函数的代码，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;事件处理函数</span><br><span class="line">bindViewTap: function() &#123;</span><br><span class="line">  wx.navigateTo(&#123;</span><br><span class="line">    url: &#39;..&#x2F;logs&#x2F;logs&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在上述代码中，wx.navigateTo()方法用于跳转页面，从url行代码尅看出，程序会跳转到logs页面，从而实现了单击头像跳转到登录日志页面的效果</p><h3 id="4-3-logs-logs"><a href="#4-3-logs-logs" class="headerlink" title="4.3 ../logs/logs"></a>4.3 ../logs/logs</h3><p>打开logs页面的逻辑文件pages/logs/logs.js，可以看到该页面引用了utils/utils.js脚本文件，如下所示。这个脚本文件用于保存公共代码，从而在不同页面中引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;logs.js</span><br><span class="line">const util &#x3D; require(&#39;..&#x2F;..&#x2F;utils&#x2F;util.js&#39;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本文以Hello World为例，讲解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小程序的目录结构&lt;/li&gt;
&lt;li&gt;小程序的文件组成&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——开发者工具介绍(1.7)</title>
    <link href="http://pgzxc.github.io/posts/5739b87.html"/>
    <id>http://pgzxc.github.io/posts/5739b87.html</id>
    <published>2020-10-15T15:03:47.000Z</published>
    <updated>2020-10-29T15:37:35.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>本文主要对小程序开发工具进行简单介绍：</p><ul><li>界面布局</li><li>菜单栏/工具栏</li><li>模拟器</li><li>编辑器</li><li>调试器</li></ul><a id="more"></a><h2 id="二-界面布局"><a href="#二-界面布局" class="headerlink" title="二 界面布局"></a>二 界面布局</h2><p>小程序项目创建成功后，会自动进入开发调试环境，从图中可以看出，微信开发者工具的主界面主要由菜单栏、工具栏、模拟器、编辑器和调试器组成。接下来对这些功能分别进行讲解</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-tools-layout.png" loading="lazy"></p><h2 id="三-菜单栏"><a href="#三-菜单栏" class="headerlink" title="三 菜单栏"></a>三 菜单栏</h2><p>通过菜单栏可以访问微信开发者工具的大部分功能，常用的菜单如下：</p><ul><li>项目：用于新建项目，或打开一个现有的项目</li><li>文件：用于新建文件、保存文件或关闭文件</li><li>编辑：用于编辑代码，对代码进行格式化</li><li>工具：用于访问一些辅助工具，如自动化测试、代码仓库等</li><li>界面：用于控制界面中各部分的显示和隐藏</li><li>设置：用于对外观、快捷键、编辑器等进行设置</li><li>微信开发者工具：可以进行切换账号、更换开发模式、调试等操作</li></ul><h2 id="四-工具栏"><a href="#四-工具栏" class="headerlink" title="四 工具栏"></a>四 工具栏</h2><p>工具栏提供了一些常用功能的快捷按钮，具体解释如下：</p><ul><li>个人中心：位于工具栏最左边的第一个按钮，显示当前登录用户的用户名、头像</li><li>模拟器、编辑器和调试器：用于控制相应工具的显示和隐藏</li><li>云开发：开发者可以使用云开发来开发小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发能力从基础库2.2.3开始支持</li><li>模式切换下拉菜单：用于在小程序模式、搜索动态页和插件之间进行切换</li><li>编译下拉菜单：用于切换编译模式，默认为普通编译，可以添加其他编译模式</li><li>编译：编写小程序的代码后，需要编译才能运行。默认情况下，直接按Ctrl+S快捷键保存代码文件，微信开发者工具就会自动编译运行。若要手动编译，则单击“编译”按钮即可</li><li>预览：单击“预览”按钮会生成一个二维码，使用手机中的微信扫码二维码，即可在微信中预览小程序的实际运行效果</li><li>真机调试：可以实现直接利用开发者工具，通过网络连接对手机上运行的小程序进行调试，帮助开发者更好地定位和查找在手机上出现的问题</li><li>切后台：用于模拟小程序在手机中切后台的效果</li><li>清缓存：用于将代码上传到小程序管理后台，可以在“开发管理”中查看上传的版本，将代码提交审核。需要注意的是，如果在创建项目时使用AppID为测试号，则不会显示“上传”按钮</li><li>版本管理：用于通过Git对小程序进行版本管理</li></ul><h2 id="五-模拟器"><a href="#五-模拟器" class="headerlink" title="五 模拟器"></a>五 模拟器</h2><p>模拟器用于模拟手机环境，查看不同型号手机的运行效果</p><p><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-tools-simulator.png" loading="lazy"></p><p>图中，上方的iPhone 12 5表示手机型号，单击可以切换成其他手机。由于不同手机屏幕的CSS像素不同，宽高比也不同，在开发小程序时应对常见的手机屏幕进行适配。100%表示缩放百分比，可以调节预览画面的大小。WIFI表示网络环境，还可以切换成2G、3G、4G或Offline(离线)，不同环境的网速不同，从而可以测试小程序的网络加载速度。模拟器的底部状态栏显示了当前的页面路径为/pages/index/index</p><h2 id="六-编辑器"><a href="#六-编辑器" class="headerlink" title="六 编辑器"></a>六 编辑器</h2><p>编辑器分为左右两栏，左栏用于浏览项目目录结构，右栏用于编写代码。在左栏中单击某个文件，就可以在右栏中对改文件进行编辑。</p><h2 id="七-调试器"><a href="#七-调试器" class="headerlink" title="七 调试器"></a>七 调试器</h2><p>调试器类似于Google Chrome浏览器中的开发者工具。下面对调试器中的各个面板的功能进行简要介绍。</p><ul><li>Console：“控制台”面板，用于输出调试信息，也可以直接编写代码执行</li><li>Source：“源代码”面板，可以查看或编辑源代码，并支持代码调试</li><li>Network：“安全”面板，用于调试页面的安全和认证等信息，如HTTPS</li><li>AppData：“App数据”面板，可以查看或编辑当前小程序运行时的数据</li><li>Audits：“审计”面板，用于对小程序进行体验评分</li><li>Sensor：“传感器”面板，用于模拟地理位置、重力感应</li><li>Storage：“存储”面板，用于查看和管理本地数据缓存</li><li>Trace：“跟踪”面板，用于真机调试时跟踪调试信息</li><li>Wxml：Wxml面板，用于查看和调试WXML和WXSS</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;本文主要对小程序开发工具进行简单介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;界面布局&lt;/li&gt;
&lt;li&gt;菜单栏/工具栏&lt;/li&gt;
&lt;li&gt;模拟器&lt;/li&gt;
&lt;li&gt;编辑器&lt;/li&gt;
&lt;li&gt;调试器&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发之——创建项目(1.6)</title>
    <link href="http://pgzxc.github.io/posts/bb087157.html"/>
    <id>http://pgzxc.github.io/posts/bb087157.html</id>
    <published>2020-10-15T15:01:18.000Z</published>
    <updated>2020-10-29T15:37:35.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>使用微信开发者工具创建项目时，有以下几种项目可以创建：</p><h4 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h4><ul><li>小程序(小程序+插件)</li><li>小游戏(小游戏+小游戏性能优化方案)</li><li>代码片段(小程序+小游戏+插件+游戏性能优化方案)</li></ul><h4 id="公众号网页项目"><a href="#公众号网页项目" class="headerlink" title="公众号网页项目"></a>公众号网页项目</h4><ul><li>公众号网页</li></ul><a id="more"></a><h2 id="二-创建项目"><a href="#二-创建项目" class="headerlink" title="二 创建项目"></a>二 创建项目</h2><ul><li>首次打开微信开发者工具时，会出现一个登陆页，提示使用微信扫码登录。登录成功后，会看到如下页面<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-create-splash.png" loading="lazy"></li><li>依次单击：小程序项目——&gt;小程序，打开小程序新建和导入页面<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-create-import-view.png" loading="lazy"></li><li>登录到微信开发者管理后台后，依次点击：开发——&gt;开发设置，查看AppID(小程序ID)<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-create-appid-view.png" loading="lazy"></li><li>填写项目的名称，目录(存储位置)，AppID(注册的AppID或测试号)<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-create-infor-insert.png" loading="lazy"></li><li>点击下方的创建，项目创建完成后的界面如下图<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-create-finished.png" loading="lazy"><h2 id="三-导入项目"><a href="#三-导入项目" class="headerlink" title="三 导入项目"></a>三 导入项目</h2>切换到导入项目选项卡，点击目录，选择要导入的项目<br><img src="https://cdn.jsdelivr.net/gh/pgzxc/CDN/blog-wechat/wechat-project-import-select.png" loading="lazy"></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;p&gt;使用微信开发者工具创建项目时，有以下几种项目可以创建：&lt;/p&gt;
&lt;h4 id=&quot;小程序项目&quot;&gt;&lt;a href=&quot;#小程序项目&quot; class=&quot;headerlink&quot; title=&quot;小程序项目&quot;&gt;&lt;/a&gt;小程序项目&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;小程序(小程序+插件)&lt;/li&gt;
&lt;li&gt;小游戏(小游戏+小游戏性能优化方案)&lt;/li&gt;
&lt;li&gt;代码片段(小程序+小游戏+插件+游戏性能优化方案)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;公众号网页项目&quot;&gt;&lt;a href=&quot;#公众号网页项目&quot; class=&quot;headerlink&quot; title=&quot;公众号网页项目&quot;&gt;&lt;/a&gt;公众号网页项目&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;公众号网页&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="跨平台" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://pgzxc.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
