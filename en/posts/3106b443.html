<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/en/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon/favicon-64x64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon/favicon-32x32.png">
  <link rel="mask-icon" href="/en/images/favicon/favicon-64x64.png" color="#222">

<link rel="stylesheet" href="/en/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inconsolata:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pgzxc.github.io","root":"/en/","images":"/en/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"an-old-hope","dark":"an-old-hope"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Search...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/en/js/config.js" defer></script>

    <meta name="description" content="一 面试题汇总 你能提供一下 SOLID 原则的概述吗？ Dart 中 Object、dynamic 和 var 有何不同？ 什么是 Dart 中 cascade 级联和 extension 扩展运算？ mixin 混入和 interface 接口在 Dart 中有何不同？ Dart 中的空安全是什么？">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter面试题——面试题整理7">
<meta property="og:url" content="https://pgzxc.github.io/posts/3106b443.html">
<meta property="og:site_name" content="PGzxc (English)">
<meta property="og:description" content="一 面试题汇总 你能提供一下 SOLID 原则的概述吗？ Dart 中 Object、dynamic 和 var 有何不同？ 什么是 Dart 中 cascade 级联和 extension 扩展运算？ mixin 混入和 interface 接口在 Dart 中有何不同？ Dart 中的空安全是什么？">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-03-25T04:07:17.000Z">
<meta property="article:modified_time" content="2026-02-22T02:43:04.811Z">
<meta property="article:author" content="PGzxc">
<meta property="article:tag" content="Flutter面试题">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://pgzxc.github.io/posts/3106b443.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://pgzxc.github.io/posts/3106b443.html","path":"posts/3106b443.html","title":"Flutter面试题——面试题整理7"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Flutter面试题——面试题整理7 | PGzxc (English)</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="/en/js/utils.js" defer></script><script src="/en/js/motion.js" defer></script><script src="/en/js/sidebar.js" defer></script><script src="/en/js/next-boot.js" defer></script><script src="/en/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/en/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/en/js/third-party/tags/mermaid.js" defer></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/en/js/third-party/tags/wavedrom.js" defer></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/en/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/en/css/noscript.css">
  </noscript>
<link rel="alternate" href="/en/atom.xml" title="PGzxc (English)" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/en/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PGzxc (English)</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What I learn from books is superficial; I must experience it myself</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-bell fa-fw"></i>Home</a></li><li class="menu-item menu-item-nav"><a href="/en/navs/" rel="section"><i class="fa fa-bars fa-fw"></i>Navigation</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">275</span></a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">4492</span></a></li><li class="menu-item menu-item-links"><a href="/en/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Search..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Site Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB"><span class="nav-number">1.</span> <span class="nav-text">一 面试题汇总</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94-%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83"><span class="nav-number">2.</span> <span class="nav-text">二  面试题解答(仅供参考)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BD%A0%E8%83%BD%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%8B-SOLID-%E5%8E%9F%E5%88%99%E7%9A%84%E6%A6%82%E8%BF%B0%E5%90%97%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1  你能提供一下 SOLID 原则的概述吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Dart-%E4%B8%AD-Object%E3%80%81dynamic-%E5%92%8C-var-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Dart 中 Object、dynamic 和 var 有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BB%80%E4%B9%88%E6%98%AF-Dart-%E4%B8%AD-cascade-%E7%BA%A7%E8%81%94%E5%92%8C-extension-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">2.3  什么是 Dart 中 cascade 级联和 extension 扩展运算？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-mixin-%E6%B7%B7%E5%85%A5%E5%92%8C-interface-%E6%8E%A5%E5%8F%A3%E5%9C%A8-Dart-%E4%B8%AD%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 mixin 混入和 interface 接口在 Dart 中有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Dart-%E4%B8%AD%E7%9A%84%E7%A9%BA%E5%AE%89%E5%85%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 Dart 中的空安全是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A-Dart-%E4%B8%AD%E7%9A%84-Isolate%E3%80%81Event-Loop-%E5%92%8C-Future-%E7%9A%84%E6%A6%82%E5%BF%B5%E5%90%97%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 你能解释 Dart 中的 Isolate、Event Loop 和 Future 的概念吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-Flutter-%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%9C%89%E7%8A%B6%E6%80%81%E5%B0%8F%E9%83%A8%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A-setState-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 Flutter 无状态和有状态小部件之间有什么区别，以及 setState() 的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-Flutter-InheritedWidget-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 Flutter InheritedWidget 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-%E4%BD%A0%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%9C%A8-Flutter-%E4%B8%AD-keys-%E9%94%AE%E7%9A%84%E4%BD%9C%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 你能解释一下在 Flutter 中 keys 键的作用吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-%E5%9C%A8-Flutter-%E4%B8%AD%EF%BC%8CKeys%EF%BC%88%E9%94%AE%EF%BC%89%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 在 Flutter 中，Keys（键）有哪几种类型？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">三 参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PGzxc"
      src="/en/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">PGzxc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/en/archives/">
          <span class="site-state-item-count">4492</span>
          <span class="site-state-item-name">Posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/en/categories/">
        <span class="site-state-item-count">275</span>
        <span class="site-state-item-name">Categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/en/tags/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">Tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/calvin_zhou" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;calvin_zhou" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/5582039920" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;5582039920" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://www.jianshu.com/u/c5cdcb4dc52b" title="简书 → http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;c5cdcb4dc52b" rel="noopener me" target="_blank"><i class="fa fa-heartbeat fa-fw"></i></a>
      </span>
  </div>


<nav class="sidebar-nav" id="sidebar-nav">
  <ul class="sidebar-nav-menu">
        <li class="menu-item menu-item-home">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-nav">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-links">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
  </ul>
</nav>
        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pgzxc.github.io/posts/3106b443.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/en/images/avatar.jpg">
      <meta itemprop="name" content="PGzxc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PGzxc (English)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Flutter面试题——面试题整理7 | PGzxc (English)">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flutter面试题——面试题整理7<a href="https://github.com/PGzxc/PGzxc.github.io/edit/master/source/_posts/Flutter%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%867.md" class="post-edit-link" title="Edit" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created at:2024-03-25 12:07:17" itemprop="dateCreated datePublished" datetime="2024-03-25T12:07:17+08:00">2024-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/en/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">面试相关</span></a>
        </span>
          ,
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/en/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Flutter%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Flutter面试题</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>11 minutes</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一-面试题汇总"><a href="#一-面试题汇总" class="headerlink" title="一 面试题汇总"></a>一 面试题汇总</h2><ol>
<li>你能提供一下 SOLID 原则的概述吗？</li>
<li>Dart 中 Object、dynamic 和 var 有何不同？</li>
<li>什么是 Dart 中 cascade 级联和 extension 扩展运算？</li>
<li>mixin 混入和 interface 接口在 Dart 中有何不同？</li>
<li>Dart 中的空安全是什么？<span id="more"></span></li>
<li>你能解释 Dart 中的 Isolate、Event Loop 和 Future 的概念吗？</li>
<li>Flutter 无状态和有状态小部件之间有什么区别，以及 setState() 的作用是什么？</li>
<li>Flutter InheritedWidget 是什么？</li>
<li>你能解释一下在 Flutter 中 keys 键的作用吗？</li>
<li>在 Flutter 中，Keys（键）有哪几种类型？</li>
</ol>
<h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二  面试题解答(仅供参考)"></a>二  面试题解答(仅供参考)</h2><h3 id="2-1-你能提供一下-SOLID-原则的概述吗？"><a href="#2-1-你能提供一下-SOLID-原则的概述吗？" class="headerlink" title="2.1  你能提供一下 SOLID 原则的概述吗？"></a>2.1  你能提供一下 SOLID 原则的概述吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SOLID 原则是面向对象编程中一组设计原则，旨在帮助开发者编写可维护、可扩展、高质量的代码。</span><br><span class="line">它由五个主要原则组成，分别是：</span><br><span class="line"></span><br><span class="line">1. S -单一职责原则 (Single Responsibility Principle, SRP)</span><br><span class="line">-定义：每个类应该只有一个职责，也就是只负责一项功能。</span><br><span class="line">-目的：减少类的复杂度，避免类承担过多的职责。如果一个类承担了过多的职责，会使得它变得难以修改和扩展。</span><br><span class="line">-示例：如果一个类既负责数据存储，又负责数据的显示，那么它应该被拆分成两个类，一个负责存储，另一个负责显示。</span><br><span class="line"></span><br><span class="line">2. O - 开放/封闭原则 (Open/Closed Principle, OCP)</span><br><span class="line">-定义：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。</span><br><span class="line">-目的：在需要修改某个功能时，尽量避免修改现有的代码，而是通过扩展现有的类来实现新功能。</span><br><span class="line">-示例：通过继承或者接口实现功能扩展，而不是直接修改原有类的实现。</span><br><span class="line"></span><br><span class="line">3. L - 里氏替换原则 (Liskov Substitution Principle, LSP)</span><br><span class="line">-定义：子类对象应该能够替换父类对象，且程序的功能不受影响。</span><br><span class="line">-目的：确保继承关系的合理性，避免子类对父类行为的破坏。</span><br><span class="line">-示例：如果Bird是父类，而Penguin是继承自Bird的子类，那么Penguin不应该破坏Bird类的预期行为（如飞行能力）。</span><br><span class="line"></span><br><span class="line">4. I - 接口隔离原则 (Interface Segregation Principle, ISP)</span><br><span class="line">-定义：不应该强迫客户端依赖它不需要的接口。</span><br><span class="line">-目的：将大接口拆分成多个小接口，让实现类只需要关注自己需要的部分。</span><br><span class="line">-示例：一个类不应该实现它不需要的功能，如果一个类不需要某些方法，</span><br><span class="line">应该将这些方法分到不同的接口中，而不是让类去实现这些方法。</span><br><span class="line"></span><br><span class="line">5. D - 依赖倒置原则 (Dependency Inversion Principle, DIP)</span><br><span class="line">-定义：高层模块不应该依赖低层模块，二者应该依赖抽象（接口或抽象类）。</span><br><span class="line">具体实现应依赖于抽象，而不是依赖于具体类。</span><br><span class="line">-目的：降低模块之间的耦合度，提高系统的灵活性和可扩展性。</span><br><span class="line">-示例：一个依赖注入（DI）框架可以帮助实现依赖倒置，避免直接依赖于具体实现类，而是依赖于接口或抽象类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">SOLID 原则是面向对象设计中的核心理念，旨在通过合理划分职责、灵活扩展和依赖注入等方式，</span><br><span class="line">创建高内聚、低耦合的代码结构，提升代码的可维护性、可扩展性和可测试性。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Dart-中-Object、dynamic-和-var-有何不同？"><a href="#2-2-Dart-中-Object、dynamic-和-var-有何不同？" class="headerlink" title="2.2 Dart 中 Object、dynamic 和 var 有何不同？"></a>2.2 Dart 中 Object、dynamic 和 var 有何不同？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在 Dart 中，Object、dynamic 和 var 都涉及到类型的定义，但它们在类型检查和赋值时有着不同的行为和用途。</span><br><span class="line">下面是它们的区别</span><br><span class="line"></span><br><span class="line">1. Object</span><br><span class="line">-定义：Object 是 Dart 中所有类的基类，几乎所有的对象都是 Object 类型的子类。</span><br><span class="line">-类型检查：声明为 Object 的变量可以接受任何类型的对象（包括自定义类），但访问时只能使用 Object 类的方法。</span><br><span class="line">如果要调用特定类型的方法，必须进行类型转换。</span><br><span class="line">-使用场景：当你不确定变量的具体类型时，但又希望它是一个对象时，使用 Object。</span><br><span class="line">-示例</span><br><span class="line">Object obj = &#x27;Hello, Dart&#x27;;  // 这可以是任何类型</span><br><span class="line">print(obj.toString());       // 可以调用 Object 类的通用方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. dynamic</span><br><span class="line">-定义：dynamic 是 Dart 中的特殊类型，它表示一个可以动态改变类型的变量，表示完全没有静态类型检查的变量。</span><br><span class="line">-类型检查：dynamic 类型的变量可以赋任何类型的值，并且在编译时不会进行类型检查。</span><br><span class="line">类型检查会在运行时进行，这可能会导致运行时错误。</span><br><span class="line">-使用场景：当你希望一个变量能够接收任何类型的值，且不需要在编译时检查时使用。</span><br><span class="line">-示例</span><br><span class="line">dynamic obj = &#x27;Hello, Dart&#x27;; // 可以随时更改为其他类型</span><br><span class="line">obj = 123;                   // 可以赋值为不同的类型</span><br><span class="line">print(obj.length);           // 如果 obj 是 int 类型，会在运行时出错</span><br><span class="line"></span><br><span class="line">3. var</span><br><span class="line">-定义：var 是 Dart 中的一种声明变量的方式，它的类型会根据右侧赋值的类型自动推导出来。</span><br><span class="line">-类型检查：一旦给 var 赋值后，变量的类型就被固定了，不能再赋值为不同类型的值。</span><br><span class="line">它的类型由赋值时决定，所以相当于具有静态类型，但仍然需要在编译时进行类型推导。</span><br><span class="line">-使用场景：当你希望变量类型由编译器自动推导并且在之后不再改变时，使用 var</span><br><span class="line">-示例</span><br><span class="line">var name = &#x27;Dart&#x27;;  // 自动推导为 String 类型</span><br><span class="line">name = 123;         // 编译时错误，因为 name 被推导为 String 类型</span><br></pre></td></tr></table></figure>

<p>总结</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">定义</th>
<th align="center">类型检查</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Object</td>
<td align="center">所有类的基类，可以存储任何类型的对象</td>
<td align="center">可以存储任何类型的对象，但只能调用 <code>Object</code> 的方法。</td>
<td align="center">类型固定，无法直接调用其他类特有的方法，需类型转换。</td>
</tr>
<tr>
<td align="center">dynamic</td>
<td align="center">完全动态类型，可以存储任何类型的值，并且没有编译时类型检查。</td>
<td align="center">没有编译时类型检查，类型检查在运行时进行。</td>
<td align="center">允许任意类型，且没有类型安全，容易导致运行时错误。</td>
</tr>
<tr>
<td align="center">var</td>
<td align="center">类型由右侧赋值推导确定，一旦确定后不可更改</td>
<td align="center">类型由赋值推导，且不允许改变类型。</td>
<td align="center">类型自动推导，确保类型安全，但类型固定。</td>
</tr>
</tbody></table>
<h3 id="2-3-什么是-Dart-中-cascade-级联和-extension-扩展运算？"><a href="#2-3-什么是-Dart-中-cascade-级联和-extension-扩展运算？" class="headerlink" title="2.3  什么是 Dart 中 cascade 级联和 extension 扩展运算？"></a>2.3  什么是 Dart 中 cascade 级联和 extension 扩展运算？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">在 Dart 中，cascade（级联） 和 extension（扩展） 是两个用于提高代码可读性和简洁性的特性。</span><br><span class="line">它们各自有不同的用途，帮助你更有效地操作对象和扩展类功能。</span><br><span class="line"></span><br><span class="line">1. Cascade（级联运算符）</span><br><span class="line">-定义：级联运算符 .. 允许你在同一个对象上连续调用多个方法或设置多个属性，而无需重复写对象的名称。</span><br><span class="line">-作用：简化代码、减少重复，使得代码更加简洁和易读。</span><br><span class="line">-使用场景：当你需要对同一个对象执行多个操作时，使用级联可以让代码更加简洁</span><br><span class="line">-示例</span><br><span class="line">class Person &#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  Person(&#123;required this.name, required this.age&#125;);</span><br><span class="line"></span><br><span class="line">  void sayHello() &#123;</span><br><span class="line">    print(&#x27;Hello, my name is $name.&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void haveBirthday() &#123;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var person = Person(name: &#x27;John&#x27;, age: 30);</span><br><span class="line"></span><br><span class="line">  // 使用级联运算符</span><br><span class="line">  person</span><br><span class="line">    ..sayHello()        // 调用方法</span><br><span class="line">    ..haveBirthday()    // 调用方法</span><br><span class="line">    ..name = &#x27;Jane&#x27;;    // 设置属性</span><br><span class="line">  </span><br><span class="line">  print(&#x27;Updated name: $&#123;person.name&#125;, Age: $&#123;person.age&#125;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">解释：</span><br><span class="line">-使用 .. 级联运算符，可以在一个对象person上依次调用sayHello()和haveBirthday()，并修改name属性。</span><br><span class="line">-级联运算符帮助我们避免多次引用 person 对象，简化了代码。</span><br><span class="line"></span><br><span class="line">2. Extension（扩展运算符）</span><br><span class="line">-定义：扩展运算符 extension 允许你为现有类添加方法、getter、setter 或操作符，而无需修改类的原始代码。</span><br><span class="line">它可以让你在不改变原有类的情况下，扩展其功能。</span><br><span class="line">-作用：通过扩展现有类，使得该类可以拥有新的功能，符合开放/封闭原则，不修改原有类代码。</span><br><span class="line">-使用场景：当你需要为现有类添加额外的功能或方法，但不能直接修改该类的源代码时，可以使用扩展。</span><br><span class="line">-示例</span><br><span class="line">extension StringReversal on String &#123;</span><br><span class="line">  // 为 String 类型扩展一个 reverse 方法</span><br><span class="line">  String get reverse &#123;</span><br><span class="line">    return this.split(&#x27;&#x27;).reversed.join(&#x27;&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  String message = &#x27;Dart&#x27;;</span><br><span class="line"></span><br><span class="line">  // 使用扩展方法</span><br><span class="line">  print(message.reverse);  // 输出: traD</span><br><span class="line">&#125;</span><br><span class="line">解释：</span><br><span class="line">-通过extension StringReversal，我们为String类型添加了一个reverse方法，该方法返回字符串的反转结果。</span><br><span class="line">-扩展方法可以直接通过 . 运算符来调用，就像原生方法一样。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">定义</th>
<th align="center">用途</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cascade</td>
<td align="center">使用 <code>..</code> 运算符在同一对象上连续调用方法或设置属性</td>
<td align="center">提高代码简洁性，减少重复引用对象</td>
<td align="center">person..sayHello()..haveBirthday()..name &#x3D; &#39;Jane&#39;;</td>
</tr>
<tr>
<td align="center">Extension</td>
<td align="center">使用 <code>extension</code> 为现有类添加方法、属性等，而不修改原类代码</td>
<td align="center">扩展现有类的功能，符合开放&#x2F;封闭原则</td>
<td align="center">extension StringReversal on String { String get reverse {...} }</td>
</tr>
</tbody></table>
<h3 id="2-4-mixin-混入和-interface-接口在-Dart-中有何不同？"><a href="#2-4-mixin-混入和-interface-接口在-Dart-中有何不同？" class="headerlink" title="2.4 mixin 混入和 interface 接口在 Dart 中有何不同？"></a>2.4 mixin 混入和 interface 接口在 Dart 中有何不同？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在 Dart 中，mixin（混入） 和 interface（接口） 都用于实现类之间的复用和功能共享，</span><br><span class="line">但它们的工作原理和使用方式有所不同。下面是它们的主要区别：</span><br><span class="line"></span><br><span class="line">ChatGPT 说：</span><br><span class="line">在 Dart 中，mixin（混入） 和 interface（接口） 都用于实现类之间的复用和功能共享，</span><br><span class="line">但它们的工作原理和使用方式有所不同。下面是它们的主要区别：</span><br><span class="line"></span><br><span class="line">1. Mixin（混入）</span><br><span class="line">-定义：Mixin 是一种类复用的机制，允许你将一个类的行为（方法和属性）混入到另一个类中，而无需通过继承。</span><br><span class="line">Dart 中的 mixin 关键字用于定义混入类。</span><br><span class="line">-使用场景：当你希望复用某些功能到多个类时，mixin 比传统继承更加灵活，</span><br><span class="line">因为它允许在多个类之间共享代码，而不需要继承整个类。</span><br><span class="line">-特点：</span><br><span class="line">--不能实例化混入类。</span><br><span class="line">--允许混入多个类，类似于多重继承，但不会带来多重继承的复杂性。</span><br><span class="line">--可以包含方法和字段。</span><br><span class="line"></span><br><span class="line">2. Interface（接口）</span><br><span class="line">-定义：接口是用于定义类应遵循的行为规范。</span><br><span class="line">Dart 中的所有类都可以作为接口使用。当一个类实现接口时，它必须实现接口中定义的所有方法。</span><br><span class="line">-使用场景：当你需要指定类应实现某些功能或行为时，可以通过接口来规定类的结构。</span><br><span class="line">-特点：</span><br><span class="line">-Dart 中没有单独的 interface 关键字，任何类都可以作为接口。</span><br><span class="line">-类实现接口时，必须实现接口中定义的所有方法。</span><br><span class="line">-接口仅包含方法签名，没有实现。</span><br></pre></td></tr></table></figure>

<p>总结</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">mixin（混入）</th>
<th align="center">interface（接口）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td align="center">用于类之间共享代码的机制，可以在多个类中混入功能。</td>
<td align="center">用于定义类应该遵循的行为规范，强制实现类提供方法实现。</td>
</tr>
<tr>
<td align="center">继承</td>
<td align="center">可以通过 <code>with</code> 关键字混入多个类</td>
<td align="center">使用 <code>implements</code> 关键字实现接口，强制实现所有方法。</td>
</tr>
<tr>
<td align="center">方法实现</td>
<td align="center">可以包含方法的实现（有具体代码）。</td>
<td align="center">只包含方法签名，没有具体的实现（必须由实现类提供实现）。</td>
</tr>
<tr>
<td align="center">多重继承</td>
<td align="center">支持多重混入，可以在一个类中混入多个 mixin。</td>
<td align="center">一个类只能实现多个接口，但不能继承多个接口的实现。</td>
</tr>
<tr>
<td align="center">实例化</td>
<td align="center">不能实例化 mixin 类，只能通过 <code>with</code> 关键字混入</td>
<td align="center">接口不能被实例化，但可以用作实现类的类型检查。</td>
</tr>
</tbody></table>
<h3 id="2-5-Dart-中的空安全是什么？"><a href="#2-5-Dart-中的空安全是什么？" class="headerlink" title="2.5 Dart 中的空安全是什么？"></a>2.5 Dart 中的空安全是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Dart 中的空安全（Null Safety） 是 Dart 2.12 引入的特性，</span><br><span class="line">旨在减少程序中出现null引用错误（NullPointerException）的可能性，从而提高代码的稳定性和安全性。</span><br><span class="line"></span><br><span class="line">空安全特性使得类型系统能够在编译时确保 null 值的安全使用，避免了空引用的错误。</span><br><span class="line">通过空安全，Dart 强制要求开发者明确指定哪些变量可以为空，哪些不能为空。</span><br><span class="line"></span><br><span class="line">1. 如何启用空安全？</span><br><span class="line">-在 Dart 2.12 及之后的版本中，空安全是默认启用的。</span><br><span class="line">-你可以通过 dart migrate 命令来迁移已有项目到支持空安全的版本</span><br><span class="line"></span><br><span class="line">2.空安全的主要概念</span><br><span class="line">-非空类型（Non-nullable Types）：</span><br><span class="line">默认情况下，Dart 中的所有类型都 不能为 null。</span><br><span class="line">也就是说，一个变量在声明时，如果不显式指定为可空类型，它就不能为 null。</span><br><span class="line">-可空类型（Nullable Types）：如果希望一个变量可以为 null，需要在类型后面加上 ?，这表示该变量是可空的。</span><br><span class="line">-示例</span><br><span class="line">int a = 5;   // a 不能为 null</span><br><span class="line">a = null;     // 错误：a 不能赋值为 null</span><br><span class="line"></span><br><span class="line">int? b = 5;  // b 可以为 null</span><br><span class="line">b = null;     // 正确：b 可以为 null</span><br><span class="line"></span><br><span class="line">3. 常见的空安全特性：</span><br><span class="line">-强制声明非空：默认情况下，Dart 不允许将 null 赋给非空类型变量。</span><br><span class="line">-使用 ? 声明可空类型：可以通过在类型后加 ? 来表示该变量允许为 null。</span><br><span class="line">-空安全操作符：</span><br><span class="line">--?（可空类型操作符）：访问可空对象时，如果对象为 null，不会抛出异常，而是返回 null。</span><br><span class="line">示例</span><br><span class="line">String? name = null;</span><br><span class="line">int? length = name?.length;  // length 为 null，不会抛出异常</span><br><span class="line"></span><br><span class="line">--!（强制解包操作符）：如果你确定一个可空类型的变量不为 null，可以使用 ! 操作符强制解包。</span><br><span class="line">若变量确实为 null，则会抛出异常。</span><br><span class="line">示例</span><br><span class="line">String? name = &quot;Dart&quot;;</span><br><span class="line">print(name!.length);  // 强制解包，如果 name 为 null 会抛出异常</span><br><span class="line"></span><br><span class="line">--late 关键字：用于声明一个非空变量，且该变量在初始化时不需要立即赋值。</span><br><span class="line">late 表示变量稍后会被初始化，避免编译器警告。</span><br><span class="line">示例</span><br><span class="line">late String description;</span><br><span class="line">description = &quot;Dart is awesome!&quot;; // 稍后初始化</span><br><span class="line"></span><br><span class="line">4. 空安全的好处：</span><br><span class="line">-编译时检测 null 错误：Dart 在编译时就能检查出是否有可能出现 null 引用错误，从而避免运行时的崩溃。</span><br><span class="line">-明确变量的可空性：通过 ? 和 ! 等符号，Dart强制开发者明确区分哪些变量可以为 null，</span><br><span class="line">哪些不能为 null，这使得代码更加安全和易于理解。</span><br><span class="line"></span><br><span class="line">5.总结：</span><br><span class="line">-空安全 是 Dart 2.12 引入的特性，目的是避免空引用错误。</span><br><span class="line">-非空类型 默认情况下不能为 null，可空类型 需要在类型后加 ? 来表示。</span><br><span class="line">-空安全操作符（如 ?、!、late）允许开发者在编译时保证代码的 null 安全，提升代码的健壮性。</span><br></pre></td></tr></table></figure>

<h3 id="2-6-你能解释-Dart-中的-Isolate、Event-Loop-和-Future-的概念吗？"><a href="#2-6-你能解释-Dart-中的-Isolate、Event-Loop-和-Future-的概念吗？" class="headerlink" title="2.6 你能解释 Dart 中的 Isolate、Event Loop 和 Future 的概念吗？"></a>2.6 你能解释 Dart 中的 Isolate、Event Loop 和 Future 的概念吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">在 Dart 中，Isolate、Event Loop 和 Future 是处理并发、异步操作和事件循环的核心概念。</span><br><span class="line">它们在 Flutter 中也起着至关重要的作用，尤其在涉及 UI 更新、异步操作和多线程时。</span><br><span class="line">让我们逐一了解这三个概念。</span><br><span class="line"></span><br><span class="line"> 1. Isolate（隔离体）</span><br><span class="line">-定义：Isolate 是 Dart 中实现并发的基本单位，它是一个独立的执行单元，拥有自己的内存空间、事件队列和堆栈。</span><br><span class="line">每个 Isolate 之间互不共享内存，因此它们之间的通信只能通过消息传递来完成。</span><br><span class="line">-特点：</span><br><span class="line">--独立的内存空间：每个 Isolate 都有自己的内存堆和堆栈，不能直接访问其他 Isolate 的内存。</span><br><span class="line">--并行执行：可以在多个 Isolate 上并行执行任务，适合执行计算密集型任务，避免阻塞主线程。</span><br><span class="line">--消息传递：由于 Isolate 之间没有共享内存，它们通过 SendPort 和 ReceivePort 进行消息通信。</span><br><span class="line"></span><br><span class="line">2. Event Loop（事件循环）</span><br><span class="line">-定义：Event Loop 是 Dart 和 JavaScript 中的核心概念，它负责管理所有的异步操作和任务队列。</span><br><span class="line">简单来说，事件循环机制允许 Dart 程序在等待某些操作（如 I/O、定时器等）时不中断主线程的执行，</span><br><span class="line">而是通过事件队列将这些操作推送到后续执行。</span><br><span class="line"></span><br><span class="line">-工作原理：</span><br><span class="line">--Dart 程序开始时，主线程会启动事件循环。</span><br><span class="line">--当遇到异步操作（如 Future、Stream）时，操作会被放入事件队列。</span><br><span class="line">--事件循环会不断检查队列，并按顺序执行队列中的任务。</span><br><span class="line"></span><br><span class="line">3. Future（未来值）</span><br><span class="line">-定义：Future 是 Dart 中表示异步操作结果的对象。</span><br><span class="line">它代表一个可能还没有完成的操作，并提供了 then、catchError 等方法来处理异步结果。</span><br><span class="line"></span><br><span class="line">-工作原理：</span><br><span class="line">--Future 用于表示将来某个时间点会获得一个结果或错误，它允许开发者以非阻塞的方式处理异步任务。</span><br><span class="line">--Future 通过 then、catchError 或 async/await 来处理结果。</span><br><span class="line"></span><br><span class="line">小总结：</span><br><span class="line">-Isolate 用于并发执行独立任务，避免主线程阻塞。</span><br><span class="line">-Event Loop 负责管理异步任务的执行顺序，保证 UI 线程不被阻塞。</span><br><span class="line">-Future 用于表示异步任务的结果，允许开发者以非阻塞的方式处理异步操作。</span><br></pre></td></tr></table></figure>

<p>总结</p>
<table>
<thead>
<tr>
<th align="center">概念</th>
<th align="center">定义</th>
<th align="center">特点</th>
<th align="center">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Isolate</td>
<td align="center">独立的执行单元，拥有自己的内存空间和事件队列，适合并行执行任务。</td>
<td align="center">不共享内存、通过消息传递通信、可并行执行任务。</td>
<td align="center">适用于并发计算密集型任务，避免 UI 阻塞。</td>
</tr>
<tr>
<td align="center">Event Loop</td>
<td align="center">负责管理和调度异步操作的循环机制。</td>
<td align="center">异步任务放入事件队列，按顺序执行。</td>
<td align="center">异步任务放入事件队列，按顺序执行。</td>
</tr>
<tr>
<td align="center">Future</td>
<td align="center">表示一个异步操作的结果，表示未来某个时间会获得一个结果或错误。</td>
<td align="center">提供 <code>then</code>、<code>catchError</code> 等方法处理异步结果。</td>
<td align="center">适用于处理异步操作，如 I&#x2F;O、网络请求、延时操作等。</td>
</tr>
</tbody></table>
<h3 id="2-7-Flutter-无状态和有状态小部件之间有什么区别，以及-setState-的作用是什么？"><a href="#2-7-Flutter-无状态和有状态小部件之间有什么区别，以及-setState-的作用是什么？" class="headerlink" title="2.7 Flutter 无状态和有状态小部件之间有什么区别，以及 setState() 的作用是什么？"></a>2.7 Flutter 无状态和有状态小部件之间有什么区别，以及 setState() 的作用是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">在Flutter中，StatelessWidget（无状态小部件）和StatefulWidget（有状态小部件）是两种基本的Widget类型，它们之间有很大的区别。</span><br><span class="line">setState() 是与 StatefulWidget 相关的一个方法，用于触发小部件的重建。</span><br><span class="line">下面是它们的详细区别和 setState() 的作用。</span><br><span class="line"></span><br><span class="line">1. StatelessWidget（无状态小部件）</span><br><span class="line">定义：StatelessWidget 是不持有任何状态的 Widget。</span><br><span class="line">也就是说，它的外观和行为完全由它的 输入数据（即构造函数中的参数）决定，一旦构建完成就不会发生改变。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">-不可变：无状态小部件是静态的，不会随着时间变化而改变。它们的 UI 内容完全依赖传入的参数（构造函数参数）。</span><br><span class="line">-性能高：由于没有状态变化，它们的重建相对简单，性能较好。</span><br><span class="line"></span><br><span class="line">2. StatefulWidget（有状态小部件）</span><br><span class="line">定义：StatefulWidget 是持有状态的 Widget。</span><br><span class="line">它的 UI 会随着状态的变化而更新，可以响应用户交互或外部数据变化。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">-可变状态：有状态小部件的外观和行为可以根据状态的变化动态更新。</span><br><span class="line">-State 类：每个 StatefulWidget 都有一个关联的 State 类，负责管理和维护状态。</span><br><span class="line">-重建：当状态发生变化时，可以通过调用 setState() 来重新构建 UI。</span><br><span class="line"></span><br><span class="line">3. setState() 的作用</span><br><span class="line">定义：setState() 是StatefulWidget中的一个方法，用于通知Flutter框架状态发生变化，并触发该小部件的重建。</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">-当状态发生变化时，调用 setState() 会标记该 Widget 为“脏”的，需要重新构建。</span><br><span class="line">-setState() 内部会调用 build() 方法，从而重新构建 UI，更新屏幕显示。</span><br><span class="line">-只有在 StatefulWidget 中才能使用 setState()，因为它依赖于 State 类来管理状态。</span><br><span class="line"></span><br><span class="line">小总结：</span><br><span class="line">-StatelessWidget 适用于没有状态变化的组件，它的 UI 是静态的。</span><br><span class="line">-StatefulWidget 适用于需要根据用户交互或数据变化更新 UI 的组件，</span><br><span class="line">状态发生变化时可以通过 setState() 更新 UI</span><br></pre></td></tr></table></figure>

<p>总结</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">StatelessWidget（无状态小部件）</th>
<th align="center">StatefulWidget（有状态小部件）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">状态</td>
<td align="center">不持有状态，UI 基于外部传入的数据而构建。</td>
<td align="center">持有状态，UI 根据内部状态的变化进行更新。</td>
</tr>
<tr>
<td align="center">可变性</td>
<td align="center">不会随着时间变化而改变。</td>
<td align="center">可以根据状态变化进行重建，UI 会动态更新。</td>
</tr>
<tr>
<td align="center">构建方法</td>
<td align="center"><code>build()</code> 方法只依赖构造函数中的数据。</td>
<td align="center"><code>build()</code> 方法依赖状态管理，并通过 <code>setState()</code> 来触发更新。</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">性能较高，因为不需要重建 UI。</td>
<td align="center">性能相对较低，需要通过 <code>setState()</code> 重建 UI。</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">适用于静态的、不可变的 UI 组件，如显示信息、无交互的组件。</td>
<td align="center">适用于需要根据用户操作或外部事件动态更新的 UI 组件。</td>
</tr>
</tbody></table>
<h3 id="2-8-Flutter-InheritedWidget-是什么？"><a href="#2-8-Flutter-InheritedWidget-是什么？" class="headerlink" title="2.8 Flutter InheritedWidget 是什么？"></a>2.8 Flutter InheritedWidget 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Flutter 中的 InheritedWidget 是一种特殊的 Widget，用于在 Widget 树中向下传递数据。</span><br><span class="line">它的主要作用是提供一种机制，</span><br><span class="line">使得树中下层的 Widget 可以访问到祖先 Widget 中的共享数据，而无需通过构造函数一层层传递数据。</span><br><span class="line"></span><br><span class="line">1. InheritedWidget 的基本概念</span><br><span class="line">-InheritedWidget 允许在Widget树中共享数据，并通过Widget树的 上下文（BuildContext）来访问这些数据。</span><br><span class="line">-当 InheritedWidget 中的数据发生变化时，它会通知依赖它的子 Widget 重新构建，以便更新数据。</span><br><span class="line">-它适用于在 Widget 树中传递跨多个子树的数据，常见于应用级的状态管理、主题、路由等场景。</span><br><span class="line"></span><br><span class="line">2. InheritedWidget 的工作原理</span><br><span class="line">-共享数据：InheritedWidget 会将共享数据存储在它的 child 属性下，并通过 of 方法让子 Widget 访问。</span><br><span class="line">-依赖更新：当InheritedWidget中的数据变化时，它会标记所有依赖它的子Widget为“脏”，触发这些子Widget的重建。</span><br><span class="line"></span><br><span class="line">3. 使用 InheritedWidget</span><br><span class="line">-要使用 InheritedWidget，需要创建一个自定义的继承自 InheritedWidget 的类，</span><br><span class="line">并重写 updateShouldNotify() 方法，决定何时通知子 Widget 更新。</span><br><span class="line">-子 Widget 通过 InheritedWidget.of(context) 获取共享的数据。</span><br><span class="line"></span><br><span class="line">4. InheritedWidget 的常见使用场景</span><br><span class="line">-主题管理：InheritedWidget 用于在 Widget 树中传递主题数据（如颜色、字体等），</span><br><span class="line">使得所有子 Widget 可以访问主题并相应更新。</span><br><span class="line">-应用配置：可以用来传递应用级别的配置或状态，如用户信息、设置、语言等。</span><br><span class="line">-状态管理：一些轻量级的状态管理方案（例如 Provider）就是基于 InheritedWidget 实现的</span><br><span class="line"></span><br><span class="line">5. 优缺点</span><br><span class="line">优点：</span><br><span class="line">高效：</span><br><span class="line">InheritedWidget 仅会在其数据发生变化时，通知依赖它的 Widget 更新，不会影响树中其他不相关的 Widget。</span><br><span class="line">简洁：</span><br><span class="line">对于较小的应用，使用 InheritedWidget 可以很方便地实现跨 Widget 树的数据共享。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">复杂性：</span><br><span class="line">对于复杂的状态管理或频繁变化的数据，InheritedWidget 的使用可能会显得较为繁琐，且手动管理依赖可能不够方便。</span><br><span class="line"></span><br><span class="line">性能：如果不合理使用，过多的 InheritedWidget 嵌套可能会导致性能问题，特别是在需要频繁重建树的情况下。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">-InheritedWidget 是 Flutter 中用于跨 Widget 树共享数据的一种机制，常用于应用级别的状态管理。</span><br><span class="line">-它通过 updateShouldNotify() 来判断是否需要通知子 Widget 重新构建。</span><br><span class="line">-of(context) 是获取数据的方式，它可以帮助子 Widget 获取来自父 Widget 的共享数据。</span><br><span class="line">-适合传递全局性的数据，但对于复杂的状态管理，可能需要更强大的工具（如 Provider、Riverpod）来管理。</span><br></pre></td></tr></table></figure>

<h3 id="2-9-你能解释一下在-Flutter-中-keys-键的作用吗？"><a href="#2-9-你能解释一下在-Flutter-中-keys-键的作用吗？" class="headerlink" title="2.9 你能解释一下在 Flutter 中 keys 键的作用吗？"></a>2.9 你能解释一下在 Flutter 中 keys 键的作用吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">在 Flutter 中，Key 是一个非常重要的概念，用于标识和区分不同的 Widget 或者 Widget 的状态。</span><br><span class="line">它特别在 Widget 树重建、UI 更新以及列表渲染时扮演着重要的角色。</span><br><span class="line">通过使用 Key，Flutter 能够更高效地重建和重新排序 Widget 树。</span><br><span class="line"></span><br><span class="line">1. Key 的作用</span><br><span class="line">Key 主要有以下几种作用：</span><br><span class="line"></span><br><span class="line">-标识唯一性：</span><br><span class="line">Key可以唯一标识一个Widget或者它的状态，帮助Flutter 在 Widget 树重建时识别并保持不同 Widget 的状态。</span><br><span class="line"></span><br><span class="line">-保持状态：</span><br><span class="line">在列表或动态 UI 中，Key使得Flutter能够正确地重新绑定 Widget 的状态，避免在 Widget 重新构建时丢失状态。</span><br><span class="line"></span><br><span class="line">-优化性能：通过提供 Key，Flutter 可以避免不必要的 Widget 重建和重新排序，提高性能。</span><br><span class="line"></span><br><span class="line">2. 使用场景</span><br><span class="line">-列表中的元素：</span><br><span class="line">当我们有一个动态列表（例如使用 ListView 渲染的列表）时，Key 可以帮助 Flutter 确定哪个元素发生了变化，</span><br><span class="line">从而有效地重用现有的 Widget，而不是重新创建一个新的。</span><br><span class="line"></span><br><span class="line">-局部更新：在需要保持局部状态或局部更新时（例如在一个Form中），通过Key可以确保某个子Widget的状态不会丢失。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. Key 在 Widget 重建中的作用</span><br><span class="line">Key 在 Flutter 中的最重要的作用是在 Widget 树重建时，</span><br><span class="line">帮助 Flutter 确定哪些 Widget 需要保留状态，哪些 Widget 需要重新创建。</span><br><span class="line"></span><br><span class="line">-没有 Key 时，如果一个父 Widget 重新构建，它会销毁其所有的子 Widget，然后重新创建一遍。</span><br><span class="line">这可能会导致一些子 Widget 的状态丢失。</span><br><span class="line">-使用 Key 时，Flutter 能够根据 Key 来识别出哪些子 Widget 是相同的，从而保留它们的状态或更新它们。</span><br><span class="line"></span><br><span class="line"> 4. 为什么需要 Key？</span><br><span class="line">-状态管理：当 Widget 树发生变化时，Key 可以帮助 Flutter 保持 Widget 的状态和属性，避免不必要的重建。</span><br><span class="line">-优化渲染性能：使用 Key 能够帮助 Flutter 更高效地重建界面，只更新必要的部分，减少性能开销。</span><br><span class="line">-列表优化：对于复杂的列表或动态组件，通过 Key 能有效地避免重新构建整个列表，只更新有变化的部分。</span><br></pre></td></tr></table></figure>

<h3 id="2-10-在-Flutter-中，Keys（键）有哪几种类型？"><a href="#2-10-在-Flutter-中，Keys（键）有哪几种类型？" class="headerlink" title="2.10 在 Flutter 中，Keys（键）有哪几种类型？"></a>2.10 在 Flutter 中，Keys（键）有哪几种类型？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Flutter 中有几种常见的 Key 类型，每种类型的使用场景有所不同</span><br><span class="line"></span><br><span class="line">1.GlobalKey：</span><br><span class="line">作用：</span><br><span class="line">GlobalKey 用于标识一个 Widget 的唯一性，并允许跨多个 Widget 树之间访问它。</span><br><span class="line">它能够访问 Widget 树中任何位置的状态，常用于跨组件通信。</span><br><span class="line"></span><br><span class="line">使用场景：</span><br><span class="line">当你需要在多个地方访问同一个Widget的状态时，GlobalKey 会非常有用，例如访问 Form 的状态或 Scaffold 状态</span><br><span class="line"></span><br><span class="line">2.LocalKey（包括 ValueKey, ObjectKey, UniqueKey）：</span><br><span class="line">-作用：</span><br><span class="line">LocalKey 是一种比较轻量的 Key，适用于在同一 Widget 树内区分不同的 Widget。</span><br><span class="line">LocalKey 通常用于对比同级 Widget 是否发生变化。</span><br><span class="line"></span><br><span class="line">-ValueKey：基于值来比较 Widget，适用于通过特定数据（如字符串或整数）区分的 Widget。</span><br><span class="line">-ObjectKey：基于对象引用来区分 Widget，适用于依赖于对象的状态。</span><br><span class="line">-UniqueKey：每次创建一个新的 UniqueKey 时，它都会生成一个唯一的标识符，适用于需要完全唯一标识的场景。</span><br></pre></td></tr></table></figure>

<p>总结</p>
<table>
<thead>
<tr>
<th align="center">Key 类型</th>
<th align="center">描述</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GlobalKey</td>
<td align="center">用于跨多个 Widget 树访问状态，能够全局访问 Widget 和其状态。</td>
<td align="center">表单、Scaffold、导航等跨界面状态管理。</td>
</tr>
<tr>
<td align="center">ValueKey</td>
<td align="center">基于值来判断 Widget 是否相等。</td>
<td align="center">根据数据值（如 ID、字符串）区分 Widget</td>
</tr>
<tr>
<td align="center">ObjectKey</td>
<td align="center">基于对象引用来判断 Widget 是否相等。</td>
<td align="center">对象状态管理，如列表中的对象。</td>
</tr>
<tr>
<td align="center">UniqueKey</td>
<td align="center">每次创建一个新的、唯一的 Key。</td>
<td align="center">需要确保 Widget 唯一性的场景。</td>
</tr>
</tbody></table>
<h2 id="三-参考"><a href="#三-参考" class="headerlink" title="三 参考"></a>三 参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://ducafecat.com/blog/flutter-interview-questions-with-answers-02">狗哥课堂—Flutter 面试题整理 02</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/en/tags/Flutter%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Flutter面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/en/posts/460184d5.html" rel="prev" title="Flutter面试题——面试题整理6">
                  <i class="fa fa-angle-left"></i> Flutter面试题——面试题整理6
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/en/posts/a1b9a9d2.html" rel="next" title="Flutter面试题——面试题整理8">
                  Flutter面试题——面试题整理8 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">PGzxc</span>
  </div><div class="footer-language">
  <a href="/" data-lang="zh-CN" class="lang-link">中文</a>
  <span class="lang-separator">|</span>
  <a href="/en/" data-lang="en" class="lang-link">English</a>
  <span class="lang-separator">|</span>
  <a href="/ja/" data-lang="ja" class="lang-link">日本語</a>
</div>

<style>
.footer-language {
  text-align: center;
  margin: 10px 0;
}

.lang-link {
  margin: 0 5px;
  padding: 2px 8px;
  text-decoration: none;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.lang-link:hover {
  background-color: #f0f0f0;
}

.lang-link.active {
  background-color: #333;
  color: white;
}

.lang-separator {
  color: #999;
}
</style>

<script>
// 检测当前语言并设置选中状态
function setActiveLanguage() {
  const pathname = window.location.pathname;
  const langLinks = document.querySelectorAll('.lang-link');
  
  langLinks.forEach(link => {
    link.classList.remove('active');
  });
  
  if (pathname.startsWith('/en/')) {
    document.querySelector('[data-lang="en"]').classList.add('active');
  } else if (pathname.startsWith('/ja/')) {
    document.querySelector('[data-lang="ja"]').classList.add('active');
  } else {
    document.querySelector('[data-lang="zh-CN"]').classList.add('active');
  }
}

// 页面加载时设置选中状态
window.addEventListener('load', setActiveLanguage);

// 为语言切换链接添加点击事件处理
const langLinks = document.querySelectorAll('.lang-link');
langLinks.forEach(link => {
  link.addEventListener('click', function(e) {
    const targetLang = this.getAttribute('data-lang');
    const currentPath = window.location.pathname;
    
    // 提取当前路径中除去语言前缀的部分
    let pathWithoutLang = currentPath;
    if (currentPath.startsWith('/en/')) {
      pathWithoutLang = currentPath.substring(3);
    } else if (currentPath.startsWith('/ja/')) {
      pathWithoutLang = currentPath.substring(3);
    }
    
    // 构建目标URL
    let targetUrl = this.getAttribute('href');
    if (pathWithoutLang && pathWithoutLang !== '/') {
      // 如果不是首页，保持路径
      targetUrl = targetUrl + pathWithoutLang.replace(/^\//, '');
    }
    
    // 阻止默认跳转并使用新URL
    e.preventDefault();
    window.location.href = targetUrl;
  });
});
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"PGzxc","repo":"PGzxc.github.io","client_id":"4d2d97c55a316dfcea73","client_secret":"f55fe43764e8560484a13850e4a6d84792924fb0","admin_user":"PGzxc","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"41b34d0545fe42f828a3f51b946e7041"}</script>
<script src="/en/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
