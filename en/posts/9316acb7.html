<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/en/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon/favicon-64x64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon/favicon-32x32.png">
  <link rel="mask-icon" href="/en/images/favicon/favicon-64x64.png" color="#222">

<link rel="stylesheet" href="/en/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inconsolata:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pgzxc.github.io","root":"/en/","images":"/en/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"an-old-hope","dark":"an-old-hope"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Search...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/en/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/en/js/config.js" defer></script>

    <meta name="description" content="一 面试题汇总(Boss直聘分享-米哈游) 自我介绍 说说async、await的设计和实现 深拷贝需要注意哪些问题 判断数组的方法由哪些？手写一个instanceof方法 如何借鉴React diff算法的思想，实现各种情况树节点的更新">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题—面试题整理(1)">
<meta property="og:url" content="https://pgzxc.github.io/posts/9316acb7.html">
<meta property="og:site_name" content="PGzxc (English)">
<meta property="og:description" content="一 面试题汇总(Boss直聘分享-米哈游) 自我介绍 说说async、await的设计和实现 深拷贝需要注意哪些问题 判断数组的方法由哪些？手写一个instanceof方法 如何借鉴React diff算法的思想，实现各种情况树节点的更新">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-04-01T08:50:12.000Z">
<meta property="article:modified_time" content="2026-02-22T02:43:04.886Z">
<meta property="article:author" content="PGzxc">
<meta property="article:tag" content="Web前端面试题">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://pgzxc.github.io/posts/9316acb7.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://pgzxc.github.io/posts/9316acb7.html","path":"posts/9316acb7.html","title":"前端面试题—面试题整理(1)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端面试题—面试题整理(1) | PGzxc (English)</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="/en/js/utils.js" defer></script><script src="/en/js/motion.js" defer></script><script src="/en/js/sidebar.js" defer></script><script src="/en/js/next-boot.js" defer></script><script src="/en/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/en/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/en/js/third-party/tags/mermaid.js" defer></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/en/js/third-party/tags/wavedrom.js" defer></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/en/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/en/css/noscript.css">
  </noscript>
<link rel="alternate" href="/en/atom.xml" title="PGzxc (English)" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/en/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PGzxc (English)</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">What I learn from books is superficial; I must experience it myself</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/en/" rel="section"><i class="fa fa-bell fa-fw"></i>Home</a></li><li class="menu-item menu-item-nav"><a href="/en/navs/" rel="section"><i class="fa fa-bars fa-fw"></i>Navigation</a></li><li class="menu-item menu-item-categories"><a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">275</span></a></li><li class="menu-item menu-item-archives"><a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">4492</span></a></li><li class="menu-item menu-item-links"><a href="/en/links/" rel="section"><i class="fa fa-link fa-fw"></i>Links</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Search..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Site Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB-Boss%E7%9B%B4%E8%81%98%E5%88%86%E4%BA%AB-%E7%B1%B3%E5%93%88%E6%B8%B8"><span class="nav-number">1.</span> <span class="nav-text">一 面试题汇总(Boss直聘分享-米哈游)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94-%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83"><span class="nav-number">2.</span> <span class="nav-text">二 面试题解答(仅供参考)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 自我介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%AF%B4%E8%AF%B4async%E3%80%81await%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 说说async、await的设计和实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 深拷贝需要注意哪些问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E7%94%B1%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAinstanceof%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 判断数组的方法由哪些？手写一个instanceof方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%A6%82%E4%BD%95%E5%80%9F%E9%89%B4React-diff%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E6%83%85%E5%86%B5%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 如何借鉴React diff算法的思想，实现各种情况树节点的更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E6%80%8E%E4%B9%88%E8%AE%A9%E4%B8%AD%E9%97%B4%E9%A1%B5%E6%90%BA%E5%B8%A6%E4%B8%8Acookie%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 怎么让中间页携带上cookie？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E8%AF%B4%E8%AF%B4%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 说说跨域问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E8%AE%B2%E8%AE%B2webpack%E7%9A%84%E6%95%B4%E4%B8%AA%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 讲讲webpack的整个工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E8%BF%87webpack%E7%9A%84loader%E8%A7%A3%E5%86%B3%E8%BF%87%E4%B8%80%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 有没有用过webpack的loader解决过一些具体的场景问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-ES5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%9F%E8%AE%B2%E8%AE%B2%E5%AF%B9%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 ES5怎么实现继承？讲讲对原型链的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-require%E5%92%8Cimport%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.11.</span> <span class="nav-text">2.11 require和import的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E6%83%B3%E9%97%AE%E6%88%91%E7%9A%84%EF%BC%9F"><span class="nav-number">2.12.</span> <span class="nav-text">2.12 有没有什么想问我的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">三 参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PGzxc"
      src="/en/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">PGzxc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/en/archives/">
          <span class="site-state-item-count">4492</span>
          <span class="site-state-item-name">Posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/en/categories/">
        <span class="site-state-item-count">275</span>
        <span class="site-state-item-name">Categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/en/tags/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">Tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/calvin_zhou" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;calvin_zhou" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/5582039920" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;5582039920" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://www.jianshu.com/u/c5cdcb4dc52b" title="简书 → http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;c5cdcb4dc52b" rel="noopener me" target="_blank"><i class="fa fa-heartbeat fa-fw"></i></a>
      </span>
  </div>


<nav class="sidebar-nav" id="sidebar-nav">
  <ul class="sidebar-nav-menu">
        <li class="menu-item menu-item-home">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-nav">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-links">
          <a href="/enundefined" rel="section">
            <span></span>
          </a>
        </li>
  </ul>
</nav>
        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://pgzxc.github.io/posts/9316acb7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/en/images/avatar.jpg">
      <meta itemprop="name" content="PGzxc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PGzxc (English)">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="前端面试题—面试题整理(1) | PGzxc (English)">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端面试题—面试题整理(1)<a href="https://github.com/PGzxc/PGzxc.github.io/edit/master/source/_posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86(1).md" class="post-edit-link" title="Edit" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created at:2024-04-01 16:50:12" itemprop="dateCreated datePublished" datetime="2024-04-01T16:50:12+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/en/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">面试相关</span></a>
        </span>
          ,
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/en/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Web前端面试题</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>11 minutes</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一-面试题汇总-Boss直聘分享-米哈游"><a href="#一-面试题汇总-Boss直聘分享-米哈游" class="headerlink" title="一 面试题汇总(Boss直聘分享-米哈游)"></a>一 面试题汇总(Boss直聘分享-米哈游)</h2><ol>
<li>自我介绍</li>
<li>说说async、await的设计和实现</li>
<li>深拷贝需要注意哪些问题</li>
<li>判断数组的方法由哪些？手写一个instanceof方法</li>
<li>如何借鉴React diff算法的思想，实现各种情况树节点的更新 <span id="more"></span></li>
<li>怎么让中间页携带上cookie？</li>
<li>说说跨域问题</li>
<li>讲讲webpack的整个工作流程</li>
<li>有没有用过webpack的loader解决过一些具体的场景问题？</li>
<li>ES5怎么实现继承？讲讲对原型链的理解</li>
<li>require和import的区别？</li>
<li>有没有什么想问我的？</li>
</ol>
<h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-自我介绍"><a href="#2-1-自我介绍" class="headerlink" title="2.1 自我介绍"></a>2.1 自我介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当你面试前端开发岗位时，一个好的自我介绍可以给面试官留下深刻的印象。</span><br><span class="line">下面是一个简洁但有条理的前端开发自我介绍范例：</span><br><span class="line"></span><br><span class="line">大家好，我是 [你的名字]，很高兴有机会在这里面试前端开发岗位。</span><br><span class="line"></span><br><span class="line">我拥有 [你的工作经验/教育背景]。</span><br><span class="line">在过去的 [工作年限] 中，我一直专注于前端开发，并致力于不断提升自己的技术能力和项目实践经验。</span><br><span class="line"></span><br><span class="line">我熟练掌握 HTML、CSS 和 JavaScript，</span><br><span class="line">能够创建响应式、易于维护的网页布局，并通过 JavaScript 实现交互功能和动态效果。</span><br><span class="line">我对前端框架如React和Vue也有深入的了解，并在项目中应用它们来提高开发效率和用户体验。</span><br><span class="line"></span><br><span class="line">除了技术能力，我注重团队合作和沟通。</span><br><span class="line">我乐于与设计师、后端工程师以及产品经理合作，共同推动项目的成功实现。</span><br><span class="line">我喜欢和团队成员分享知识和经验，相信团队合作是实现共同目标的关键。</span><br><span class="line"></span><br><span class="line">在我的上一家公司，我参与了 [项目名称] 等多个项目的开发，负责前端部分的设计和实现。</span><br><span class="line">通过这些项目，我积累了丰富的经验，学会了如何解决实际项目中的挑战，并不断提升自己的技能水平。</span><br><span class="line"></span><br><span class="line">我对前端开发充满热情，并且愿意不断学习和探索新的技术。</span><br><span class="line">我相信我可以为贵公司带来价值，并与优秀的团队一起共同成长。</span><br><span class="line"></span><br><span class="line">谢谢您考虑我的申请，我期待能有机会加入贵公司，为您的团队贡献我的力量。</span><br><span class="line"></span><br><span class="line">根据你的实际经历和技能，你可以根据以上范例进行修改和调整，以展示出你的独特优势和经验</span><br></pre></td></tr></table></figure>

<h3 id="2-2-说说async、await的设计和实现"><a href="#2-2-说说async、await的设计和实现" class="headerlink" title="2.2 说说async、await的设计和实现"></a>2.2 说说async、await的设计和实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">async 和 await 是 JavaScript 中用于处理异步操作的语法糖，</span><br><span class="line">它们的设计和实现旨在简化异步代码的编写，并提高可读性。</span><br><span class="line"></span><br><span class="line">1-设计原则：</span><br><span class="line"></span><br><span class="line">1.1-简化异步编程：</span><br><span class="line">传统的异步编程方式（回调函数、Promise链）可能会导致回调地狱（Callback Hell），难以维护和理解。</span><br><span class="line">async和await的设计就是为了解决这个问题，使异步代码看起来更像同步代码，提高了可读性和可维护性。</span><br><span class="line"></span><br><span class="line">1.2-基于Promise：</span><br><span class="line">async 函数的返回值始终是一个Promise对象，这使得async和await与Promise API良好地集成在一起。</span><br><span class="line">因此，await 关键字只能在 async 函数内部使用。</span><br><span class="line"></span><br><span class="line">2-实现机制：</span><br><span class="line"></span><br><span class="line">2.1-async函数：</span><br><span class="line">async 函数本质上是一个返回 Promise 对象的函数，它内部的异步操作会被封装成 Promise 对象，</span><br><span class="line">并在异步操作执行完成后自动将结果作为 Promise 的 resolve 值返回。</span><br><span class="line">当 async 函数内部有 await 关键字时，函数执行会被挂起，</span><br><span class="line">直到等待的 Promise 对象状态变为 resolved 后再继续执行下一步操作。</span><br><span class="line"></span><br><span class="line">2.2-await表达式：</span><br><span class="line">await 关键字用于等待一个 Promise 对象的解决（resolve），并获取解决后的结果。</span><br><span class="line">在 await 后面可以跟任何返回 Promise 对象的表达式，包括普通函数调用、Promise 对象、</span><br><span class="line">或者其他 async 函数。在等待期间，await 会暂停 async 函数的执行，</span><br><span class="line">直到 Promise 对象状态变为 resolved 或 rejected。</span><br><span class="line"></span><br><span class="line">3-异步错误处理：</span><br><span class="line"></span><br><span class="line">3.1-对于 async 函数内部的异步操作，可以使用 try...catch语句来捕获和处理错误，就像处理同步代码一样。</span><br><span class="line"></span><br><span class="line">3.2-如果在 await 表达式中发生了错误（Promise 被 reject），</span><br><span class="line">那么整个 async 函数会抛出一个 rejected 的 Promise，可以使用catch方法或者try...catch来捕获这个错误。</span><br><span class="line"></span><br><span class="line">4-性能和兼容性：</span><br><span class="line"></span><br><span class="line">async 和 await 是基于 Promise 实现的，因此具有与 Promise 相似的性能和兼容性。</span><br><span class="line">需要注意的是，在支持 async 和 await 的环境中（如现代浏览器和 Node.js 8+），</span><br><span class="line">它们通常是首选的异步编程方式，但在不支持的环境中可能需要转译成 Promise 或其他形式的异步代码。</span><br><span class="line"></span><br><span class="line">总的来说，async 和 await 的设计和实现大大简化了 JavaScript 中的异步编程，</span><br><span class="line">使得开发者能够更轻松地编写和理解异步代码，提高了代码的可读性和可维护性。</span><br></pre></td></tr></table></figure>

<h3 id="2-3-深拷贝需要注意哪些问题"><a href="#2-3-深拷贝需要注意哪些问题" class="headerlink" title="2.3 深拷贝需要注意哪些问题"></a>2.3 深拷贝需要注意哪些问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">深拷贝是指在复制一个对象时，不仅复制对象本身，还复制对象内部所有嵌套的子对象，</span><br><span class="line">使得新对象与原对象完全独立，修改新对象不会影响到原对象。</span><br><span class="line">在实现深拷贝时，需要注意以下几个问题：</span><br><span class="line"></span><br><span class="line">1-循环引用：</span><br><span class="line">原对象内部可能存在循环引用，即对象的某个属性引用了该对象本身或者其父级对象，</span><br><span class="line">这会导致深拷贝进入无限递归，最终导致堆栈溢出。</span><br><span class="line">因此，在实现深拷贝时，需要检测和处理循环引用的情况，避免陷入无限循环。</span><br><span class="line"></span><br><span class="line">2-函数、正则表达式等特殊对象：</span><br><span class="line">在 JavaScript 中，函数、正则表达式等特殊对象的复制需要特殊处理。</span><br><span class="line">通常情况下，直接复制这些对象可能会丢失其原有的行为或含义，</span><br><span class="line">因此需要针对这些特殊对象进行适当的处理，例如使用相应的构造函数重新创建这些对象。</span><br><span class="line"></span><br><span class="line">3-原型链：</span><br><span class="line">在深拷贝过程中，需要保留原对象的原型链关系。</span><br><span class="line">如果直接复制对象的属性值而不考虑原型链，可能会导致新对象失去一些原有的行为或属性。</span><br><span class="line"></span><br><span class="line">4-性能：</span><br><span class="line">深拷贝可能会涉及递归遍历对象的所有属性，对于大型对象或深层嵌套的对象，这可能会导致性能问题。</span><br><span class="line">因此，在实现深拷贝时，需要考虑采用高效的算法和数据结构，以提高复制的效率。</span><br><span class="line"></span><br><span class="line">5-属性描述符：</span><br><span class="line">原对象的某些属性可能具有特殊的属性描述符（如不可枚举、不可配置等），</span><br><span class="line">在复制过程中需要保留这些属性描述符，以确保新对象与原对象的属性行为一致。</span><br><span class="line"></span><br><span class="line">综上所述，实现深拷贝时需要注意处理循环引用、特殊对象、原型链、性能等问题，</span><br><span class="line">以确保复制后的对象与原对象在结构和行为上保持一致，并且能够在各种情况下正确地使用和操作</span><br></pre></td></tr></table></figure>

<h3 id="2-4-判断数组的方法由哪些？手写一个instanceof方法"><a href="#2-4-判断数组的方法由哪些？手写一个instanceof方法" class="headerlink" title="2.4 判断数组的方法由哪些？手写一个instanceof方法"></a>2.4 判断数组的方法由哪些？手写一个instanceof方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">判断一个值是否为数组的方法有以下几种：</span><br><span class="line"></span><br><span class="line">1-Array.isArray() 方法：</span><br><span class="line">这是判断一个值是否为数组最推荐的方法。</span><br><span class="line">它会在当前的执行环境中判断给定的参数是否为数组，并返回一个布尔值。</span><br><span class="line"></span><br><span class="line">Array.isArray(value);</span><br><span class="line"></span><br><span class="line">2-instanceof 操作符：</span><br><span class="line">可以用于判断一个值是否为某个构造函数的实例，可以利用这个特性判断一个值是否为数组。</span><br><span class="line"></span><br><span class="line">value instanceof Array;</span><br><span class="line"></span><br><span class="line">3-Object.prototype.toString.call() 方法：</span><br><span class="line">可以获取一个值的内部属性 [[Class]]，利用这个特性可以判断一个值是否为数组。</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(value) === &#x27;[object Array]&#x27;;</span><br><span class="line"></span><br><span class="line">4-Array.prototype.isPrototypeOf() 方法：</span><br><span class="line">用于测试一个对象是否存在于另一个对象的原型链上，可以用于判断一个值是否为数组。</span><br><span class="line"></span><br><span class="line">Array.prototype.isPrototypeOf(value);</span><br><span class="line"></span><br><span class="line">这些方法都可以判断一个值是否为数组，但推荐使用 Array.isArray() 方法。</span><br><span class="line"></span><br><span class="line">下面是一个手写的 instanceof 方法的简单实现：</span><br><span class="line"></span><br><span class="line">function myInstanceOf(obj, constructor) &#123;</span><br><span class="line">    // 检查参数是否为对象</span><br><span class="line">    if (typeof obj !== &#x27;object&#x27; || obj === null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取对象的原型</span><br><span class="line">    let proto = Object.getPrototypeOf(obj);</span><br><span class="line"></span><br><span class="line">    // 遍历原型链</span><br><span class="line">    while (proto !== null) &#123;</span><br><span class="line">        // 判断原型是否为目标构造函数的原型</span><br><span class="line">        if (proto === constructor.prototype) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 继续向上查找原型链</span><br><span class="line">        proto = Object.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果未找到目标构造函数的原型，则返回 false</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">console.log(myInstanceOf([], Array)); // true</span><br><span class="line">console.log(myInstanceOf(&#123;&#125;, Array)); // false</span><br><span class="line">console.log(myInstanceOf(null, Object)); // false</span><br><span class="line"></span><br><span class="line">这个 myInstanceOf 方法的实现是通过遍历给定对象的原型链，逐级查找目标构造函数的原型，</span><br><span class="line">如果找到则返回 true，否则返回 false。</span><br></pre></td></tr></table></figure>

<h3 id="2-5-如何借鉴React-diff算法的思想，实现各种情况树节点的更新"><a href="#2-5-如何借鉴React-diff算法的思想，实现各种情况树节点的更新" class="headerlink" title="2.5 如何借鉴React diff算法的思想，实现各种情况树节点的更新"></a>2.5 如何借鉴React diff算法的思想，实现各种情况树节点的更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">React 的 diff 算法主要用于 Virtual DOM 的比对和更新，其思想可以借鉴到其他场景的树节点更新中。</span><br><span class="line">下面是一些可以借鉴 React diff 算法思想的树节点更新的情况：</span><br><span class="line"></span><br><span class="line">1-树节点的添加、删除、移动：</span><br><span class="line"></span><br><span class="line">添加：对比两棵树的节点，找出新树中有而旧树中没有的节点，执行相应的添加操作。</span><br><span class="line">删除：对比两棵树的节点，找出旧树中有而新树中没有的节点，执行相应的删除操作。</span><br><span class="line">移动：对比两棵树的节点，找出新旧树中相同的节点，并对比它们的位置，执行相应的移动操作。</span><br><span class="line"></span><br><span class="line">2-树节点的属性更新：</span><br><span class="line"></span><br><span class="line">对比两棵树中相同节点的属性，找出需要更新的属性，执行相应的更新操作。</span><br><span class="line">可以利用属性的不可变性，只更新变化的部分，减少不必要的更新操作。</span><br><span class="line"></span><br><span class="line">3-树节点的文本内容更新：</span><br><span class="line"></span><br><span class="line">对比两棵树中相同节点的文本内容，找出需要更新的文本内容，执行相应的更新操作。</span><br><span class="line">同样可以利用文本内容的不可变性，只更新变化的部分。</span><br><span class="line"></span><br><span class="line">4-树节点的递归更新：</span><br><span class="line"></span><br><span class="line">对树节点进行递归比对，从根节点开始，逐层比对其子节点，并执行相应的更新操作。</span><br><span class="line"></span><br><span class="line">5-优化性能：</span><br><span class="line"></span><br><span class="line">可以通过一些优化手段，例如增加 diff 算法的时间复杂度，减少不必要的比对操作，提高更新性能。</span><br><span class="line"></span><br><span class="line">下面是一个简单的例子，演示如何借鉴 React diff 算法思想实现树节点的更新：</span><br><span class="line"></span><br><span class="line">function updateNode(oldNode, newNode) &#123;</span><br><span class="line">    // 比较节点类型</span><br><span class="line">    if (oldNode.type !== newNode.type) &#123;</span><br><span class="line">        // 节点类型不同，替换整个节点</span><br><span class="line">        return newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新节点属性</span><br><span class="line">    let updatedNode = &#123;</span><br><span class="line">        ...oldNode,</span><br><span class="line">        props: &#123; ...oldNode.props, ...newNode.props &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 比较子节点</span><br><span class="line">    if (newNode.children.length &gt; 0) &#123;</span><br><span class="line">        updatedNode.children = newNode.children.map((newChild, index) =&gt; &#123;</span><br><span class="line">            const oldChild = oldNode.children[index];</span><br><span class="line">            // 递归更新子节点</span><br><span class="line">            return updateNode(oldChild, newChild);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return updatedNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">const oldTree = &#123;</span><br><span class="line">    type: &#x27;div&#x27;,</span><br><span class="line">    props: &#123; id: &#x27;old&#x27;, className: &#x27;container&#x27; &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123; type: &#x27;h1&#x27;, props: &#123; className: &#x27;title&#x27; &#125;, children: [&#x27;Old Title&#x27;] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const newTree = &#123;</span><br><span class="line">    type: &#x27;div&#x27;,</span><br><span class="line">    props: &#123; id: &#x27;new&#x27;, className: &#x27;container&#x27; &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123; type: &#x27;h1&#x27;, props: &#123; className: &#x27;title updated&#x27; &#125;, children: [&#x27;New Title&#x27;] &#125;,</span><br><span class="line">        &#123; type: &#x27;p&#x27;, props: &#123; className: &#x27;content&#x27; &#125;, children: [&#x27;New Content&#x27;] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const updatedTree = updateNode(oldTree, newTree);</span><br><span class="line">console.log(updatedTree);</span><br><span class="line"></span><br><span class="line">这个例子中的 updateNode 函数接收两棵树的根节点，并递归比较它们的节点，并执行相应的更新操作。</span><br></pre></td></tr></table></figure>

<h3 id="2-6-怎么让中间页携带上cookie？"><a href="#2-6-怎么让中间页携带上cookie？" class="headerlink" title="2.6 怎么让中间页携带上cookie？"></a>2.6 怎么让中间页携带上cookie？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">要让中间页携带上 Cookie，你可以在客户端发送 HTTP 请求时，通过设置请求头来添加 Cookie。</span><br><span class="line"></span><br><span class="line">在常见的情况下，浏览器会自动在每次 HTTP 请求中包含当前域下的 Cookie，</span><br><span class="line">但如果你需要在中间页中进行特定的 HTTP 请求，可以使用以下方法来手动添加 Cookie：</span><br><span class="line"></span><br><span class="line">1-使用 XMLHttpRequest（XHR）对象：</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;中间页URL&#x27;, true);</span><br><span class="line">xhr.withCredentials = true; // 携带 Cookie</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">在这个例子中，设置了 withCredentials 属性为 true，这样浏览器就会在发送请求时包含当前域下的 Cookie。</span><br><span class="line"></span><br><span class="line">2-使用 Fetch API：</span><br><span class="line"></span><br><span class="line">fetch(&#x27;中间页URL&#x27;, &#123;</span><br><span class="line">  method: &#x27;GET&#x27;,</span><br><span class="line">  credentials: &#x27;include&#x27; // 携带 Cookie</span><br><span class="line">&#125;)</span><br><span class="line">.then(response =&gt; &#123;</span><br><span class="line">  // 处理响应</span><br><span class="line">&#125;);</span><br><span class="line">在这个例子中，设置了 credentials 选项为 &#x27;include&#x27;，这样浏览器也会在发送请求时包含当前域下的 Cookie。</span><br><span class="line"></span><br><span class="line">无论你选择使用 XHR 对象还是 Fetch API，都需要注意以下几点：</span><br><span class="line"></span><br><span class="line">你必须在服务器端允许使用 Cookie。</span><br><span class="line">在服务器端的响应中，需要设置 Access-Control-Allow-Credentials: true 头部，以允许跨域请求携带 Cookie。</span><br><span class="line">如果你是在同一域名下进行请求，通常情况下不需要特别设置，浏览器会自动携带 Cookie。</span><br><span class="line">请确保你的操作符合相关的安全性要求，并遵循跨站请求伪造（CSRF）和其他安全最佳实践</span><br></pre></td></tr></table></figure>

<h3 id="2-7-说说跨域问题"><a href="#2-7-说说跨域问题" class="headerlink" title="2.7 说说跨域问题"></a>2.7 说说跨域问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">跨域问题是指当一个请求的发起域（域名、协议、端口）与请求的目标域不一致时，</span><br><span class="line">浏览器会限制页面中的 JavaScript 代码对目标域的访问，这是为了保护用户隐私和安全。</span><br><span class="line">跨域问题可能出现在 AJAX 请求、Web 字体加载、图像加载、脚本加载等场景中。</span><br><span class="line"></span><br><span class="line">以下是一些常见的跨域问题和解决方案：</span><br><span class="line"></span><br><span class="line">1-原因：</span><br><span class="line">浏览器的同源策略（Same-Origin Policy）限制了 JavaScript 的跨域访问，</span><br><span class="line">即在默认情况下，一个页面中的 JavaScript 代码只能与同一域名、端口和协议下的资源进行交互。</span><br><span class="line"></span><br><span class="line">2-解决方案：</span><br><span class="line"></span><br><span class="line">2.1-CORS（跨域资源共享）：</span><br><span class="line">服务端设置响应头中的 Access-Control-Allow-Origin 来允许跨域请求。</span><br><span class="line">服务器端可以配置允许哪些域名的请求可以跨域访问，</span><br><span class="line">也可以设置 Access-Control-Allow-Origin: * 来允许所有域名的请求。</span><br><span class="line">此外，还可以通过设置 Access-Control-Allow-Credentials: true 来允许跨域请求携带凭据（如 Cookie）。</span><br><span class="line"></span><br><span class="line">2.2-JSONP（JSON with Padding）：</span><br><span class="line">通过动态创建 &lt;script&gt; 标签实现跨域请求。</span><br><span class="line">在请求中携带一个回调函数名，并将返回的数据包裹在该函数中返回，以实现跨域数据传输。</span><br><span class="line"></span><br><span class="line">2.3-代理服务器：</span><br><span class="line">通过在同一域下部署一个代理服务器来转发跨域请求。</span><br><span class="line">客户端发送请求到代理服务器，代理服务器再将请求发送到目标服务器，然后将响应返回给客户端。</span><br><span class="line">这样就绕过了浏览器的跨域限制。</span><br><span class="line"></span><br><span class="line">2.4-跨域资源共享（Cross-Origin Resource Sharing，CORS）：</span><br><span class="line">在服务端设置相关的响应头，允许特定域的请求访问资源。</span><br><span class="line"></span><br><span class="line">3-常见跨域场景：</span><br><span class="line"></span><br><span class="line">3.1-Ajax 跨域请求：</span><br><span class="line">浏览器限制了使用 XMLHttpRequest 或 Fetch API 发起跨域请求。</span><br><span class="line">图片跨域请求：由于图片没有跨域限制，可以通过动态创建 &lt;img&gt; 标签来加载跨域图片资源。</span><br><span class="line">跨域资源引用：在 &lt;script&gt;、&lt;link&gt;、&lt;img&gt; 等标签中引用跨域资源时会受到同源策略的限制。</span><br><span class="line"></span><br><span class="line">4-安全风险：</span><br><span class="line">跨域请求存在安全风险，如 CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击。</span><br><span class="line">因此，在允许跨域访问时，需要谨慎考虑安全性，并采取适当的措施来防范安全风险。</span><br><span class="line"></span><br><span class="line">综上所述，跨域问题是 Web 开发中常见的问题之一，</span><br><span class="line">需要在开发过程中注意合理处理跨域请求，并根据具体情况选择合适的解决方案来解决跨域问题。</span><br></pre></td></tr></table></figure>

<h3 id="2-8-讲讲webpack的整个工作流程"><a href="#2-8-讲讲webpack的整个工作流程" class="headerlink" title="2.8 讲讲webpack的整个工作流程"></a>2.8 讲讲webpack的整个工作流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。</span><br><span class="line">它可以将多个模块打包成一个或多个 bundle 文件，以优化资源加载和提高性能。</span><br><span class="line">Webpack 的工作流程可以大致分为以下几个步骤：</span><br><span class="line"></span><br><span class="line">1-入口点（Entry）：</span><br><span class="line"></span><br><span class="line">首先，Webpack 根据配置文件（通常是 webpack.config.js）中指定的入口点来开始打包过程。</span><br><span class="line">入口点指定了应用程序的起始模块，Webpack 将从这些模块开始递归地构建依赖图。</span><br><span class="line"></span><br><span class="line">2-模块解析（Module Resolution）：</span><br><span class="line"></span><br><span class="line">Webpack 将逐个解析入口点及其依赖的模块，确定每个模块的依赖关系。</span><br><span class="line">在解析模块时，Webpack 根据配置中的 rules 和 loaders 对模块进行转换和处理，</span><br><span class="line">例如将 ES6+ 代码转换为 ES5、处理 CSS、图片等资源文件等。</span><br><span class="line"></span><br><span class="line">3-依赖图构建（Dependency Graph）：</span><br><span class="line"></span><br><span class="line">Webpack 构建一个模块依赖图，包含了项目中所有模块之间的依赖关系。</span><br><span class="line">Webpack 根据模块之间的依赖关系，决定模块的加载顺序和打包方式。</span><br><span class="line"></span><br><span class="line">4-模块打包（Module Bundling）：</span><br><span class="line"></span><br><span class="line">在构建依赖图后，Webpack 开始根据配置生成打包结果。</span><br><span class="line">根据模块的依赖关系，Webpack 将模块打包成一个或多个 bundle 文件。</span><br><span class="line"></span><br><span class="line">5-资源输出（Output）：</span><br><span class="line"></span><br><span class="line">最后，Webpack 将打包结果输出到指定的目录中。</span><br><span class="line">可以通过配置文件中的 output 字段来指定输出路径和文件名格式。</span><br><span class="line"></span><br><span class="line">整个工作流程中，Webpack 还包括了许多其他功能和特性，</span><br><span class="line">如代码分割、懒加载、模块热替换（Hot Module Replacement，HMR）等。</span><br><span class="line">通过配置文件，可以灵活地配置各种插件和 loader，以满足不同项目的需求。</span><br><span class="line"></span><br><span class="line">总的来说，Webpack 的工作流程是一个将模块转换、打包和输出的过程，</span><br><span class="line">通过对项目中的模块进行分析和处理，生成优化后的静态资源文件，以提高应用程序的性能和加载速度</span><br></pre></td></tr></table></figure>

<h3 id="2-9-有没有用过webpack的loader解决过一些具体的场景问题？"><a href="#2-9-有没有用过webpack的loader解决过一些具体的场景问题？" class="headerlink" title="2.9 有没有用过webpack的loader解决过一些具体的场景问题？"></a>2.9 有没有用过webpack的loader解决过一些具体的场景问题？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">作为一个常用的模块打包工具，Webpack 的 loader 功能非常强大，可以用于解决各种具体的场景问题。</span><br><span class="line">以下是一些我使用 Webpack loader 解决过的具体场景问题：</span><br><span class="line"></span><br><span class="line">1-处理 CSS：使用 css-loader 和 style-loader 来处理 CSS 文件，</span><br><span class="line">将 CSS 文件转换为 JavaScript 模块，以便在 JavaScript 中引用，并且将 CSS 样式注入到页面中。</span><br><span class="line"></span><br><span class="line">2-处理图片和字体文件：使用 file-loader 和 url-loader 来处理图片和字体文件，</span><br><span class="line">将它们复制到输出目录，并返回文件路径，以便在页面中引用。</span><br><span class="line"></span><br><span class="line">3-处理 JavaScript 兼容性：使用 babel-loader 将 ES6+ 代码转换为 ES5 代码，</span><br><span class="line">以确保在不支持最新 JavaScript 语法的浏览器中也能正常运行应用程序。</span><br><span class="line"></span><br><span class="line">4-处理样式预处理器：使用 sass-loader、less-loader 或 stylus-loader 来处理 SASS、LESS 或 Stylus 样式文件，将其转换为 CSS。</span><br><span class="line"></span><br><span class="line">5-处理静态资源引用路径：使用 file-loader、url-loader </span><br><span class="line">或 resolve-url-loader 来处理静态资源的引用路径，以确保在打包过程中正确解析资源的相对路径。</span><br><span class="line"></span><br><span class="line">6-处理文件大小优化：使用image-webpack-loader来优化图片文件大小，以减少网络传输时间和提高加载速度。</span><br><span class="line"></span><br><span class="line">7-处理代码分割：使用 splitChunksPlugin 和 bundle-loader 来实现代码分割，</span><br><span class="line">将应用程序拆分为多个 bundle，以优化页面加载性能。</span><br><span class="line"></span><br><span class="line">8-处理静态资源版本控制：使用 file-loader 和 url-loader 的 outputPath 和 publicPath </span><br><span class="line">配置选项，配合插件如 asset-webpack-plugin 来实现静态资源的版本控制和缓存。</span><br><span class="line"></span><br><span class="line">以上是我在使用 Webpack loader 解决过的一些具体场景问题，</span><br><span class="line">Webpack loader 提供了丰富的功能和灵活的配置选项，可以满足各种不同项目的需求。</span><br></pre></td></tr></table></figure>

<h3 id="2-10-ES5怎么实现继承？讲讲对原型链的理解"><a href="#2-10-ES5怎么实现继承？讲讲对原型链的理解" class="headerlink" title="2.10 ES5怎么实现继承？讲讲对原型链的理解"></a>2.10 ES5怎么实现继承？讲讲对原型链的理解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">在 ES5 中，可以使用原型链来实现继承。下面是一个基于原型链的简单继承示例，以及对原型链的理解：</span><br><span class="line"></span><br><span class="line">1. 基于原型链的继承示例：</span><br><span class="line"></span><br><span class="line">// 父类</span><br><span class="line">function Animal(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类方法</span><br><span class="line">Animal.prototype.sayName = function() &#123;</span><br><span class="line">    console.log(&#x27;My name is &#x27; + this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Dog(name, breed) &#123;</span><br><span class="line">    Animal.call(this, name);</span><br><span class="line">    this.breed = breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类继承父类的原型链</span><br><span class="line">Dog.prototype = Object.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">// 子类方法</span><br><span class="line">Dog.prototype.bark = function() &#123;</span><br><span class="line">    console.log(&#x27;Woof! I am a &#x27; + this.breed);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 实例化子类</span><br><span class="line">var myDog = new Dog(&#x27;Buddy&#x27;, &#x27;Labrador&#x27;);</span><br><span class="line">myDog.sayName(); // 输出：My name is Buddy</span><br><span class="line">myDog.bark();    // 输出：Woof! I am a Labrador</span><br><span class="line"></span><br><span class="line">2. 原型链的理解：</span><br><span class="line">2.1原型链是 JavaScript 中实现继承的一种机制。</span><br><span class="line">每个对象都有一个原型链，它是一条从该对象到 Object.prototype（最顶层的原型对象）的链路。</span><br><span class="line">当访问对象的属性或方法时，如果对象自身没有定义，则会沿着原型链向上查找，直到找到相应的属性或方法为止。</span><br><span class="line"></span><br><span class="line">2.2-在上面的示例中，Dog.prototype 对象通过 Object.create(Animal.prototype) 创建，</span><br><span class="line">将 Animal.prototype 设置为 Dog.prototype 的原型，从而实现了子类Dog对父类Animal 的继承。</span><br><span class="line"></span><br><span class="line">2.3-原型链的工作方式是通过 [[Prototype]] 隐式属性实现的。</span><br><span class="line">每个对象都有一个 [[Prototype]] 属性，指向其原型对象。</span><br><span class="line">当试图访问对象的属性或方法时，如果对象本身没有定义，则会沿着[[Prototype]]链向上查找，直到找到为止。</span><br><span class="line"></span><br><span class="line">原型链的顶端是 Object.prototype，它是 JavaScript 中所有对象的根对象。因此，所有对象都继承了 Object.prototype 的属性和方法。</span><br><span class="line"></span><br><span class="line">总的来说，原型链是 JavaScript 中实现继承的一种机制，</span><br><span class="line">它通过对象之间的原型关联来实现属性和方法的共享，从而提高了代码的复用性和可维护性。</span><br></pre></td></tr></table></figure>

<h3 id="2-11-require和import的区别？"><a href="#2-11-require和import的区别？" class="headerlink" title="2.11 require和import的区别？"></a>2.11 require和import的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">require和 import是JavaScript 中用于导入模块的两种不同方式，它们的主要区别在于以下几个方面：</span><br><span class="line"></span><br><span class="line">1-语法：</span><br><span class="line"></span><br><span class="line">require 是 CommonJS 规范中定义的模块导入方法，</span><br><span class="line">其语法为 const module = require(&#x27;module-name&#x27;);，通常用于 Node.js 环境中。</span><br><span class="line">import 是 ES6 中定义的模块导入语法，其语法为 import module from &#x27;module-name&#x27;;</span><br><span class="line">通常用于现代浏览器和支持 ES6 模块的 JavaScript 运行时环境中。</span><br><span class="line"></span><br><span class="line">2-加载方式：</span><br><span class="line"></span><br><span class="line">require 是同步加载模块的方式，即模块在引入时会立即加载并执行，导致阻塞后续代码的执行。</span><br><span class="line">import 是异步加载模块的方式，即模块在引入时不会立即加载，</span><br><span class="line">而是在代码执行到引入语句时才会加载模块，不会阻塞后续代码的执行。</span><br><span class="line"></span><br><span class="line">3-变量声明：</span><br><span class="line"></span><br><span class="line">require 导入的模块会被放到一个变量中，可以是任何合法的 JavaScript 变量名，</span><br><span class="line">模块的导出内容可以通过这个变量来访问。</span><br><span class="line">import 导入的模块会被放到一个具名变量中，该变量名必须与导出模块的名称相同，</span><br><span class="line">模块的导出内容可以通过该变量来访问。</span><br><span class="line"></span><br><span class="line">4-静态分析：</span><br><span class="line"></span><br><span class="line">require 是动态的，只能在代码运行时确定导入的模块。</span><br><span class="line">import 是静态的，可以在编译阶段确定导入的模块，从而使得工具可以进行静态分析和优化。</span><br><span class="line"></span><br><span class="line">总的来说，require 和 import 是两种不同的模块导入语法，各有其适用的场景和特点。</span><br><span class="line">在 Node.js 环境中，通常使用 require；而在现代的 JavaScript 应用中，通常使用 import。</span><br></pre></td></tr></table></figure>

<h3 id="2-12-有没有什么想问我的？"><a href="#2-12-有没有什么想问我的？" class="headerlink" title="2.12 有没有什么想问我的？"></a>2.12 有没有什么想问我的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">在面试结束时，当面试官询问你是否有任何问题时，这是一个很好的机会来展示你对公司和职位的兴趣，</span><br><span class="line">并且了解更多关于公司、团队和工作环境的信息。</span><br><span class="line">以下是一些你可以问的问题示例：</span><br><span class="line"></span><br><span class="line">1-关于公司：</span><br><span class="line">可以询问公司的发展方向和未来规划是什么？</span><br><span class="line">了解公司的文化和价值观是什么？</span><br><span class="line">询问公司的业务模式和主要客户群体是谁？</span><br><span class="line"></span><br><span class="line">2-关于团队：</span><br><span class="line">可以询问你将在团队中的角色和职责是什么？</span><br><span class="line">了解团队的工作方式和协作流程是怎样的？</span><br><span class="line">询问团队成员的技术背景和经验情况如何？</span><br><span class="line"></span><br><span class="line">3-关于职位：</span><br><span class="line">可以询问职位的具体工作内容和项目类型是什么？</span><br><span class="line">了解职位的晋升和发展路径是怎样的？</span><br><span class="line">询问关于工作时间、福利和薪酬待遇等方面的信息。</span><br><span class="line"></span><br><span class="line">4-关于技术：</span><br><span class="line">可以询问公司对于新技术和工具的采用情况如何？</span><br><span class="line">了解公司的技术栈和项目中使用的主要技术是什么？</span><br><span class="line">询问公司是否有提供技术培训和学习资源的机会。</span><br><span class="line"></span><br><span class="line">通过提出这些问题，你不仅可以更深入地了解公司和职位，</span><br><span class="line">还能展示你对工作的热情和求知欲，给面试官留下积极的印象。</span><br><span class="line">同时，这也是一个展示你思考问题能力和对未来发展的关注的好机会。</span><br></pre></td></tr></table></figure>

<h2 id="三-参考"><a href="#三-参考" class="headerlink" title="三 参考"></a>三 参考</h2><ul>
<li>ChatGPT3.5</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/en/tags/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Web前端面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/en/posts/6fef04ee.html" rel="prev" title="标准韩国语第三册——第11课-纸巾与糖-课文">
                  <i class="fa fa-angle-left"></i> 标准韩国语第三册——第11课-纸巾与糖-课文
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/en/posts/b83bff74.html" rel="next" title="前端面试题—面试题整理(2)">
                  前端面试题—面试题整理(2) <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">PGzxc</span>
  </div><div class="footer-language">
  <a href="/" data-lang="zh-CN" class="lang-link">中文</a>
  <span class="lang-separator">|</span>
  <a href="/en/" data-lang="en" class="lang-link">English</a>
  <span class="lang-separator">|</span>
  <a href="/ja/" data-lang="ja" class="lang-link">日本語</a>
</div>

<style>
.footer-language {
  text-align: center;
  margin: 10px 0;
}

.lang-link {
  margin: 0 5px;
  padding: 2px 8px;
  text-decoration: none;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.lang-link:hover {
  background-color: #f0f0f0;
}

.lang-link.active {
  background-color: #333;
  color: white;
}

.lang-separator {
  color: #999;
}
</style>

<script>
// 检测当前语言并设置选中状态
function setActiveLanguage() {
  const pathname = window.location.pathname;
  const langLinks = document.querySelectorAll('.lang-link');
  
  langLinks.forEach(link => {
    link.classList.remove('active');
  });
  
  if (pathname.startsWith('/en/')) {
    document.querySelector('[data-lang="en"]').classList.add('active');
  } else if (pathname.startsWith('/ja/')) {
    document.querySelector('[data-lang="ja"]').classList.add('active');
  } else {
    document.querySelector('[data-lang="zh-CN"]').classList.add('active');
  }
}

// 页面加载时设置选中状态
window.addEventListener('load', setActiveLanguage);

// 为语言切换链接添加点击事件处理
const langLinks = document.querySelectorAll('.lang-link');
langLinks.forEach(link => {
  link.addEventListener('click', function(e) {
    const targetLang = this.getAttribute('data-lang');
    const currentPath = window.location.pathname;
    
    // 提取当前路径中除去语言前缀的部分
    let pathWithoutLang = currentPath;
    if (currentPath.startsWith('/en/')) {
      pathWithoutLang = currentPath.substring(3);
    } else if (currentPath.startsWith('/ja/')) {
      pathWithoutLang = currentPath.substring(3);
    }
    
    // 构建目标URL
    let targetUrl = this.getAttribute('href');
    if (pathWithoutLang && pathWithoutLang !== '/') {
      // 如果不是首页，保持路径
      targetUrl = targetUrl + pathWithoutLang.replace(/^\//, '');
    }
    
    // 阻止默认跳转并使用新URL
    e.preventDefault();
    window.location.href = targetUrl;
  });
});
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"PGzxc","repo":"PGzxc.github.io","client_id":"4d2d97c55a316dfcea73","client_secret":"f55fe43764e8560484a13850e4a6d84792924fb0","admin_user":"PGzxc","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"be3585cb45ed53ce99f8efd7558082cc"}</script>
<script src="/en/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
