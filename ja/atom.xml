<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PGzxc (Japanese)</title>
  
  <subtitle>本から学んだことは表面的なもの；自分で体験しなければならない</subtitle>
  <link href="https://pgzxc.github.io/atom.xml" rel="self"/>
  
  <link href="https://pgzxc.github.io/"/>
  <updated>2026-02-22T02:43:05.043Z</updated>
  <id>https://pgzxc.github.io/</id>
  
  <author>
    <name>PGzxc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter开发之——常用网络请求框架和数据解析</title>
    <link href="https://pgzxc.github.io/posts/9c91e63c.html"/>
    <id>https://pgzxc.github.io/posts/9c91e63c.html</id>
    <published>2026-02-22T01:13:06.000Z</published>
    <updated>2026-02-22T02:43:05.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 Flutter 应用开发中，网络层同样由 网络请求库 + 数据解析方式 两部分组成。</span><br><span class="line">由于 Flutter 本身跨平台(Android/iOS/Web/Desktop)，网络与解析方案更强调 一致性、性能和可维护性。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-Flutter-常用网络请求库"><a href="#二-Flutter-常用网络请求库" class="headerlink" title="二 Flutter 常用网络请求库"></a>二 Flutter 常用网络请求库</h2><h3 id="2-1-http-官方基础库"><a href="#2-1-http-官方基础库" class="headerlink" title="2.1 http(官方基础库)"></a>2.1 http(官方基础库)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1-来源：Dart 官方</span><br><span class="line">2-定位：基础 HTTP 客户端</span><br><span class="line"></span><br><span class="line">3-特点：</span><br><span class="line">-API 简单</span><br><span class="line">-支持 GET/POST</span><br><span class="line">-Future/async / await</span><br><span class="line">-轻量、无侵入</span><br><span class="line"></span><br><span class="line">3-不足：</span><br><span class="line">-无拦截器</span><br><span class="line">-无统一错误处理</span><br><span class="line">-功能偏基础</span><br><span class="line"></span><br><span class="line">4-说明：</span><br><span class="line">适合简单项目/Demo</span><br></pre></td></tr></table></figure><h3 id="2-2-Dio-Flutter-事实标准"><a href="#2-2-Dio-Flutter-事实标准" class="headerlink" title="2.2 Dio(Flutter 事实标准)"></a>2.2 Dio(Flutter 事实标准)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1-定位：高级 HTTP 客户端</span><br><span class="line">2-地位：Flutter 中最主流网络库</span><br><span class="line"></span><br><span class="line">3-核心能力：</span><br><span class="line">-拦截器(请求/响应/错误)</span><br><span class="line">-请求取消</span><br><span class="line">-文件上传/下载</span><br><span class="line">-超时、重试</span><br><span class="line">-FormData 支持</span><br><span class="line"></span><br><span class="line">4-典型使用场景：</span><br><span class="line">-中大型 Flutter 项目</span><br><span class="line">-企业级应用</span><br><span class="line"></span><br><span class="line">5-说明：</span><br><span class="line">Flutter 网络开发首选</span><br></pre></td></tr></table></figure><h3 id="2-3-Chopper-Retrofit-风格"><a href="#2-3-Chopper-Retrofit-风格" class="headerlink" title="2.3  Chopper(Retrofit 风格)"></a>2.3  Chopper(Retrofit 风格)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1-定位：接口式网络封装</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-类似 Retrofit</span><br><span class="line">-支持代码生成</span><br><span class="line">-接口定义清晰</span><br><span class="line"></span><br><span class="line">3-不足：</span><br><span class="line">-社区活跃度一般</span><br><span class="line">-学习成本略高</span><br></pre></td></tr></table></figure><h3 id="2-4-Retrofit-Dart-版"><a href="#2-4-Retrofit-Dart-版" class="headerlink" title="2.4 Retrofit(Dart 版)"></a>2.4 Retrofit(Dart 版)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-定位：Dio + 注解 + 代码生成</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-接口即文档</span><br><span class="line">-编译期生成请求代码</span><br><span class="line">-强类型</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">偏好 Retrofit 风格的开发者常用</span><br></pre></td></tr></table></figure><h3 id="2-5-WebSocket-网络库"><a href="#2-5-WebSocket-网络库" class="headerlink" title="2.5 WebSocket 网络库"></a>2.5 WebSocket 网络库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1-常见方案：</span><br><span class="line">-dart:io WebSocket</span><br><span class="line">-socket_io_client</span><br><span class="line"></span><br><span class="line">2-使用场景：</span><br><span class="line">-即时聊天</span><br><span class="line">-实时推送</span><br><span class="line">-实时状态同步</span><br></pre></td></tr></table></figure><h2 id="三-Flutter-常用数据解析方式"><a href="#三-Flutter-常用数据解析方式" class="headerlink" title="三 Flutter 常用数据解析方式"></a>三 Flutter 常用数据解析方式</h2><h3 id="3-1-JSON-绝对主流"><a href="#3-1-JSON-绝对主流" class="headerlink" title="3.1 JSON(绝对主流)"></a>3.1 JSON(绝对主流)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flutter 与后端交互 几乎全部基于 JSON。</span><br></pre></td></tr></table></figure><h3 id="3-2-dart-convert-基础解析"><a href="#3-2-dart-convert-基础解析" class="headerlink" title="3.2 dart:convert(基础解析)"></a>3.2 dart:convert(基础解析)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1-内置库：</span><br><span class="line">jsonDecode(response.body);</span><br><span class="line">jsonEncode(data);</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-官方</span><br><span class="line">-无依赖</span><br><span class="line">-手动映射</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">小项目 / 简单接口常用</span><br></pre></td></tr></table></figure><h3 id="3-3-手写-Model-fromJson-最常见"><a href="#3-3-手写-Model-fromJson-最常见" class="headerlink" title="3.3 手写 Model + fromJson(最常见)"></a>3.3 手写 Model + fromJson(最常见)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">class User &#123;</span><br><span class="line">  final String name;</span><br><span class="line"></span><br><span class="line">  User.fromJson(Map&lt;String, dynamic&gt; json)</span><br><span class="line">      : name = json[&#x27;name&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-优点：</span><br><span class="line">-灵活</span><br><span class="line">-可控</span><br><span class="line">-学习成本低</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">Flutter 项目最普遍方案</span><br></pre></td></tr></table></figure><h3 id="3-4-json-serializable-推荐"><a href="#3-4-json-serializable-推荐" class="headerlink" title="3.4 json_serializable(推荐)"></a>3.4 json_serializable(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-定位：编译期代码生成</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-自动生成 fromJson / toJson</span><br><span class="line">-类型安全</span><br><span class="line">-性能好</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">中大型项目首选</span><br></pre></td></tr></table></figure><h3 id="3-5-freezed-json-serializable-高级方案"><a href="#3-5-freezed-json-serializable-高级方案" class="headerlink" title="3.5 freezed + json_serializable(高级方案)"></a>3.5 freezed + json_serializable(高级方案)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1-特点：</span><br><span class="line">-不可变对象</span><br><span class="line">-copyWith</span><br><span class="line">-联合类型</span><br><span class="line">-强类型约束</span><br><span class="line"></span><br><span class="line">2-说明：</span><br><span class="line">复杂业务 / 状态模型常用</span><br></pre></td></tr></table></figure><h3 id="3-5-XML-解析-较少"><a href="#3-5-XML-解析-较少" class="headerlink" title="3.5 XML 解析(较少)"></a>3.5 XML 解析(较少)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用场景：</span><br><span class="line">-老接口</span><br><span class="line">-RSS</span><br></pre></td></tr></table></figure><h2 id="四-网络库-解析方式的常见组合"><a href="#四-网络库-解析方式的常见组合" class="headerlink" title="四 网络库 + 解析方式的常见组合"></a>四 网络库 + 解析方式的常见组合</h2><h3 id="4-1-小型项目-Demo"><a href="#4-1-小型项目-Demo" class="headerlink" title="4.1 小型项目 &#x2F; Demo"></a>4.1 小型项目 &#x2F; Demo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http + 手写 fromJson</span><br></pre></td></tr></table></figure><h3 id="4-2-主流-Flutter-项目"><a href="#4-2-主流-Flutter-项目" class="headerlink" title="4.2 主流 Flutter 项目"></a>4.2 主流 Flutter 项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dio + json_serializable</span><br></pre></td></tr></table></figure><h3 id="4-3-接口规范型项目"><a href="#4-3-接口规范型项目" class="headerlink" title="4.3  接口规范型项目"></a>4.3  接口规范型项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retrofit(Dart) + Dio + json_serializable</span><br></pre></td></tr></table></figure><h3 id="4-4-实时通信"><a href="#4-4-实时通信" class="headerlink" title="4.4 实时通信"></a>4.4 实时通信</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebSocket + Model 映射</span><br></pre></td></tr></table></figure><h2 id="五-Flutter-网络层常见封装思路"><a href="#五-Flutter-网络层常见封装思路" class="headerlink" title="五 Flutter 网络层常见封装思路"></a>五 Flutter 网络层常见封装思路</h2><h3 id="5-1-分层结构-推荐"><a href="#5-1-分层结构-推荐" class="headerlink" title="5.1 分层结构(推荐)"></a>5.1 分层结构(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UI</span><br><span class="line"> ↓</span><br><span class="line">ViewModel / Bloc</span><br><span class="line"> ↓</span><br><span class="line">Repository</span><br><span class="line"> ↓</span><br><span class="line">ApiService</span><br><span class="line"> ↓</span><br><span class="line">Dio</span><br></pre></td></tr></table></figure><h3 id="5-2-统一返回结构"><a href="#5-2-统一返回结构" class="headerlink" title="5.2 统一返回结构"></a>5.2 统一返回结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class BaseResponse&lt;T&gt; &#123;</span><br><span class="line">  final int code;</span><br><span class="line">  final String msg;</span><br><span class="line">  final T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Dio-拦截器统一处理"><a href="#5-3-Dio-拦截器统一处理" class="headerlink" title="5.3 Dio 拦截器统一处理"></a>5.3 Dio 拦截器统一处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Header 注入(Token)</span><br><span class="line">日志打印</span><br><span class="line">错误统一转换</span><br><span class="line">重试机制</span><br></pre></td></tr></table></figure><h2 id="六-Flutter-面试高频关注点"><a href="#六-Flutter-面试高频关注点" class="headerlink" title="六 Flutter 面试高频关注点"></a>六 Flutter 面试高频关注点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Dio 与 http 区别</span><br><span class="line">2.json_serializable 原理</span><br><span class="line">3.Flutter 中网络线程模型</span><br><span class="line">4.异常处理如何做</span><br><span class="line">5.Token 刷新机制</span><br><span class="line">6.WebSocket 使用场景</span><br><span class="line">7.跨平台网络一致性</span><br></pre></td></tr></table></figure><h2 id="七-总结一句话"><a href="#七-总结一句话" class="headerlink" title="七 总结一句话"></a>七 总结一句话</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dio 负责网络能力，Model 负责数据结构，代码生成负责性能和规范。</span><br><span class="line"></span><br><span class="line">推荐组合：</span><br><span class="line">-新项目：Dio + json_serializable</span><br><span class="line">-复杂业务：Dio + Retrofit + freezed</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在 Flutter 应用开发中，网络层同样由 网络请求库 + 数据解析方式 两部分组成。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于 Flutter 本身跨平台(Android/iOS/Web/Desktop)，网络与解析方案更强调 一致性、性能和可维护性。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="F-跨平台" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/F-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="Flutter" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/F-%E8%B7%A8%E5%B9%B3%E5%8F%B0/Flutter/"/>
    
    
    <category term="Flutter" scheme="https://pgzxc.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter开发之——常见状态管理</title>
    <link href="https://pgzxc.github.io/posts/ba246823.html"/>
    <id>https://pgzxc.github.io/posts/ba246823.html</id>
    <published>2026-02-20T23:43:19.000Z</published>
    <updated>2026-02-22T02:43:05.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flutter 状态管理一般分为3类：</span><br><span class="line">1.Widget自带状态</span><br><span class="line">2.Inherited/响应式状态</span><br><span class="line">3.架构级状态管理框架</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-状态管理"><a href="#二-状态管理" class="headerlink" title="二 状态管理"></a>二 状态管理</h2><h3 id="2-1-最基础-官方内置"><a href="#2-1-最基础-官方内置" class="headerlink" title="2.1 最基础(官方内置)"></a>2.1 最基础(官方内置)</h3><p>1-setState</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1-定位：局部 UI 状态</span><br><span class="line">2-复杂度：1</span><br><span class="line">3-适合：页面内简单交互</span><br><span class="line">setState(() &#123;</span><br><span class="line">  count++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">4-优点</span><br><span class="line">-学习成本低</span><br><span class="line">-官方推荐入门</span><br><span class="line">-无第三方依赖</span><br><span class="line"></span><br><span class="line">5-缺点</span><br><span class="line">-逻辑和 UI 耦合</span><br><span class="line">-页面复杂后难维护</span><br><span class="line">-跨页面共享状态困难</span><br><span class="line"></span><br><span class="line">6-适合场景</span><br><span class="line">-按钮点击</span><br><span class="line">-切换 tab</span><br><span class="line">-显示/隐藏控件</span><br></pre></td></tr></table></figure><p>2-ValueNotifier &#x2F; ValueListenableBuilder</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1-定位：轻量响应式状态</span><br><span class="line">2-复杂度：2</span><br><span class="line"></span><br><span class="line">final counter = ValueNotifier&lt;int&gt;(0);</span><br><span class="line">ValueListenableBuilder(</span><br><span class="line">  valueListenable: counter,</span><br><span class="line">  builder: (_, value, __) =&gt; Text(&#x27;$value&#x27;),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">3-优点</span><br><span class="line">-比 setState 更解耦</span><br><span class="line">-监听粒度更小</span><br><span class="line">-性能好</span><br><span class="line"></span><br><span class="line">4-缺点</span><br><span class="line">-只适合简单值</span><br><span class="line">-复杂业务不友好</span><br><span class="line"></span><br><span class="line">5-适合场景</span><br><span class="line">-计数器</span><br><span class="line">-loading 状态</span><br><span class="line">-单一字段变化</span><br></pre></td></tr></table></figure><h3 id="2-2-官方推荐体系-主流"><a href="#2-2-官方推荐体系-主流" class="headerlink" title="2.2 官方推荐体系(主流)"></a>2.2 官方推荐体系(主流)</h3><p>1-InheritedWidget &#x2F; InheritedModel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1-定位：Flutter 底层状态共享</span><br><span class="line">2-复杂度：3</span><br><span class="line"></span><br><span class="line">class MyInherited extends InheritedWidget &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">4-优点</span><br><span class="line">-Flutter 核心机制</span><br><span class="line">-性能极好</span><br><span class="line"></span><br><span class="line">5-缺点</span><br><span class="line">-使用复杂</span><br><span class="line">-样板代码多</span><br><span class="line"></span><br><span class="line">一般不直接用，而是用封装好嘅方案(Provider/Riverpod)</span><br></pre></td></tr></table></figure><p>2-Provider(官方推荐)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">基于 InheritedWidget</span><br><span class="line"></span><br><span class="line">1-定位：应用级状态管理</span><br><span class="line">2-复杂度：3</span><br><span class="line">3-热度：4</span><br><span class="line"></span><br><span class="line">ChangeNotifierProvider(</span><br><span class="line">  create: (_) =&gt; CounterModel(),</span><br><span class="line">  child: MyApp(),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">context.watch&lt;CounterModel&gt;().count;</span><br><span class="line"></span><br><span class="line">4-优点</span><br><span class="line">-官方推荐</span><br><span class="line">-学习成本低</span><br><span class="line">-社区成熟</span><br><span class="line"></span><br><span class="line">5-缺点</span><br><span class="line">-ChangeNotifier 易滥用</span><br><span class="line">-状态不可预测（可变）</span><br><span class="line"></span><br><span class="line">6-适合场景</span><br><span class="line">-中小型项目</span><br><span class="line">-快速开发</span><br><span class="line">-传统 MVC/MVVM</span><br></pre></td></tr></table></figure><h3 id="2-3-进阶-现代方案-强烈推荐"><a href="#2-3-进阶-现代方案-强烈推荐" class="headerlink" title="2.3 进阶 &amp; 现代方案(强烈推荐)"></a>2.3 进阶 &amp; 现代方案(强烈推荐)</h3><p>1-Riverpod(Provider 作者新作)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1-定位：现代化状态管理</span><br><span class="line">2-复杂度：4</span><br><span class="line">3-趋势：3</span><br><span class="line"></span><br><span class="line">final counterProvider = StateProvider&lt;int&gt;((ref) =&gt; 0);</span><br><span class="line">ref.watch(counterProvider);</span><br><span class="line"></span><br><span class="line">4-优点</span><br><span class="line">-编译期安全</span><br><span class="line">-不依赖 BuildContext</span><br><span class="line">-更好测试</span><br><span class="line">-支持 async / stream</span><br><span class="line"></span><br><span class="line">5-缺点</span><br><span class="line">-学习曲线略陡</span><br><span class="line"></span><br><span class="line">6-适合场景</span><br><span class="line">-中大型项目</span><br><span class="line">-复杂业务</span><br><span class="line">-新项目首选</span><br><span class="line"></span><br><span class="line">2024+ 新项目强烈推荐</span><br></pre></td></tr></table></figure><p>2-Bloc&#x2F;Cubit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1-定位：事件驱动、严谨架构</span><br><span class="line">2-复杂度：5</span><br><span class="line">3-企业级：3</span><br><span class="line">bloc.add(IncrementEvent());</span><br><span class="line"></span><br><span class="line">4-优点</span><br><span class="line">-状态可预测</span><br><span class="line">-单向数据流</span><br><span class="line">-非常适合团队协作</span><br><span class="line"></span><br><span class="line">5-缺点</span><br><span class="line">-样板代码多</span><br><span class="line">-学习成本高</span><br><span class="line"></span><br><span class="line">6-适合场景</span><br><span class="line">-大型 App</span><br><span class="line">-多人协作</span><br><span class="line">-强业务流程（金融/IM）</span><br></pre></td></tr></table></figure><h3 id="2-4-其他常见方案-了解即可"><a href="#2-4-其他常见方案-了解即可" class="headerlink" title="2.4 其他常见方案(了解即可)"></a>2.4 其他常见方案(了解即可)</h3><p>1-GetX</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1-定位：All-in-one 框架</span><br><span class="line">2-复杂度：2</span><br><span class="line"></span><br><span class="line">3-优点</span><br><span class="line">-上手极快</span><br><span class="line">-少样板代码</span><br><span class="line"></span><br><span class="line">3-缺点</span><br><span class="line">-侵入性强</span><br><span class="line">-隐式魔法多</span><br><span class="line">-官方 Flutter 团队不推荐</span><br><span class="line"></span><br><span class="line">适合个人项目/Demo</span><br></pre></td></tr></table></figure><p>2-MobX</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1-定位：响应式编程</span><br><span class="line">2-复杂度：3</span><br><span class="line"></span><br><span class="line">@observable</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3-优点</span><br><span class="line">-自动响应</span><br><span class="line">-写法优雅</span><br><span class="line"></span><br><span class="line">4-缺点</span><br><span class="line">-依赖代码生成</span><br><span class="line">-Debug 较难</span><br></pre></td></tr></table></figure><h2 id="三-快速对比表"><a href="#三-快速对比表" class="headerlink" title="三 快速对比表"></a>三 快速对比表</h2><table><thead><tr><th align="center">方案</th><th align="center">学习成本</th><th align="center">规模</th><th align="center">推荐指数</th></tr></thead><tbody><tr><td align="center">setState</td><td align="center">1</td><td align="center">小</td><td align="center">2</td></tr><tr><td align="center">ValueNotifier</td><td align="center">2</td><td align="center">小</td><td align="center">3</td></tr><tr><td align="center">Provider</td><td align="center">3</td><td align="center">中</td><td align="center">4</td></tr><tr><td align="center">Riverpod</td><td align="center">4</td><td align="center">中&#x2F;大</td><td align="center">5</td></tr><tr><td align="center">Bloc</td><td align="center">5</td><td align="center">大</td><td align="center">4</td></tr><tr><td align="center">GetX</td><td align="center">2</td><td align="center">小</td><td align="center">2</td></tr></tbody></table><h2 id="四-实战建议"><a href="#四-实战建议" class="headerlink" title="四 实战建议"></a>四 实战建议</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Demo / 小工具 → setState + ValueNotifier</span><br><span class="line">普通商业 App → Riverpod</span><br><span class="line">复杂业务 / 大团队 → Bloc</span><br><span class="line">新项目不建议再选 Provider</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Flutter 状态管理一般分为3类：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.Widget自带状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.Inherited/响应式状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.架构级状态管理框架&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="F-跨平台" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/F-%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="Flutter" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/F-%E8%B7%A8%E5%B9%B3%E5%8F%B0/Flutter/"/>
    
    
    <category term="Flutter" scheme="https://pgzxc.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙开发之——常用网络请求框架和数据解析</title>
    <link href="https://pgzxc.github.io/posts/714fd11c.html"/>
    <id>https://pgzxc.github.io/posts/714fd11c.html</id>
    <published>2026-02-20T03:19:08.000Z</published>
    <updated>2026-02-22T02:43:05.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在鸿蒙应用开发中，</span><br><span class="line">网络能力主要围绕 系统原生API展开，同时在 ArkTS/JS体系下，数据解析方式也更加偏向JSON+类型映射。</span><br><span class="line">与Android/iOS 不同，鸿蒙目前第三方网络库生态较少，以官方能力为主。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-鸿蒙常用网络请求方式"><a href="#二-鸿蒙常用网络请求方式" class="headerlink" title="二 鸿蒙常用网络请求方式"></a>二 鸿蒙常用网络请求方式</h2><h3 id="2-1-HTTP-HTTPS-主流"><a href="#2-1-HTTP-HTTPS-主流" class="headerlink" title="2.1 HTTP &#x2F; HTTPS(主流)"></a>2.1 HTTP &#x2F; HTTPS(主流)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">适用于：</span><br><span class="line">-接口数据请求</span><br><span class="line">-登录/列表/配置下发</span><br><span class="line">-业务数据同步</span><br></pre></td></tr></table></figure><h3 id="2-2-WebSocket-实时通信"><a href="#2-2-WebSocket-实时通信" class="headerlink" title="2.2 WebSocket(实时通信)"></a>2.2 WebSocket(实时通信)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">适用于：</span><br><span class="line">-即时消息</span><br><span class="line">-实时推送</span><br><span class="line">-设备状态同步</span><br></pre></td></tr></table></figure><h2 id="三-鸿蒙常用网络库-网络能力"><a href="#三-鸿蒙常用网络库-网络能力" class="headerlink" title="三 鸿蒙常用网络库&#x2F;网络能力"></a>三 鸿蒙常用网络库&#x2F;网络能力</h2><h3 id="3-1-ohos-net-http-主流官方方案"><a href="#3-1-ohos-net-http-主流官方方案" class="headerlink" title="3.1 @ohos.net.http(主流官方方案)"></a>3.1 @ohos.net.http(主流官方方案)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1-定位：鸿蒙官方 HTTP 网络模块</span><br><span class="line">2-适用语言：ArkTS / JS</span><br><span class="line"></span><br><span class="line">3-核心能力：</span><br><span class="line">-HTTP/HTTPS 请求</span><br><span class="line">-GET/POST/PUT/DELETE</span><br><span class="line">-Header/参数配置</span><br><span class="line">-Promise/Callback 风格</span><br><span class="line">-支持超时、证书配置</span><br><span class="line"></span><br><span class="line">4-特点：</span><br><span class="line">-官方维护，稳定可靠</span><br><span class="line">-与系统权限、生命周期结合紧密</span><br><span class="line">-生态最成熟</span><br><span class="line"></span><br><span class="line">5-说明：</span><br><span class="line">鸿蒙应用网络请求首选方案</span><br></pre></td></tr></table></figure><h3 id="3-2-fetch-API-轻量级"><a href="#3-2-fetch-API-轻量级" class="headerlink" title="3.2 fetch API(轻量级)"></a>3.2 fetch API(轻量级)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1-来源：Web 标准 API</span><br><span class="line">2-支持环境：ArkTS/JS</span><br><span class="line"></span><br><span class="line">3-特点：</span><br><span class="line">-语法简单</span><br><span class="line">-Promise 风格</span><br><span class="line">-上手成本低</span><br><span class="line"></span><br><span class="line">4-不足：</span><br><span class="line">-功能相对简单</span><br><span class="line">-拦截、统一处理能力有限</span><br><span class="line"></span><br><span class="line">5-说明：</span><br><span class="line">适合简单请求/小型应用</span><br></pre></td></tr></table></figure><h3 id="3-3-WebSocket-ohos-net-webSocket"><a href="#3-3-WebSocket-ohos-net-webSocket" class="headerlink" title="3.3  WebSocket(@ohos.net.webSocket)"></a>3.3  WebSocket(@ohos.net.webSocket)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1-定位：官方 WebSocket 模块</span><br><span class="line"></span><br><span class="line">2-使用场景：</span><br><span class="line">-聊天</span><br><span class="line">-实时推送</span><br><span class="line">-IoT 状态通信</span><br></pre></td></tr></table></figure><h3 id="3-4-第三方网络库-较少"><a href="#3-4-第三方网络库-较少" class="headerlink" title="3.4 第三方网络库(较少)"></a>3.4 第三方网络库(较少)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">目前鸿蒙生态中：</span><br><span class="line">-类 Retrofit / OkHttp 的成熟库较少</span><br><span class="line">-大多基于官方 HTTP 再封装</span><br><span class="line">-企业项目通常自研网络封装层</span><br><span class="line"></span><br><span class="line">鸿蒙网络层以“自封装”为主</span><br></pre></td></tr></table></figure><h2 id="四-鸿蒙常用数据解析方式"><a href="#四-鸿蒙常用数据解析方式" class="headerlink" title="四 鸿蒙常用数据解析方式"></a>四 鸿蒙常用数据解析方式</h2><h3 id="4-1-JSON-绝对主流"><a href="#4-1-JSON-绝对主流" class="headerlink" title="4.1 JSON(绝对主流)"></a>4.1 JSON(绝对主流)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">鸿蒙前后端交互几乎全部使用 JSON：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 0,</span><br><span class="line">  &quot;data&quot;: &#123;&#125;,</span><br><span class="line">  &quot;msg&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-JSON-parse-JSON-stringify-基础方式"><a href="#3-2-JSON-parse-JSON-stringify-基础方式" class="headerlink" title="3.2 JSON.parse&#x2F;JSON.stringify(基础方式)"></a>3.2 JSON.parse&#x2F;JSON.stringify(基础方式)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1-最常用、最基础：</span><br><span class="line">const obj = JSON.parse(response);</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-无依赖</span><br><span class="line">-简单直接</span><br><span class="line">-无类型约束</span><br></pre></td></tr></table></figure><h3 id="3-3-ArkTS-类型映射-推荐"><a href="#3-3-ArkTS-类型映射-推荐" class="headerlink" title="3.3 ArkTS 类型映射(推荐)"></a>3.3 ArkTS 类型映射(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1-在 ArkTS 中，通常结合 interface / class 做数据约束：</span><br><span class="line"></span><br><span class="line">interface BaseResponse&lt;T&gt; &#123;</span><br><span class="line">  code: number;</span><br><span class="line">  msg: string;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2-优势：</span><br><span class="line">-可读性好</span><br><span class="line">-代码规范</span><br><span class="line">-便于维护</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">工程中最常见做法</span><br></pre></td></tr></table></figure><h3 id="3-4-第三方-JSON-解析库-少量"><a href="#3-4-第三方-JSON-解析库-少量" class="headerlink" title="3.4 第三方 JSON 解析库(少量)"></a>3.4 第三方 JSON 解析库(少量)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1-部分项目会使用：</span><br><span class="line">-fast-json（JS 方案）</span><br><span class="line">-手写映射工具</span><br><span class="line"></span><br><span class="line">2-说明：</span><br><span class="line">但总体不如 Android/iOS 成熟。</span><br></pre></td></tr></table></figure><h3 id="3-5-XML-解析-较少"><a href="#3-5-XML-解析-较少" class="headerlink" title="3.5 XML 解析(较少)"></a>3.5 XML 解析(较少)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用场景：</span><br><span class="line">-老系统</span><br><span class="line">-特殊设备协议</span><br></pre></td></tr></table></figure><h2 id="四-网络请求-解析的典型封装思路-鸿蒙"><a href="#四-网络请求-解析的典型封装思路-鸿蒙" class="headerlink" title="四 网络请求 + 解析的典型封装思路(鸿蒙)"></a>四 网络请求 + 解析的典型封装思路(鸿蒙)</h2><h3 id="4-1-分层结构-推荐"><a href="#4-1-分层结构-推荐" class="headerlink" title="4.1 分层结构(推荐)"></a>4.1 分层结构(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UI (Page / Ability)</span><br><span class="line">   ↓</span><br><span class="line">ViewModel</span><br><span class="line">   ↓</span><br><span class="line">Repository</span><br><span class="line">   ↓</span><br><span class="line">HttpService（@ohos.net.http 封装）</span><br></pre></td></tr></table></figure><h3 id="4-2-统一返回结构"><a href="#4-2-统一返回结构" class="headerlink" title="4.2 统一返回结构"></a>4.2 统一返回结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface BaseResponse&lt;T&gt; &#123;</span><br><span class="line">  code: number;</span><br><span class="line">  msg: string;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-统一错误处理"><a href="#4-3-统一错误处理" class="headerlink" title="4.3 统一错误处理"></a>4.3 统一错误处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-网络异常</span><br><span class="line">-HTTP 状态码</span><br><span class="line">-业务错误码</span><br><span class="line">-登录失效</span><br></pre></td></tr></table></figure><h3 id="4-4-Header-Token-统一注入"><a href="#4-4-Header-Token-统一注入" class="headerlink" title="4.4 Header &#x2F; Token 统一注入"></a>4.4 Header &#x2F; Token 统一注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-请求前统一注入 Token</span><br><span class="line">-统一 User-Agent</span><br><span class="line">-日志开关控制</span><br></pre></td></tr></table></figure><h2 id="五-鸿蒙与-Android-iOS-网络差异"><a href="#五-鸿蒙与-Android-iOS-网络差异" class="headerlink" title="五 鸿蒙与 Android&#x2F;iOS 网络差异"></a>五 鸿蒙与 Android&#x2F;iOS 网络差异</h2><table><thead><tr><th align="center">对比项</th><th align="center">鸿蒙</th><th align="center">Android</th><th align="center">iOS</th></tr></thead><tbody><tr><td align="center">底层网络</td><td align="center">官方模块</td><td align="center">OkHttp</td><td align="center">URLSession</td></tr><tr><td align="center">主流封装</td><td align="center">自封装</td><td align="center">Retrofit</td><td align="center">Alamofire</td></tr><tr><td align="center">JSON 解析</td><td align="center">JSON.parse</td><td align="center">Gson &#x2F; Moshi</td><td align="center">Codable</td></tr><tr><td align="center">第三方生态</td><td align="center">较少</td><td align="center">非常成熟</td><td align="center">成熟</td></tr><tr><td align="center">网络层模式</td><td align="center">官方优先</td><td align="center">社区优先</td><td align="center">官方 + 社区</td></tr></tbody></table><h2 id="六-面试高频关注点"><a href="#六-面试高频关注点" class="headerlink" title="六 面试高频关注点"></a>六 面试高频关注点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.鸿蒙常用网络模块有哪些</span><br><span class="line">2.@ohos.net.http 与 fetch 的区别</span><br><span class="line">3.ArkTS 中如何做数据解析</span><br><span class="line">4.网络请求权限如何配置</span><br><span class="line">5.网络异常如何统一处理</span><br><span class="line">6.鸿蒙网络层如何封装</span><br><span class="line">7.WebSocket 使用场景</span><br></pre></td></tr></table></figure><h2 id="七-总结一句话"><a href="#七-总结一句话" class="headerlink" title="七 总结一句话"></a>七 总结一句话</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鸿蒙网络开发以官方能力为核心，JSON.parse 为基础，ArkTS 类型约束为规范，自封装网络层为主流实践。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在鸿蒙应用开发中，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;网络能力主要围绕 系统原生API展开，同时在 ArkTS/JS体系下，数据解析方式也更加偏向JSON+类型映射。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;与Android/iOS 不同，鸿蒙目前第三方网络库生态较少，以官方能力为主。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="HarmonyOS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/HarmonyOS/"/>
    
    
    <category term="HarmonyOS" scheme="https://pgzxc.github.io/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙开发之——常见状态管理</title>
    <link href="https://pgzxc.github.io/posts/5dd3d8ea.html"/>
    <id>https://pgzxc.github.io/posts/5dd3d8ea.html</id>
    <published>2026-02-19T00:00:45.000Z</published>
    <updated>2026-02-22T02:43:05.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">鸿蒙主流状态管理 = ArkUI 状态装饰器 + 单向数据流</span><br><span class="line">中大型项目：UI 状态在组件，业务状态在 ViewModel/Store</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-几种状态管理对比"><a href="#二-几种状态管理对比" class="headerlink" title="二 几种状态管理对比"></a>二 几种状态管理对比</h2><table><thead><tr><th align="center">平台</th><th align="center">核心</th></tr></thead><tbody><tr><td align="center">RN</td><td align="center">JS 全局 Store</td></tr><tr><td align="center">Flutter</td><td align="center">Widget 树</td></tr><tr><td align="center">Android</td><td align="center">ViewModel</td></tr><tr><td align="center">鸿蒙</td><td align="center">ArkUI 状态驱动 UI</td></tr></tbody></table><p>说明：ArkUI 本身就是状态驱动框架</p><h2 id="三-状态管理"><a href="#三-状态管理" class="headerlink" title="三 状态管理"></a>三 状态管理</h2><h3 id="3-1-ArkUI-内置状态管理-最常用"><a href="#3-1-ArkUI-内置状态管理-最常用" class="headerlink" title="3.1 ArkUI 内置状态管理(最常用)"></a>3.1 ArkUI 内置状态管理(最常用)</h3><p>1-@State(组件私有状态)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@State count: number = 0;</span><br><span class="line">Button(&#x27;+&#x27;)</span><br><span class="line">  .onClick(() =&gt; &#123;</span><br><span class="line">    this.count++;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">2-特点</span><br><span class="line">-自动刷新 UI</span><br><span class="line">-生命周期随组件</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">类似 Flutter setState / SwiftUI @State</span><br></pre></td></tr></table></figure><p>2-@Prop(父 → 子传值)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@Prop title: string;</span><br><span class="line"></span><br><span class="line">2-说明</span><br><span class="line">单向数据流，子组件不可直接修改</span><br></pre></td></tr></table></figure><p>3-@Link(双向绑定)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@Link count: number;</span><br><span class="line"></span><br><span class="line">2-说明</span><br><span class="line">慎用，容易造成状态耦合</span><br></pre></td></tr></table></figure><p>4-@Provide &#x2F; @Consume(跨组件)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@Provide(&#x27;user&#x27;) user: User;</span><br><span class="line">@Consume(&#x27;user&#x27;) user: User;</span><br><span class="line"></span><br><span class="line">2-类似</span><br><span class="line">-RN Context</span><br><span class="line">-Flutter InheritedWidget</span><br><span class="line"></span><br><span class="line">3-说明</span><br><span class="line">滥用会导致隐式依赖</span><br></pre></td></tr></table></figure><h3 id="3-2-全局-应用级状态-重点"><a href="#3-2-全局-应用级状态-重点" class="headerlink" title="3.2 全局&#x2F;应用级状态(重点)"></a>3.2 全局&#x2F;应用级状态(重点)</h3><p>1-AppStorage(全局状态)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">AppStorage.SetOrCreate(&#x27;token&#x27;, &#x27;&#x27;);</span><br><span class="line">@StorageLink(&#x27;token&#x27;) token: string;</span><br><span class="line"></span><br><span class="line">2-特点</span><br><span class="line">-全局共享</span><br><span class="line">-支持持久化</span><br><span class="line"></span><br><span class="line">3-场景：</span><br><span class="line">适合登录态 / 用户信息</span><br></pre></td></tr></table></figure><p>2-LocalStorage(页面级)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">let storage = new LocalStorage();</span><br><span class="line">@LocalStorageLink(&#x27;count&#x27;) count: number;</span><br><span class="line"></span><br><span class="line">2-说明</span><br><span class="line">页面级状态共享</span><br></pre></td></tr></table></figure><h3 id="3-3-企业级做法-非常重要"><a href="#3-3-企业级做法-非常重要" class="headerlink" title="3.3 企业级做法(非常重要)"></a>3.3 企业级做法(非常重要)</h3><p>1-ViewModel&#x2F;Store 模式(推荐)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1-说明</span><br><span class="line">ArkUI 本身不限制你如何组织业务状态</span><br><span class="line"></span><br><span class="line">2-示例(简化)</span><br><span class="line">//定义</span><br><span class="line">class CounterViewModel &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.state.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">@State vm: CounterViewModel = new CounterViewModel();</span><br><span class="line"></span><br><span class="line">3-推荐模式</span><br><span class="line">UI（ArkUI）</span><br><span class="line">  ↓</span><br><span class="line">ViewModel</span><br><span class="line">  ↓</span><br><span class="line">Service / Repository</span><br></pre></td></tr></table></figure><h3 id="3-4-单向数据流-进阶"><a href="#3-4-单向数据流-进阶" class="headerlink" title="3.4 单向数据流(进阶)"></a>3.4 单向数据流(进阶)</h3><p>1-MVI &#x2F; Redux 思想(可选)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1-流程</span><br><span class="line">Action → Reducer → State → UI</span><br><span class="line"></span><br><span class="line">2-说明</span><br><span class="line">-鸿蒙官方未强制</span><br><span class="line">-复杂业务项目常见</span><br></pre></td></tr></table></figure><h2 id="四-鸿蒙状态管理方案对比"><a href="#四-鸿蒙状态管理方案对比" class="headerlink" title="四 鸿蒙状态管理方案对比"></a>四 鸿蒙状态管理方案对比</h2><table><thead><tr><th align="center">方案</th><th align="center">作用域</th><th align="center">推荐指数</th></tr></thead><tbody><tr><td align="center">@State</td><td align="center">组件</td><td align="center">5颗星</td></tr><tr><td align="center">@Prop</td><td align="center">父子</td><td align="center">5颗星</td></tr><tr><td align="center">@Provide</td><td align="center">跨组件</td><td align="center">3颗星</td></tr><tr><td align="center">AppStorage</td><td align="center">全局</td><td align="center">4颗星</td></tr><tr><td align="center">ViewModel</td><td align="center">业务层</td><td align="center">5颗星</td></tr><tr><td align="center">Redux&#x2F;MVI</td><td align="center">复杂业务</td><td align="center">4颗星</td></tr></tbody></table><h2 id="五-和其他平台的对照"><a href="#五-和其他平台的对照" class="headerlink" title="五 和其他平台的对照"></a>五 和其他平台的对照</h2><table><thead><tr><th align="center">思想</th><th align="center">RN</th><th align="center">Flutter</th><th align="center">Android</th><th align="center">iOS</th><th align="center">鸿蒙</th></tr></thead><tbody><tr><td align="center">局部状态</td><td align="center">useState</td><td align="center">setState</td><td align="center">remember</td><td align="center">@State</td><td align="center">@State</td></tr><tr><td align="center">父子传递</td><td align="center">props</td><td align="center">widget</td><td align="center">params</td><td align="center">@Binding</td><td align="center">@Prop</td></tr><tr><td align="center">全局状态</td><td align="center">Zustand</td><td align="center">Riverpod</td><td align="center">StateFlow</td><td align="center">EnvObj</td><td align="center">AppStorage</td></tr><tr><td align="center">Redux</td><td align="center">RTK</td><td align="center">Bloc</td><td align="center">MVI</td><td align="center">TCA</td><td align="center">MVI</td></tr></tbody></table><h2 id="六-实战选型建议"><a href="#六-实战选型建议" class="headerlink" title="六 实战选型建议"></a>六 实战选型建议</h2><h3 id="6-1-小型页面"><a href="#6-1-小型页面" class="headerlink" title="6.1 小型页面"></a>6.1 小型页面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@State + @Prop</span><br></pre></td></tr></table></figure><h3 id="6-2-中型应用"><a href="#6-2-中型应用" class="headerlink" title="6.2 中型应用"></a>6.2 中型应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@State</span><br><span class="line"> + ViewModel</span><br><span class="line"> + AppStorage（少量）</span><br></pre></td></tr></table></figure><h3 id="6-3-大型-企业项目"><a href="#6-3-大型-企业项目" class="headerlink" title="6.3 大型 &#x2F; 企业项目"></a>6.3 大型 &#x2F; 企业项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewModel / Store</span><br><span class="line"> + 单向数据流（MVI）</span><br><span class="line"> + ArkUI 只负责渲染</span><br></pre></td></tr></table></figure><h3 id="6-4-不推荐"><a href="#6-4-不推荐" class="headerlink" title="6.4 不推荐"></a>6.4 不推荐</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有状态都丢 AppStorage</span><br><span class="line">大量使用 @Link</span><br><span class="line">UI 里写业务逻辑</span><br></pre></td></tr></table></figure><h2 id="七-一句话总结"><a href="#七-一句话总结" class="headerlink" title="七 一句话总结"></a>七 一句话总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鸿蒙状态管理不是选库，而是用好 ArkUI 的状态装饰器</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;鸿蒙主流状态管理 = ArkUI 状态装饰器 + 单向数据流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;中大型项目：UI 状态在组件，业务状态在 ViewModel/Store&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="HarmonyOS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/HarmonyOS/"/>
    
    
    <category term="状态管理" scheme="https://pgzxc.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
    <category term="HarmonyOS" scheme="https://pgzxc.github.io/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——IOS与安卓组件对比-3</title>
    <link href="https://pgzxc.github.io/posts/86691e61.html"/>
    <id>https://pgzxc.github.io/posts/86691e61.html</id>
    <published>2026-02-17T23:38:29.000Z</published>
    <updated>2026-02-22T02:43:05.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文介绍：</span><br><span class="line"> - iOS(SwiftUI/UIKit)与 Android(Jetpack Compose/XML)的组件</span><br><span class="line"> - 分为:基础布局、交互控件、列表与适配器、弹窗与提示、进度与反馈、图片与媒体、数据与表单以及高级组件</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-对比"><a href="#二-对比" class="headerlink" title="二 对比"></a>二 对比</h2><h3 id="2-1-基础布局-Layouts"><a href="#2-1-基础布局-Layouts" class="headerlink" title="2.1 基础布局 (Layouts)"></a>2.1 基础布局 (Layouts)</h3><p>这是构建界面的基石，用于组织子视图的排列方式。</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS (SwiftUI &#x2F; UIKit)</th><th align="center">Android (Compose &#x2F; XML)</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">垂直排列</td><td align="center">VStack &#x2F; UIStackView(.vertical)</td><td align="center">Column &#x2F; LinearLayout(vertical)</td><td align="center">最常用的布局</td></tr><tr><td align="center">水平排列</td><td align="center">HStack &#x2F; UIStackView(.horizontal)</td><td align="center">Row &#x2F; LinearLayout(horizontal)</td><td align="center">最常用的布局</td></tr><tr><td align="center">层叠布局</td><td align="center">ZStack &#x2F; UIView (addSubview)</td><td align="center">Box &#x2F; FrameLayout</td><td align="center">用于覆盖效果(如加蒙版)</td></tr><tr><td align="center">滚动布局</td><td align="center">ScrollView</td><td align="center">ScrollView</td><td align="center">单一方向滚动</td></tr><tr><td align="center">网格布局</td><td align="center">LazyVGrid &#x2F; UICollectionView</td><td align="center">LazyVerticalGrid &#x2F; RecyclerView(GridLayout)</td><td align="center">瀑布流或表格</td></tr><tr><td align="center">相对布局</td><td align="center">RelativeLayout (UIKit 需手动约束) &#x2F; Spacer</td><td align="center">ConstraintLayout &#x2F; Modifier.align</td><td align="center">复杂的相对位置关系</td></tr><tr><td align="center">自适应布局</td><td align="center">GeometryReader</td><td align="center">BoxWithConstraints &#x2F; ConstraintLayout</td><td align="center">获取父容器尺寸</td></tr><tr><td align="center">表单列表</td><td align="center">Form &#x2F; UITableView (Style: Grouped)</td><td align="center">LazyColumn + Card &#x2F; PreferenceFragment</td><td align="center">设置页面常用</td></tr></tbody></table><h3 id="2-2-交互控件-Interactive-Controls"><a href="#2-2-交互控件-Interactive-Controls" class="headerlink" title="2.2 交互控件 (Interactive Controls)"></a>2.2 交互控件 (Interactive Controls)</h3><p>用户直接操作的 UI 元素</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS</th><th align="center">Android</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">按钮</td><td align="center">Button &#x2F; UIButton</td><td align="center">Button &#x2F; AppCompatButton</td><td align="center">可自定义样式</td></tr><tr><td align="center">文本输入框</td><td align="center">TextField &#x2F; UITextField</td><td align="center">TextField &#x2F; EditText</td><td align="center">单行输入</td></tr><tr><td align="center">多行文本框</td><td align="center">TextEditor &#x2F; UITextView</td><td align="center">BasicTextField (maxLines) &#x2F; TextView</td><td align="center">多行输入</td></tr><tr><td align="center">开关</td><td align="center">Toggle &#x2F; UISwitch</td><td align="center">Switch &#x2F; SwitchCompat</td><td align="center">开 &#x2F; 关状态</td></tr><tr><td align="center">复选框</td><td align="center">Toggle(isOn:) (自定义样式) &#x2F; UIButton</td><td align="center">Checkbox &#x2F; MaterialCheckbox</td><td align="center">多选</td></tr><tr><td align="center">单选按钮</td><td align="center">Picker (Segmented) &#x2F; UIButton组</td><td align="center">RadioButton &#x2F; MaterialRadioButton</td><td align="center">单选</td></tr><tr><td align="center">滑块</td><td align="center">Slider &#x2F; UISlider</td><td align="center">Slider &#x2F; SeekBar</td><td align="center">连续值选择</td></tr><tr><td align="center">步进器</td><td align="center">Stepper &#x2F; UIStepper</td><td align="center">NumberPicker &#x2F; 自定义 Compose 组件</td><td align="center">整数增减</td></tr><tr><td align="center">日期选择</td><td align="center">DatePicker &#x2F; UIDatePicker</td><td align="center">DatePicker &#x2F; MaterialDatePicker</td><td align="center">选择时间 &#x2F; 日期</td></tr><tr><td align="center">下拉选择</td><td align="center">Picker (Menu) &#x2F; UIPickerView</td><td align="center">DropdownMenu &#x2F; Spinner</td><td align="center">弹出列表选择</td></tr><tr><td align="center">分段控制器</td><td align="center">Picker(selection: .segmented) &#x2F; UISegmentedControl</td><td align="center">TabRow &#x2F; RadioGroup (模拟)</td><td align="center">顶部或中部的选项卡</td></tr><tr><td align="center">搜索框</td><td align="center">SearchField &#x2F; UISearchBar</td><td align="center">SearchBar &#x2F; AppCompatSearchView</td><td align="center">带放大镜图标的输入</td></tr></tbody></table><h3 id="2-3-列表与集合-Lists-Collections"><a href="#2-3-列表与集合-Lists-Collections" class="headerlink" title="2.3 列表与集合 (Lists &amp; Collections)"></a>2.3 列表与集合 (Lists &amp; Collections)</h3><p>用于展示大量数据</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS</th><th align="center">Android</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">长列表</td><td align="center">List &#x2F; UITableView</td><td align="center">LazyColumn &#x2F; RecyclerView</td><td align="center">复用视图，性能优化</td></tr><tr><td align="center">网格列表</td><td align="center">LazyVGrid &#x2F; UICollectionView</td><td align="center">LazyVerticalGrid &#x2F; RecyclerView(Grid)</td><td align="center">多列展示</td></tr><tr><td align="center">瀑布流</td><td align="center">UICollectionView (CompositionalLayout)</td><td align="center">RecyclerView (StaggeredGrid)</td><td align="center">高度不固定的网格</td></tr><tr><td align="center">侧滑删除</td><td align="center">onDelete modifier &#x2F; UITableView Editing</td><td align="center">SwipeToDismiss &#x2F; ItemTouchHelper</td><td align="center">列表项滑动操作</td></tr><tr><td align="center">下拉刷新</td><td align="center">Refreshable &#x2F; UIRefreshControl</td><td align="center">PullRefresh &#x2F; SwipeRefreshLayout</td><td align="center">刷新数据</td></tr><tr><td align="center">上拉加载</td><td align="center">onAppear 检测 &#x2F; UIScrollViewDelegate</td><td align="center">LazyListState 检测 &#x2F; EndlessRecyclerView</td><td align="center">加载更多数据</td></tr></tbody></table><h3 id="2-4-弹窗与提示-Popups-Alerts"><a href="#2-4-弹窗与提示-Popups-Alerts" class="headerlink" title="2.4 弹窗与提示 (Popups &amp; Alerts)"></a>2.4 弹窗与提示 (Popups &amp; Alerts)</h3><p>用于打断流程或提供额外信息。</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS</th><th align="center">Android</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">警告弹窗</td><td align="center">Alert &#x2F; UIAlertController(.alert)</td><td align="center">AlertDialog &#x2F; MaterialAlertDialogBuilder</td><td align="center">系统样式弹窗</td></tr><tr><td align="center">底部弹窗</td><td align="center">ActionSheet &#x2F; UIAlertController(.actionSheet)</td><td align="center">ModalBottomSheet &#x2F; BottomSheetDialog</td><td align="center">从底部滑出</td></tr><tr><td align="center">全屏覆盖</td><td align="center">fullScreenCover &#x2F; UIModalPresentationStyle</td><td align="center">Dialog (fullscreen) &#x2F; Activity</td><td align="center">覆盖整个屏幕的弹窗</td></tr><tr><td align="center">轻提示 (Toast)</td><td align="center">Toast (SwiftUI 需自定义) &#x2F; UIAlertView (旧)</td><td align="center">Toast &#x2F; Snackbar</td><td align="center">短暂提示，不可交互</td></tr><tr><td align="center">Snackbar</td><td align="center">Snackbar (iOS 16+ SwiftUI) &#x2F; TSMessage (第三方)</td><td align="center">Snackbar &#x2F; SnackbarHost</td><td align="center">底部提示，可交互(带按钮)</td></tr><tr><td align="center">指示器 (HUD)</td><td align="center">ProgressView (overlay) &#x2F; MBProgressHUD (第三方)</td><td align="center">CircularProgressIndicator (overlay) &#x2F; ProgressDialog</td><td align="center">加载中遮罩</td></tr></tbody></table><h3 id="2-5-进度与反馈-Progress-Feedback"><a href="#2-5-进度与反馈-Progress-Feedback" class="headerlink" title="2.5 进度与反馈 (Progress &amp; Feedback)"></a>2.5 进度与反馈 (Progress &amp; Feedback)</h3><p>展示任务进度或状态。</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS</th><th align="center">Android</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">圆形进度条</td><td align="center">ProgressView (circular) &#x2F; UIActivityIndicatorView</td><td align="center">CircularProgressIndicator &#x2F; ProgressBar(style&#x3D;circular)</td><td align="center">加载中</td></tr><tr><td align="center">线性进度条</td><td align="center">ProgressView (linear) &#x2F; UIProgressView</td><td align="center">LinearProgressIndicator &#x2F; ProgressBar(style&#x3D;horizontal)</td><td align="center">下载 &#x2F; 上传进度</td></tr><tr><td align="center">评分条</td><td align="center">RatingView (需自定义) &#x2F; HCSStarRatingView</td><td align="center">RatingBar &#x2F; MaterialRatingBar</td><td align="center">星级评分</td></tr><tr><td align="center">分割线</td><td align="center">Divider &#x2F; UIView (背景色)</td><td align="center">Divider &#x2F; View (height&#x3D;1)</td><td align="center">分隔列表项</td></tr></tbody></table><h3 id="2-6-图片与媒体-Images-Media"><a href="#2-6-图片与媒体-Images-Media" class="headerlink" title="2.6 图片与媒体 (Images &amp; Media)"></a>2.6 图片与媒体 (Images &amp; Media)</h3><p>展示视觉内容。</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS</th><th align="center">Android</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">图片视图</td><td align="center">Image &#x2F; UIImageView</td><td align="center">Image &#x2F; ImageView</td><td align="center">加载本地或网络图片</td></tr><tr><td align="center">网络图片</td><td align="center">AsyncImage &#x2F; SDWebImage</td><td align="center">AsyncImage &#x2F; Coil &#x2F; Glide</td><td align="center">自动缓存、加载</td></tr><tr><td align="center">图标</td><td align="center">Image(systemName:) (SF Symbols) &#x2F; UIImage</td><td align="center">Icon &#x2F; VectorDrawable</td><td align="center">矢量图标支持</td></tr><tr><td align="center">WebView</td><td align="center">WebView &#x2F; WKWebView</td><td align="center">WebView &#x2F; AndroidWebView</td><td align="center">展示网页</td></tr><tr><td align="center">视频播放</td><td align="center">VideoPlayer &#x2F; AVPlayerViewController</td><td align="center">VideoPlayer &#x2F; ExoPlayer</td><td align="center">播放本地或网络视频</td></tr></tbody></table><h3 id="2-7-数据与表单-Data-Forms"><a href="#2-7-数据与表单-Data-Forms" class="headerlink" title="2.7 数据与表单 (Data &amp; Forms)"></a>2.7 数据与表单 (Data &amp; Forms)</h3><p>处理用户输入和数据展示。</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS</th><th align="center">Android</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">图表</td><td align="center">SwiftUICharts (iOS 16+) &#x2F; Charts (UIKit)</td><td align="center">MPAndroidChart &#x2F; Compose UI Charts</td><td align="center">折线图、柱状图等</td></tr><tr><td align="center">二维码</td><td align="center">CodeScanner &#x2F; AVFoundation</td><td align="center">BarcodeScanner &#x2F; ZXing</td><td align="center">扫描或生成二维码</td></tr><tr><td align="center">地图</td><td align="center">Map (MapKit) &#x2F; MKMapView</td><td align="center">Map (Maps Compose) &#x2F; MapView</td><td align="center">集成高德 &#x2F; 百度 &#x2F; Google</td></tr><tr><td align="center">日历</td><td align="center">CalendarView (需自定义) &#x2F; FSCalendar</td><td align="center">CalendarView &#x2F; Compose Calendar</td><td align="center">月历视图</td></tr></tbody></table><h3 id="2-8-高级-容器组件-Advanced-Containers"><a href="#2-8-高级-容器组件-Advanced-Containers" class="headerlink" title="2.8 高级 &#x2F; 容器组件 (Advanced&#x2F;Containers)"></a>2.8 高级 &#x2F; 容器组件 (Advanced&#x2F;Containers)</h3><p>用于构建复杂的页面结构。</p><table><thead><tr><th align="center">功能描述</th><th align="center">iOS</th><th align="center">Android</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">页面导航</td><td align="center">NavigationStack &#x2F; UINavigationController</td><td align="center">NavHost &#x2F; NavigationComponent</td><td align="center">页面跳转、栈管理</td></tr><tr><td align="center">底部标签</td><td align="center">TabView &#x2F; UITabBarController</td><td align="center">BottomNavigation &#x2F; TabLayout</td><td align="center">应用主界面常用</td></tr><tr><td align="center">抽屉菜单</td><td align="center">SidebarList &#x2F; UISplitViewController</td><td align="center">ModalDrawer &#x2F; NavigationView (Drawer)</td><td align="center">侧边栏菜单</td></tr><tr><td align="center">卡片视图</td><td align="center">Card (需自定义) &#x2F; UIView (shadow)</td><td align="center">Card &#x2F; MaterialCardView</td><td align="center">带阴影和圆角的容器</td></tr><tr><td align="center">折叠面板</td><td align="center">DisclosureGroup &#x2F; UITableView (expandable)</td><td align="center">ExpandableCard &#x2F; CollapsingToolbar</td><td align="center">展开 &#x2F; 收起内容</td></tr><tr><td align="center">视差滚动</td><td align="center">ScrollView + GeometryReader</td><td align="center">NestedScrollView + CollapsingToolbarLayout</td><td align="center">头部图片随滚动缩放</td></tr></tbody></table><h2 id="三-总结：核心差异点"><a href="#三-总结：核心差异点" class="headerlink" title="三 总结：核心差异点"></a>三 总结：核心差异点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1、声明式 vs 命令式 (当前主流)：</span><br><span class="line">-iOS: 官方已全面转向 SwiftUI(声明式)，但UIKit(命令式) 依然是存量代码的主力。</span><br><span class="line">-Android: 官方已全面转向 Jetpack Compose(声明式)，但 XML + Kotlin/Java(命令式) 依然广泛使用。</span><br><span class="line"></span><br><span class="line">2、列表性能：</span><br><span class="line">iOS: UITableView 和 UICollectionView 是业界标杆，复用机制极其成熟。</span><br><span class="line">SwiftUI 的 List 和 LazyVGrid 在底层也是基于它们实现的。</span><br><span class="line"></span><br><span class="line">Android: RecyclerView 是 Android 的列表王者，性能极佳。</span><br><span class="line">Compose 的 LazyColumn 也是基于 RecyclerView 的思想实现的。</span><br><span class="line"></span><br><span class="line">3、组件一致性：</span><br><span class="line">iOS: 系统组件(UIKit)的样式非常统一，很难做出颠覆性的改变，</span><br><span class="line">这保证了 App 风格符合 iOS 设计规范 (Human Interface Guidelines)。</span><br><span class="line"></span><br><span class="line">Android: 系统组件(Material Design)高度可定制，</span><br><span class="line">开发者可以轻松修改颜色、形状、动画，甚至完全重写一个组件的外观。</span><br><span class="line"></span><br><span class="line">4、特殊组件：</span><br><span class="line">iOS 特有：UISegmentedControl(分段控制器)、UIDatePicker(滚轮式日期选择)、SF Symbols(系统图标库)。</span><br><span class="line">Android 特有：Snackbar(底部交互提示)、DrawerLayout(抽屉)、ConstraintLayout(强大的相对布局)。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - iOS(SwiftUI/UIKit)与 Android(Jetpack Compose/XML)的组件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 分为:基础布局、交互控件、列表与适配器、弹窗与提示、进度与反馈、图片与媒体、数据与表单以及高级组件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="IOS" scheme="https://pgzxc.github.io/tags/IOS/"/>
    
    <category term="组件" scheme="https://pgzxc.github.io/tags/%E7%BB%84%E4%BB%B6/"/>
    
    <category term="对比" scheme="https://pgzxc.github.io/tags/%E5%AF%B9%E6%AF%94/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——IOS与安卓组件对比-2</title>
    <link href="https://pgzxc.github.io/posts/f16e2ef7.html"/>
    <id>https://pgzxc.github.io/posts/f16e2ef7.html</id>
    <published>2026-02-17T00:28:12.000Z</published>
    <updated>2026-02-22T02:43:05.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文介绍：</span><br><span class="line"> - iOS(UIKit/SwiftUI)和Android(View系统/Jetpack Compose)原生组件进行分类归纳和总体总结</span><br><span class="line"> - 分类覆盖导航、输入、选择、显示、反馈、动作及其他</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-对比"><a href="#二-对比" class="headerlink" title="二 对比"></a>二 对比</h2><h3 id="2-1-导航类组件"><a href="#2-1-导航类组件" class="headerlink" title="2.1 导航类组件"></a>2.1 导航类组件</h3><table><thead><tr><th align="center">子类</th><th align="center">iOS</th><th align="center">Android</th><th align="center">关键差异</th></tr></thead><tbody><tr><td align="center">返回&#x2F;后退</td><td align="center">Back Button + 左滑手势</td><td align="center">系统返回键 + App Bar Back</td><td align="center">iOS 更依赖手势</td></tr><tr><td align="center">底部标签</td><td align="center">Tab Bar &#x2F; TabView</td><td align="center">Bottom Navigation Bar</td><td align="center">iOS 支持 More 溢出</td></tr><tr><td align="center">顶部栏</td><td align="center">Navigation Bar</td><td align="center">App Bar &#x2F; Toolbar</td><td align="center">iOS 标题居中，Android 左对齐</td></tr><tr><td align="center">侧边菜单</td><td align="center">无原生(常用 Sheet)</td><td align="center">Navigation Drawer</td><td align="center">Android 标准侧滑</td></tr></tbody></table><h3 id="2-2-输入与选择类组件"><a href="#2-2-输入与选择类组件" class="headerlink" title="2.2 输入与选择类组件"></a>2.2 输入与选择类组件</h3><table><thead><tr><th align="center">子类</th><th align="center">iOS</th><th align="center">Android</th><th align="center">关键差异</th></tr></thead><tbody><tr><td align="center">按钮</td><td align="center">UIButton &#x2F; Button</td><td align="center">Button &#x2F; ElevatedButton &#x2F; OutlinedButton</td><td align="center">Android 样式更多样(阴影、轮廓)</td></tr><tr><td align="center">开关&#x2F;滑块</td><td align="center">UISwitch &#x2F; UISlider</td><td align="center">Switch &#x2F; Slider</td><td align="center">外观类似，Android 更可自定义</td></tr><tr><td align="center">文本输入</td><td align="center">UITextField &#x2F; TextField</td><td align="center">TextField &#x2F; OutlinedTextField</td><td align="center">Android 支持浮动标签</td></tr><tr><td align="center">单&#x2F;多选</td><td align="center">SegmentedControl 或 TableView Checkmark</td><td align="center">RadioButton &#x2F; CheckBox</td><td align="center">Android 有专用控件</td></tr><tr><td align="center">下拉&#x2F;日期</td><td align="center">UIPickerView &#x2F; UIDatePicker</td><td align="center">Spinner &#x2F; DatePicker</td><td align="center">iOS 滚轮式，Android 对话框式</td></tr><tr><td align="center">分段选择</td><td align="center">UISegmentedControl</td><td align="center">SegmentedButton (Material 3)</td><td align="center">Material 3 更接近 iOS</td></tr></tbody></table><h3 id="2-3-显示类组件"><a href="#2-3-显示类组件" class="headerlink" title="2.3 显示类组件"></a>2.3 显示类组件</h3><table><thead><tr><th align="center">子类</th><th align="center">iOS</th><th align="center">Android</th><th align="center">关键差异</th></tr></thead><tbody><tr><td align="center">列表&#x2F;网格</td><td align="center">UITableView &#x2F; UICollectionView &#x2F; List</td><td align="center">RecyclerView &#x2F; LazyColumn &#x2F; Grid</td><td align="center">Android 回收更高效</td></tr><tr><td align="center">卡片&#x2F;标签</td><td align="center">无专用(自定义)</td><td align="center">Card &#x2F; Chip</td><td align="center">Android 材质感强</td></tr><tr><td align="center">进度&#x2F;刷新</td><td align="center">UIProgressView &#x2F; UIRefreshControl</td><td align="center">ProgressBar &#x2F; SwipeRefreshLayout</td><td align="center">Android 支持上拉加载</td></tr><tr><td align="center">页面滑动 (PageView)</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">水平滑动</td><td align="center">UIPageViewController &#x2F; TabView(.page) &#x2F; ScrollView + paging (iOS 17+)</td><td align="center">ViewPager2 &#x2F; HorizontalPager</td><td align="center">Android 更现代、懒加载强</td></tr><tr><td align="center">竖直滑动</td><td align="center">UIPageViewController (.vertical) &#x2F; ScrollView + pagingBehavior</td><td align="center">ViewPager2 (VERTICAL) &#x2F; VerticalPager</td><td align="center">Android 原生支持更好(TikTok 式 feed)</td></tr><tr><td align="center">页面指示器</td><td align="center">UIPageControl</td><td align="center">自定义或 TabLayout dots</td><td align="center">iOS 原生点状</td></tr></tbody></table><h3 id="2-4-反馈与动作类组件"><a href="#2-4-反馈与动作类组件" class="headerlink" title="2.4 反馈与动作类组件"></a>2.4 反馈与动作类组件</h3><table><thead><tr><th align="center">子类</th><th align="center">iOS</th><th align="center">Android</th><th align="center">关键差异</th></tr></thead><tbody><tr><td align="center">对话框&#x2F;提示</td><td align="center">UIAlertController &#x2F; ActionSheet</td><td align="center">AlertDialog &#x2F; Snackbar &#x2F; Toast</td><td align="center">iOS 从底部弹出动作表，Android Snackbar 带动作</td></tr><tr><td align="center">加载指示</td><td align="center">UIActivityIndicatorView</td><td align="center">ProgressIndicator</td><td align="center">Android 支持线性&#x2F;圆形多种</td></tr><tr><td align="center">主要动作</td><td align="center">导航栏按钮</td><td align="center">Floating Action Button (FAB)</td><td align="center">Android FAB 浮动突出</td></tr><tr><td align="center">底部模态</td><td align="center">ActionSheet &#x2F; BottomSheet (iOS 13+)</td><td align="center">BottomSheetDialog</td><td align="center">功能类似</td></tr></tbody></table><h3 id="2-5-其他类组件"><a href="#2-5-其他类组件" class="headerlink" title="2.5 其他类组件"></a>2.5 其他类组件</h3><table><thead><tr><th align="center">子类</th><th align="center">iOS</th><th align="center">Android</th><th align="center">关键差异</th></tr></thead><tbody><tr><td align="center">搜索栏</td><td align="center">UISearchBar</td><td align="center">SearchBar</td><td align="center">Android 支持折叠 App Bar</td></tr><tr><td align="center">分隔&#x2F;徽章</td><td align="center">Separator &#x2F; Badge</td><td align="center">Divider &#x2F; Badge</td><td align="center">类似</td></tr></tbody></table><h3 id="2-6-PageView"><a href="#2-6-PageView" class="headerlink" title="2.6 PageView"></a>2.6 PageView</h3><table><thead><tr><th align="center">平台</th><th align="center">组件</th><th align="center">本质</th></tr></thead><tbody><tr><td align="center">iOS</td><td align="center"><strong>UIPageViewController</strong> &#x2F; UICollectionView</td><td align="center">Layer 合成 + 手势驱动</td></tr><tr><td align="center">Android</td><td align="center">ViewPager2</td><td align="center">RecyclerView + LayoutManager</td></tr><tr><td align="center">SwiftUI</td><td align="center">TabView(.page)</td><td align="center">UIPageViewController 封装</td></tr><tr><td align="center">Compose</td><td align="center">Pager</td><td align="center">LazyLayout + Compose 渲染</td></tr></tbody></table><p>2-说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iOS：分页是“系统级组件”</span><br><span class="line">Android：分页是“列表的特殊形态”</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - iOS(UIKit/SwiftUI)和Android(View系统/Jetpack Compose)原生组件进行分类归纳和总体总结&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 分类覆盖导航、输入、选择、显示、反馈、动作及其他&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="IOS" scheme="https://pgzxc.github.io/tags/IOS/"/>
    
    <category term="组件对比" scheme="https://pgzxc.github.io/tags/%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——IOS与安卓组件对比-1</title>
    <link href="https://pgzxc.github.io/posts/68677f4d.html"/>
    <id>https://pgzxc.github.io/posts/68677f4d.html</id>
    <published>2026-02-16T00:56:34.000Z</published>
    <updated>2026-02-22T02:43:05.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面给出 iOS 与 Android 组件(UI/框架层)对比的尽可能全面整理。</span><br><span class="line">此对比覆盖：原生平台常用组件、容器、布局、交互控件、系统服务相关 UI 等，</span><br><span class="line">并注明对应 API/类名(部分已包含 UIKit/SwiftUI &amp; Android Views/Jetpack Compose)。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-对比"><a href="#二-对比" class="headerlink" title="二 对比"></a>二 对比</h2><h3 id="2-1-视图基础类-View-基础"><a href="#2-1-视图基础类-View-基础" class="headerlink" title="2.1 视图基础类&#x2F;View 基础"></a>2.1 视图基础类&#x2F;View 基础</h3><table><thead><tr><th align="center">功能类别</th><th align="center">iOS (UIKit&#x2F;SwiftUI)</th><th align="center">Android (View&#x2F;Compose)</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">基类</td><td align="center"><strong>UIView</strong> &#x2F; <strong>View</strong> (SwiftUI 的 View 协议)</td><td align="center"><strong>View</strong> (android.view.View) &#x2F; <br><strong>Modifier</strong> (Compose)</td><td align="center">核心 UI 元素</td></tr><tr><td align="center">容器</td><td align="center">UIView(可添加子视图)</td><td align="center">ViewGroup &#x2F; Compose 布局</td><td align="center">布局容器</td></tr><tr><td align="center">视图层次</td><td align="center">subviews</td><td align="center">child Views &#x2F; Compose slots</td><td align="center">子元素关系</td></tr></tbody></table><h3 id="2-2-布局-Layout"><a href="#2-2-布局-Layout" class="headerlink" title="2.2 布局(Layout)"></a>2.2 布局(Layout)</h3><table><thead><tr><th align="center">布局类型</th><th align="center">iOS UIKit</th><th align="center">iOS SwiftUI</th><th align="center">Android View</th><th align="center">Android Compose</th><th>说明</th></tr></thead><tbody><tr><td align="center">线性</td><td align="center">UIStackView</td><td align="center">HStack&#x2F;VStack</td><td align="center">LinearLayout</td><td align="center">Row&#x2F;Column</td><td>水平&#x2F;垂直排列</td></tr><tr><td align="center">相对约束</td><td align="center">Auto Layout + NSLayoutConstraint</td><td align="center">Layout 优先级、Alignment</td><td align="center">RelativeLayout</td><td align="center">ConstraintLayout (Compose)</td><td>相对&#x2F;约束布局</td></tr><tr><td align="center">容器布局</td><td align="center">UIScrollView</td><td align="center">ScrollView &#x2F; List</td><td align="center">FrameLayout &#x2F; ConstraintLayout</td><td align="center">Box &#x2F; ConstraintLayout</td><td>基础容器</td></tr><tr><td align="center">表单布局</td><td align="center">UITableView</td><td align="center">List</td><td align="center">ListView &#x2F; RecyclerView</td><td align="center">LazyColumn</td><td>列表&#x2F;表格(懒加载)</td></tr><tr><td align="center">网格</td><td align="center">UICollectionViewFlowLayout</td><td align="center">LazyVGrid</td><td align="center">GridLayout</td><td align="center">LazyVerticalGrid</td><td>类似网格布局</td></tr><tr><td align="center">自定义布局</td><td align="center">自定义 layoutSubviews</td><td align="center">Layout</td><td align="center">onLayout&#x2F;onMeasure</td><td align="center">Modifier.layout</td><td>灵活布局</td></tr></tbody></table><h3 id="2-3-文本与输入"><a href="#2-3-文本与输入" class="headerlink" title="2.3 文本与输入"></a>2.3 文本与输入</h3><table><thead><tr><th align="center">功能</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">文本</td><td align="center"><strong>UILabel</strong> &#x2F; Text</td><td align="center">TextView</td><td align="center">Text</td></tr><tr><td align="center">可编辑文本</td><td align="center">UITextField &#x2F; UITextView</td><td align="center">EditText</td><td align="center">TextField &#x2F; BasicTextField</td></tr><tr><td align="center">富文本</td><td align="center">NSAttributedString &#x2F; TextKit</td><td align="center">SpannableString</td><td align="center">AnnotatedString</td></tr><tr><td align="center">密码框</td><td align="center">UITextField with secure</td><td align="center">EditText inputType&#x3D;password</td><td align="center">TextField (visualTransformation)</td></tr></tbody></table><h3 id="2-4-按钮与交互控件"><a href="#2-4-按钮与交互控件" class="headerlink" title="2.4 按钮与交互控件"></a>2.4 按钮与交互控件</h3><table><thead><tr><th align="center">控件</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">普通按钮</td><td align="center">UIButton</td><td align="center">Button</td><td align="center">Button &#x2F; TextButton &#x2F; IconButton</td></tr><tr><td align="center">图标按钮</td><td align="center">UIButton (image)</td><td align="center">ImageButton</td><td align="center">IconButton</td></tr><tr><td align="center">切换开关</td><td align="center">UISwitch</td><td align="center">Switch</td><td align="center">Switch</td></tr><tr><td align="center">单选按钮</td><td align="center">UISegmentedControl</td><td align="center">RadioButton &#x2F; RadioGroup</td><td align="center">RadioButton + Row</td></tr><tr><td align="center">复选框</td><td align="center">—</td><td align="center">CheckBox</td><td align="center">Checkbox</td></tr><tr><td align="center">滑块</td><td align="center">UISlider</td><td align="center">SeekBar</td><td align="center">Slider</td></tr><tr><td align="center">步进器</td><td align="center">UIStepper</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">活动指示</td><td align="center">UIActivityIndicatorView</td><td align="center">ProgressBar &#x2F; Spinner</td><td align="center">CircularProgressIndicator &#x2F; LinearProgressIndicator</td></tr></tbody></table><h3 id="2-5-图像-媒体"><a href="#2-5-图像-媒体" class="headerlink" title="2.5 图像 &amp; 媒体"></a>2.5 图像 &amp; 媒体</h3><table><thead><tr><th align="center">功能</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">显示图片</td><td align="center">UIImageView</td><td align="center">ImageView</td><td align="center">Image</td></tr><tr><td align="center">相机&#x2F;图库</td><td align="center">UIImagePickerController &#x2F; PHPicker</td><td align="center">CameraX &#x2F; Intent</td><td align="center">CameraX + Compose UI</td></tr><tr><td align="center">视频播放</td><td align="center">AVPlayer &#x2F; AVPlayerLayer</td><td align="center">ExoPlayer &#x2F; VideoView</td><td align="center">ExoPlayer + Compose</td></tr><tr><td align="center">动画</td><td align="center">UIView.animate + Core Animation</td><td align="center">Animation API</td><td align="center">animate*AsState、Transition</td></tr></tbody></table><h3 id="2-6-列表-表格-网格"><a href="#2-6-列表-表格-网格" class="headerlink" title="2.6 列表 &#x2F; 表格 &#x2F; 网格"></a>2.6 列表 &#x2F; 表格 &#x2F; 网格</h3><table><thead><tr><th align="center">列表类型</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">普通列表</td><td align="center">UITableView</td><td align="center">RecyclerView</td><td align="center">LazyColumn</td></tr><tr><td align="center">多列网格</td><td align="center">UICollectionView</td><td align="center">RecyclerView (GridLayout)</td><td align="center">LazyVerticalGrid</td></tr><tr><td align="center">选择 &amp; 编辑</td><td align="center">UITableView editing</td><td align="center">Contextual ActionMode</td><td align="center">SwipeToDismiss &#x2F; Selection APIs</td></tr></tbody></table><h3 id="2-7-弹窗-模态-导航"><a href="#2-7-弹窗-模态-导航" class="headerlink" title="2.7 弹窗 &#x2F; 模态 &#x2F; 导航"></a>2.7 弹窗 &#x2F; 模态 &#x2F; 导航</h3><table><thead><tr><th align="center">类型</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">Toast</td><td align="center">—(可用 third-party)</td><td align="center">Toast</td><td align="center">Snackbar</td></tr><tr><td align="center">Alert 弹窗</td><td align="center">UIAlertController</td><td align="center">AlertDialog</td><td align="center">AlertDialog</td></tr><tr><td align="center">Action Sheet</td><td align="center">UIAlertController (action sheet style)</td><td align="center">BottomSheetDialog</td><td align="center">ModalBottomSheet</td></tr><tr><td align="center">模态页</td><td align="center">presentViewController</td><td align="center">startActivity &#x2F; Fragment</td><td align="center">Navigation composable</td></tr><tr><td align="center">导航栏</td><td align="center">UINavigationController</td><td align="center">Toolbar + NavController</td><td align="center">NavHost + NavController</td></tr><tr><td align="center">标签页</td><td align="center">UITabBarController</td><td align="center">BottomNavigationView</td><td align="center">BottomNavigation</td></tr><tr><td align="center">分页控制</td><td align="center">UIPageControl</td><td align="center">ViewPager2</td><td align="center">Pager (Accompanist)</td></tr></tbody></table><h3 id="2-8-手势-触控"><a href="#2-8-手势-触控" class="headerlink" title="2.8 手势 &amp; 触控"></a>2.8 手势 &amp; 触控</h3><table><thead><tr><th align="center">功能</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">基本手势</td><td align="center">UITapGestureRecognizer 等</td><td align="center">GestureDetector</td><td align="center">Modifier.pointerInput</td></tr><tr><td align="center">多点手势</td><td align="center">UIPinch &#x2F; UIRotation</td><td align="center">ScaleGestureDetector</td><td align="center">Modifier.pointerInput</td></tr><tr><td align="center">拖拽</td><td align="center">UIView drag APIs</td><td align="center">View.DragListener</td><td align="center">Modifier.dragGesture</td></tr></tbody></table><h3 id="2-9-画布-绘图"><a href="#2-9-画布-绘图" class="headerlink" title="2.9 画布 &amp; 绘图"></a>2.9 画布 &amp; 绘图</h3><table><thead><tr><th align="center">功能</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">自定义绘制</td><td align="center">draw(_:) &#x2F; Core Graphics</td><td align="center">Canvas + Paint</td><td align="center">Canvas</td></tr><tr><td align="center">矢量图</td><td align="center">PDF&#x2F;VectorAsset</td><td align="center">VectorDrawable</td><td align="center">ImageVector</td></tr><tr><td align="center">硬件加速</td><td align="center">Core Animation</td><td align="center">GPU 渲染</td><td align="center">Compose 渲染管线</td></tr></tbody></table><h3 id="2-10-系统功能-UI"><a href="#2-10-系统功能-UI" class="headerlink" title="2.10 系统功能 &amp; UI"></a>2.10 系统功能 &amp; UI</h3><table><thead><tr><th align="center">功能</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">键盘事件</td><td align="center">UIResponder keyboard notifications</td><td align="center">InputMethodManager</td><td align="center">LocalSoftwareKeyboardController</td></tr><tr><td align="center">通知中心 UI</td><td align="center">UNNotificationContentExtension</td><td align="center">Notification Channels</td><td align="center">Snackbar&#x2F;Notification APIs</td></tr><tr><td align="center">权限 UI</td><td align="center">系统弹窗</td><td align="center">系统权限请求</td><td align="center">Permissions API</td></tr><tr><td align="center">锁屏&#x2F;Widget</td><td align="center">Lock Screen UIkit</td><td align="center">Widgets &#x2F; LockScreen</td><td align="center">Not applicable</td></tr></tbody></table><h3 id="2-11-数据-Bind-State"><a href="#2-11-数据-Bind-State" class="headerlink" title="2.11 数据 &amp; Bind&#x2F;State"></a>2.11 数据 &amp; Bind&#x2F;State</h3><table><thead><tr><th align="center">功能</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">数据绑定</td><td align="center">KVO &#x2F; Combine</td><td align="center">DataBinding &#x2F; LiveData</td><td align="center">State &#x2F; MutableState</td></tr><tr><td align="center">响应式</td><td align="center">Combine &#x2F; SwiftUI State</td><td align="center">LiveData &#x2F; Flow</td><td align="center">State &#x2F; SnapshotFlow</td></tr><tr><td align="center">MVVM 支持</td><td align="center">和 Combine&#x2F;SwiftUI 配合</td><td align="center">强 MVVM 支持</td><td align="center">基于 State&#x2F;Flow 自然响应</td></tr></tbody></table><h3 id="2-12-生命周期-架构"><a href="#2-12-生命周期-架构" class="headerlink" title="2.12 生命周期 &amp; 架构"></a>2.12 生命周期 &amp; 架构</h3><table><thead><tr><th align="center">层级</th><th align="center">iOS</th><th align="center">Android</th><th align="center">Compose</th></tr></thead><tbody><tr><td align="center">视图生命周期</td><td align="center">viewDidLoad&#x2F;WillAppear 等</td><td align="center">onCreate&#x2F;onStart&#x2F;onResume…</td><td align="center">Compose 生命周期 API</td></tr><tr><td align="center">页面生命周期</td><td align="center">UIViewController 生命周期</td><td align="center">Activity&#x2F;Fragment 生命周期</td><td align="center">Navigation + LifecycleOwner</td></tr><tr><td align="center">组件生命周期</td><td align="center">SwiftUI View 本质是 value type</td><td align="center">ViewModel + LifecycleOwner</td><td align="center">ViewModel + LifecycleOwner</td></tr></tbody></table><h3 id="2-13-界面声明方式对比"><a href="#2-13-界面声明方式对比" class="headerlink" title="2.13 界面声明方式对比"></a>2.13 界面声明方式对比</h3><table><thead><tr><th align="center">方式</th><th align="center">iOS</th><th align="center">Android</th></tr></thead><tbody><tr><td align="center">传统 XML&#x2F;Storyboard</td><td align="center">Storyboard &#x2F; XIB</td><td align="center">XML Layout</td></tr><tr><td align="center">代码创建</td><td align="center">Pure UIKit</td><td align="center">Pure View API</td></tr><tr><td align="center">声明式 UI</td><td align="center">SwiftUI</td><td align="center">Jetpack Compose</td></tr><tr><td align="center">混合开发</td><td align="center">UIKit + SwiftUI</td><td align="center">XML + Compose</td></tr></tbody></table><h3 id="2-14-开发体验对比点-声明式-vs-命令式"><a href="#2-14-开发体验对比点-声明式-vs-命令式" class="headerlink" title="2.14 开发体验对比点(声明式 vs. 命令式)"></a>2.14 开发体验对比点(声明式 vs. 命令式)</h3><table><thead><tr><th align="center">特点</th><th align="center">SwiftUI</th><th align="center">Jetpack Compose</th></tr></thead><tbody><tr><td align="center">数据驱动 UI</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">状态自动更新 UI</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">Preview</td><td align="center">Xcode Previews</td><td align="center">Android Studio Previews</td></tr><tr><td align="center">动画简化</td><td align="center">内建动画 API</td><td align="center">内建 Animation APIs</td></tr></tbody></table><h3 id="2-15-生态及扩展"><a href="#2-15-生态及扩展" class="headerlink" title="2.15 生态及扩展"></a>2.15 生态及扩展</h3><table><thead><tr><th align="center">项</th><th align="center">iOS</th><th align="center">Android</th></tr></thead><tbody><tr><td align="center">社区扩展库</td><td align="center">CocoaPods &#x2F; SwiftPM</td><td align="center">Gradle &#x2F; Maven</td></tr><tr><td align="center">设计规范</td><td align="center">Human Interface Guidelines</td><td align="center">Material Design</td></tr><tr><td align="center">主题支持</td><td align="center">UIAppearance &#x2F; SwiftUI Themes</td><td align="center">Styles&#x2F;Themes</td></tr></tbody></table><h3 id="2-16-核心对比总结-一眼看懂"><a href="#2-16-核心对比总结-一眼看懂" class="headerlink" title="2.16 核心对比总结(一眼看懂)"></a>2.16 核心对比总结(一眼看懂)</h3><table><thead><tr><th align="center">维度</th><th align="center">iOS (UIKit&#x2F;SwiftUI)</th><th align="center">Android (View&#x2F;Compose)</th></tr></thead><tbody><tr><td align="center">UI 基础</td><td align="center">UIView &#x2F; SwiftUI Views</td><td align="center">View &#x2F; Compose UI</td></tr><tr><td align="center">列表控件</td><td align="center">UITableView &#x2F; UICollectionView</td><td align="center">RecyclerView</td></tr><tr><td align="center">声明式</td><td align="center">SwiftUI</td><td align="center">Jetpack Compose</td></tr><tr><td align="center">传统布局</td><td align="center">Auto Layout</td><td align="center">XML + Constraint</td></tr><tr><td align="center">输入 &amp; 控件</td><td align="center">UITextField&#x2F;UIButton</td><td align="center">EditText&#x2F;Button</td></tr><tr><td align="center">弹窗</td><td align="center">UIAlertController</td><td align="center">AlertDialog&#x2F;Toast</td></tr><tr><td align="center">设计规范</td><td align="center">Human Interface</td><td align="center">Material Design</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下面给出 iOS 与 Android 组件(UI/框架层)对比的尽可能全面整理。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此对比覆盖：原生平台常用组件、容器、布局、交互控件、系统服务相关 UI 等，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并注明对应 API/类名(部分已包含 UIKit/SwiftUI &amp;amp; Android Views/Jetpack Compose)。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="IOS" scheme="https://pgzxc.github.io/tags/IOS/"/>
    
    <category term="组件对比" scheme="https://pgzxc.github.io/tags/%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——常用网络请求框架和数据解析</title>
    <link href="https://pgzxc.github.io/posts/7487767b.html"/>
    <id>https://pgzxc.github.io/posts/7487767b.html</id>
    <published>2026-02-15T04:16:28.000Z</published>
    <updated>2026-02-22T02:43:05.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">随着 Swift、SwiftUI 和并发模型的发展，</span><br><span class="line">iOS 网络开发也逐步从传统回调，过渡到 async / await + Codable 的现代模式。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-IOS-常用网络请求库"><a href="#二-IOS-常用网络请求库" class="headerlink" title="二 IOS 常用网络请求库"></a>二 IOS 常用网络请求库</h2><h3 id="2-1-URLSession-系统原生，基础能力"><a href="#2-1-URLSession-系统原生，基础能力" class="headerlink" title="2.1 URLSession(系统原生，基础能力)"></a>2.1 URLSession(系统原生，基础能力)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1-定位：系统级网络 API</span><br><span class="line">2-提供方：Apple</span><br><span class="line"></span><br><span class="line">3-核心能力：</span><br><span class="line">-HTTP / HTTPS 请求</span><br><span class="line">-后台下载、断点续传</span><br><span class="line">-Cookie / Cache 管理</span><br><span class="line">-支持 async / await（iOS 15+）</span><br><span class="line"></span><br><span class="line">4-优点：</span><br><span class="line">-无第三方依赖</span><br><span class="line">-稳定、可控</span><br><span class="line">-官方长期维护</span><br><span class="line"></span><br><span class="line">5-不足：</span><br><span class="line">-封装偏底层</span><br><span class="line">-代码模板较多</span><br><span class="line"></span><br><span class="line">6-说明：</span><br><span class="line">所有第三方网络库的底层实现基础</span><br></pre></td></tr></table></figure><h3 id="2-2-Alamofire-最主流第三方网络库"><a href="#2-2-Alamofire-最主流第三方网络库" class="headerlink" title="2.2 Alamofire(最主流第三方网络库)"></a>2.2 Alamofire(最主流第三方网络库)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1-定位：URLSession 的高级封装</span><br><span class="line">2-地位：iOS 事实标准第三方网络库</span><br><span class="line"></span><br><span class="line">3-核心特点：</span><br><span class="line">-链式调用</span><br><span class="line">-参数编码自动化</span><br><span class="line">-请求/响应拦截</span><br><span class="line">-网络状态监听</span><br><span class="line">-支持 async/await、Combine</span><br><span class="line"></span><br><span class="line">4-典型使用场景：</span><br><span class="line">-中大型 iOS 项目</span><br><span class="line">-快速搭建网络层</span><br><span class="line"></span><br><span class="line">5-说明：</span><br><span class="line">iOS 中最常用的网络库</span><br></pre></td></tr></table></figure><h3 id="2-3-Moya-接口层抽象"><a href="#2-3-Moya-接口层抽象" class="headerlink" title="2.3  Moya(接口层抽象)"></a>2.3  Moya(接口层抽象)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1-定位：基于 Alamofire 的网络抽象层</span><br><span class="line"></span><br><span class="line">2-核心特点：</span><br><span class="line">-枚举方式定义 API</span><br><span class="line">-强约束接口规范</span><br><span class="line">-便于 Mock / 单元测试</span><br><span class="line">-与 RxSwift / Combine 结合良好</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">适合团队协作和大型项目</span><br></pre></td></tr></table></figure><h3 id="2-4-AFNetworking-历史项目"><a href="#2-4-AFNetworking-历史项目" class="headerlink" title="2.4 AFNetworking(历史项目)"></a>2.4 AFNetworking(历史项目)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-语言：Objective-C</span><br><span class="line"></span><br><span class="line">2-现状：</span><br><span class="line">-曾经的主流</span><br><span class="line">-Swift 项目中已基本被淘汰</span><br><span class="line">-老项目仍可见</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">只需了解，不建议新项目使用</span><br></pre></td></tr></table></figure><h3 id="2-5-WebSocket-网络库"><a href="#2-5-WebSocket-网络库" class="headerlink" title="2.5 WebSocket 网络库"></a>2.5 WebSocket 网络库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1-常见方案：</span><br><span class="line">-URLSessionWebSocketTask（iOS 13+）</span><br><span class="line">-Starscream(第三方)</span><br><span class="line"></span><br><span class="line">2-使用场景：</span><br><span class="line">-即时聊天</span><br><span class="line">-实时推送</span><br><span class="line">-实时行情</span><br></pre></td></tr></table></figure><h2 id="三-IOS-常用数据解析方式"><a href="#三-IOS-常用数据解析方式" class="headerlink" title="三 IOS 常用数据解析方式"></a>三 IOS 常用数据解析方式</h2><h3 id="3-1-JSON-绝对主流"><a href="#3-1-JSON-绝对主流" class="headerlink" title="3.1 JSON(绝对主流)"></a>3.1 JSON(绝对主流)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iOS 与后端交互的数据格式，绝大多数为 JSON。</span><br></pre></td></tr></table></figure><h3 id="3-2-Codable-官方首选"><a href="#3-2-Codable-官方首选" class="headerlink" title="3.2 Codable(官方首选)"></a>3.2 Codable(官方首选)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1-说明：</span><br><span class="line">Swift 官方数据解析方案</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-编译期类型检查</span><br><span class="line">-与 Swift 语法深度结合</span><br><span class="line">-支持 JSONEncoder / JSONDecoder</span><br><span class="line"></span><br><span class="line">3-优点：</span><br><span class="line">-类型安全</span><br><span class="line">-性能好</span><br><span class="line">-代码简洁</span><br><span class="line"></span><br><span class="line">现代 iOS 项目首选</span><br></pre></td></tr></table></figure><h3 id="3-3-SwiftyJSON-逐渐边缘"><a href="#3-3-SwiftyJSON-逐渐边缘" class="headerlink" title="3.3 SwiftyJSON(逐渐边缘)"></a>3.3 SwiftyJSON(逐渐边缘)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-特点：</span><br><span class="line">-动态解析 JSON</span><br><span class="line">-语法简单</span><br><span class="line"></span><br><span class="line">2-缺点：</span><br><span class="line">-类型安全差</span><br><span class="line">-容易隐藏错误</span><br><span class="line"></span><br><span class="line">新项目不推荐</span><br></pre></td></tr></table></figure><h3 id="3-4-ObjectMapper-HandyJSON-第三方"><a href="#3-4-ObjectMapper-HandyJSON-第三方" class="headerlink" title="3.4 ObjectMapper&#x2F;HandyJSON(第三方)"></a>3.4 ObjectMapper&#x2F;HandyJSON(第三方)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-特点：</span><br><span class="line">-映射灵活</span><br><span class="line">-对后端字段变化容错好</span><br><span class="line"></span><br><span class="line">2-不足：</span><br><span class="line">-依赖反射</span><br><span class="line">-与 Swift 新特性兼容性一般</span><br><span class="line"></span><br><span class="line">老项目仍可见</span><br></pre></td></tr></table></figure><h3 id="3-5-XML-解析-较少"><a href="#3-5-XML-解析-较少" class="headerlink" title="3.5 XML 解析(较少)"></a>3.5 XML 解析(较少)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1-使用场景：</span><br><span class="line">-老接口</span><br><span class="line">-SOAP / RSS</span><br><span class="line"></span><br><span class="line">2-解析方式：</span><br><span class="line">-XMLParser（系统）</span><br></pre></td></tr></table></figure><h2 id="四-网络库-解析库的常见组合"><a href="#四-网络库-解析库的常见组合" class="headerlink" title="四 网络库 + 解析库的常见组合"></a>四 网络库 + 解析库的常见组合</h2><h3 id="4-1-原生-Swift-SwiftUI-项目"><a href="#4-1-原生-Swift-SwiftUI-项目" class="headerlink" title="4.1 原生 Swift&#x2F;SwiftUI 项目"></a>4.1 原生 Swift&#x2F;SwiftUI 项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLSession + Codable（官方推荐）</span><br></pre></td></tr></table></figure><h3 id="4-2-传统大型项目"><a href="#4-2-传统大型项目" class="headerlink" title="4.2 传统大型项目"></a>4.2 传统大型项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alamofire + Codable</span><br><span class="line">Moya + Codable</span><br></pre></td></tr></table></figure><h3 id="4-3-Rx-Combine-项目"><a href="#4-3-Rx-Combine-项目" class="headerlink" title="4.3 Rx&#x2F;Combine 项目"></a>4.3 Rx&#x2F;Combine 项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Moya + RxSwift</span><br><span class="line">Alamofire + Combine</span><br></pre></td></tr></table></figure><h3 id="4-4-WebSocket-实时通信"><a href="#4-4-WebSocket-实时通信" class="headerlink" title="4.4 WebSocket 实时通信"></a>4.4 WebSocket 实时通信</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URLSessionWebSocketTask</span><br><span class="line">Starscream</span><br></pre></td></tr></table></figure><h2 id="五-选型建议"><a href="#五-选型建议" class="headerlink" title="五 选型建议"></a>五 选型建议</h2><table><thead><tr><th align="center">场景</th><th align="center">推荐方案</th></tr></thead><tbody><tr><td align="center">原生项目</td><td align="center">URLSession + Codable</td></tr><tr><td align="center">中大型项目</td><td align="center">Alamofire + Codable</td></tr><tr><td align="center">团队协作</td><td align="center">Moya + Alamofire + Codable</td></tr><tr><td align="center">SwiftUI &#x2F; 新项目</td><td align="center">async&#x2F;await + URLSession</td></tr><tr><td align="center">实时通信</td><td align="center">WebSocket</td></tr></tbody></table><h2 id="六-IOS-面试高频关注点"><a href="#六-IOS-面试高频关注点" class="headerlink" title="六 IOS 面试高频关注点"></a>六 IOS 面试高频关注点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.URLSession 和 Alamofire 区别</span><br><span class="line">2.Codable 与第三方解析库对比</span><br><span class="line">3.async/await 网络实现</span><br><span class="line">4.网络层如何解耦</span><br><span class="line">5.请求拦截与统一错误处理</span><br><span class="line">6.Token 过期处理方案</span><br><span class="line">7.WebSocket 使用场景</span><br></pre></td></tr></table></figure><h2 id="七-总结一句话"><a href="#七-总结一句话" class="headerlink" title="七 总结一句话"></a>七 总结一句话</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLSession 是地基，Alamofire 提效率，Moya 管规范，Codable 管数据安全。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;随着 Swift、SwiftUI 和并发模型的发展，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iOS 网络开发也逐步从传统回调，过渡到 async / await + Codable 的现代模式。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="网络请求" scheme="https://pgzxc.github.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
    <category term="数据解析" scheme="https://pgzxc.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
    <category term="IOS" scheme="https://pgzxc.github.io/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之——常见状态管理</title>
    <link href="https://pgzxc.github.io/posts/f031f469.html"/>
    <id>https://pgzxc.github.io/posts/f031f469.html</id>
    <published>2026-02-14T13:07:23.000Z</published>
    <updated>2026-02-22T02:43:05.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现代 iOS 状态管理已经高度收敛到 SwiftUI 体系</span><br><span class="line">核心组合：State/ObservableObject/Combine（或 async/await）</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-IOS-状态管理整体演进"><a href="#二-IOS-状态管理整体演进" class="headerlink" title="二 IOS 状态管理整体演进"></a>二 IOS 状态管理整体演进</h2><h3 id="2-1-早期-UIKit-时代"><a href="#2-1-早期-UIKit-时代" class="headerlink" title="2.1 早期 UIKit 时代"></a>2.1 早期 UIKit 时代</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-状态变量</span><br><span class="line">-属性变量</span><br><span class="line">-Delegate/Notification</span><br><span class="line">-KVO</span><br><span class="line"></span><br><span class="line">2-问题</span><br><span class="line">-状态分散</span><br><span class="line">-生命周期难管</span><br><span class="line">-调试困难</span><br></pre></td></tr></table></figure><h3 id="2-2-SwiftUI-时代-主流"><a href="#2-2-SwiftUI-时代-主流" class="headerlink" title="2.2 SwiftUI 时代(主流)"></a>2.2 SwiftUI 时代(主流)</h3><p>1-@State(视图私有状态)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@State private var count = 0</span><br><span class="line"></span><br><span class="line">2-特点</span><br><span class="line">-仅当前 View</span><br><span class="line">-自动触发刷新</span><br><span class="line"></span><br><span class="line">3-类似： RN useState / Flutter setState</span><br></pre></td></tr></table></figure><p>2-@Binding(父子同步)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@Binding var count: Int</span><br><span class="line"></span><br><span class="line">2-说明</span><br><span class="line">用于组件间状态传递</span><br></pre></td></tr></table></figure><p>3-@StateObject &#x2F; @ObservedObject</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">class CounterViewModel: ObservableObject &#123;</span><br><span class="line">    @Published var count = 0</span><br><span class="line">&#125;</span><br><span class="line">@StateObject var vm = CounterViewModel()</span><br><span class="line"></span><br><span class="line">2-特点</span><br><span class="line">-ViewModel 生命周期稳定</span><br><span class="line">-跨视图共享状态</span><br><span class="line"></span><br><span class="line">3-场景：iOS 最常用方案之一</span><br></pre></td></tr></table></figure><p>4-@EnvironmentObject(全局状态)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@EnvironmentObject var appState: AppState</span><br><span class="line"></span><br><span class="line">2-类似</span><br><span class="line">-RN Context</span><br><span class="line">-Flutter Provider</span><br><span class="line"></span><br><span class="line">3-注意：</span><br><span class="line">滥用会导致隐式依赖</span><br></pre></td></tr></table></figure><h3 id="2-3-Combine-响应式状态"><a href="#2-3-Combine-响应式状态" class="headerlink" title="2.3 Combine(响应式状态)"></a>2.3 Combine(响应式状态)</h3><p>1-Combine + @Published</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@Published var user: User?</span><br><span class="line">$vm.user.sink &#123; user in &#125;</span><br><span class="line"></span><br><span class="line">2-优点</span><br><span class="line">-响应式</span><br><span class="line">-可组合</span><br><span class="line"></span><br><span class="line">3-缺点</span><br><span class="line">-学习成本略高</span><br><span class="line"></span><br><span class="line">SwiftUI 内部已深度使用</span><br></pre></td></tr></table></figure><h3 id="2-4-async-await-现代异步状态"><a href="#2-4-async-await-现代异步状态" class="headerlink" title="2.4  async&#x2F;await(现代异步状态)"></a>2.4  async&#x2F;await(现代异步状态)</h3><p>1-async&#x2F;await + ViewModel(推荐)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@MainActor</span><br><span class="line">class UserViewModel: ObservableObject &#123;</span><br><span class="line">    @Published var user: User?</span><br><span class="line"></span><br><span class="line">    func load() async &#123;</span><br><span class="line">        user = try? await api.fetchUser()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-说明</span><br><span class="line">已经取代大量 Combine 网络场景</span><br></pre></td></tr></table></figure><h3 id="2-5-Redux-单向数据流-进阶"><a href="#2-5-Redux-单向数据流-进阶" class="headerlink" title="2.5 Redux&#x2F;单向数据流(进阶)"></a>2.5 Redux&#x2F;单向数据流(进阶)</h3><p>1-The Composable Architecture(TCA)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1-iOS 最像 Redux 的方案</span><br><span class="line"></span><br><span class="line">2-代码</span><br><span class="line">struct State &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Action &#123;</span><br><span class="line">    case increment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let reducer = Reduce&lt;State, Action&gt; &#123; state, action in</span><br><span class="line">    switch action &#123;</span><br><span class="line">    case .increment:</span><br><span class="line">        state.count += 1</span><br><span class="line">        return .none</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3-优点</span><br><span class="line">-单向数据流</span><br><span class="line">-可测试性极强</span><br><span class="line"></span><br><span class="line">4-缺点</span><br><span class="line">-学习成本高</span><br><span class="line">-样板代码多</span><br><span class="line"></span><br><span class="line">5-场景：复杂业务/大型项目常用</span><br></pre></td></tr></table></figure><p>2-ReSwift(Redux 风格)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redux 直译版</span><br><span class="line">现在较少使用</span><br></pre></td></tr></table></figure><h3 id="2-6-UIKit-项目常见方案-仍在维护"><a href="#2-6-UIKit-项目常见方案-仍在维护" class="headerlink" title="2.6 UIKit 项目常见方案(仍在维护)"></a>2.6 UIKit 项目常见方案(仍在维护)</h3><p>1-MVC &#x2F; MVVM + KVO &#x2F; Combine</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ViewController 持有 ViewModel</span><br><span class="line">使用 Combine / Delegate 更新 UI</span><br><span class="line"></span><br><span class="line">新 UIKit 项目建议直接引入 Combine</span><br></pre></td></tr></table></figure><h2 id="三-IOS-状态管理方案对比"><a href="#三-IOS-状态管理方案对比" class="headerlink" title="三 IOS 状态管理方案对比"></a>三 IOS 状态管理方案对比</h2><table><thead><tr><th align="center">方案</th><th align="center">场景</th><th align="center">推荐指数</th></tr></thead><tbody><tr><td align="center">@State</td><td align="center">View 内</td><td align="center">5颗星</td></tr><tr><td align="center">ObservableObject</td><td align="center">页面 &#x2F; 模块</td><td align="center">5颗星</td></tr><tr><td align="center">EnvironmentObject</td><td align="center">全局状态</td><td align="center">3颗星</td></tr><tr><td align="center">Combine</td><td align="center">响应式</td><td align="center">4颗星</td></tr><tr><td align="center">async&#x2F;await</td><td align="center">异步</td><td align="center">5颗星</td></tr><tr><td align="center">TCA</td><td align="center">大型项目</td><td align="center">4颗星</td></tr></tbody></table><h2 id="四-和-RN-Flutter-Android-KMP-对照"><a href="#四-和-RN-Flutter-Android-KMP-对照" class="headerlink" title="四 和 RN &#x2F; Flutter &#x2F; Android &#x2F; KMP 对照"></a>四 和 RN &#x2F; Flutter &#x2F; Android &#x2F; KMP 对照</h2><table><thead><tr><th align="center">思想</th><th align="center">RN</th><th align="center">Flutter</th><th align="center">Android</th><th align="center">iOS</th></tr></thead><tbody><tr><td align="center">局部状态</td><td align="center">useState</td><td align="center">setState</td><td align="center">remember</td><td align="center">@State</td></tr><tr><td align="center">全局状态</td><td align="center">Zustand</td><td align="center">Riverpod</td><td align="center">StateFlow</td><td align="center">ObservableObject</td></tr><tr><td align="center">Redux</td><td align="center">RTK</td><td align="center">Bloc</td><td align="center">MVI</td><td align="center">TCA</td></tr><tr><td align="center">异步数据</td><td align="center">React Query</td><td align="center">AsyncProvider</td><td align="center">Flow</td><td align="center">async&#x2F;await</td></tr></tbody></table><h2 id="五-实战选型建议-重点"><a href="#五-实战选型建议-重点" class="headerlink" title="五 实战选型建议(重点)"></a>五 实战选型建议(重点)</h2><h3 id="5-1-新-SwiftUI-项目-推荐"><a href="#5-1-新-SwiftUI-项目-推荐" class="headerlink" title="5.1 新 SwiftUI 项目(推荐)"></a>5.1 新 SwiftUI 项目(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@State</span><br><span class="line"> + ObservableObject</span><br><span class="line"> + async/await</span><br></pre></td></tr></table></figure><h3 id="5-2-中大型项目"><a href="#5-2-中大型项目" class="headerlink" title="5.2 中大型项目"></a>5.2 中大型项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObservableObject</span><br><span class="line"> + Combine / async</span><br><span class="line"> +（必要时）TCA</span><br></pre></td></tr></table></figure><h3 id="5-3-不推荐"><a href="#5-3-不推荐" class="headerlink" title="5.3 不推荐"></a>5.3 不推荐</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Notification 当状态管理</span><br><span class="line">KVO 新项目</span><br><span class="line">纯单例全局变量</span><br></pre></td></tr></table></figure><h2 id="六-一句话总结"><a href="#六-一句话总结" class="headerlink" title="六 一句话总结"></a>六 一句话总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iOS 状态管理已高度统一到 SwiftUI + ViewModel</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;现代 iOS 状态管理已经高度收敛到 SwiftUI 体系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;核心组合：State/ObservableObject/Combine（或 async/await）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="IOS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/IOS/"/>
    
    
    <category term="状态管理" scheme="https://pgzxc.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
    <category term="IOS" scheme="https://pgzxc.github.io/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之——常用网络请求框架和数据解析</title>
    <link href="https://pgzxc.github.io/posts/f0a6ffda.html"/>
    <id>https://pgzxc.github.io/posts/f0a6ffda.html</id>
    <published>2026-02-13T00:15:31.000Z</published>
    <updated>2026-02-22T02:43:05.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 Android 应用开发中，网络层通常由 网络请求库 + 数据解析库 两部分组成。</span><br><span class="line">合理的选择和组合，直接影响项目的可维护性、性能和扩展性。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-Android-常用网络请求库"><a href="#二-Android-常用网络请求库" class="headerlink" title="二 Android 常用网络请求库"></a>二 Android 常用网络请求库</h2><h3 id="2-1-OkHttp-网络层事实标准"><a href="#2-1-OkHttp-网络层事实标准" class="headerlink" title="2.1 OkHttp(网络层事实标准)"></a>2.1 OkHttp(网络层事实标准)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1-定位：底层 HTTP 通信库</span><br><span class="line">2-作者：Square</span><br><span class="line"></span><br><span class="line">3-核心能力：</span><br><span class="line">-支持HTTP/HTTPS</span><br><span class="line">-同步/异步请求</span><br><span class="line">-连接池、缓存机制</span><br><span class="line">-拦截器体系(非常关键)</span><br><span class="line">-WebSocket 支持</span><br><span class="line"></span><br><span class="line">4-典型使用场景：</span><br><span class="line">-所有网络请求的底层</span><br><span class="line">-Retrofit 的核心依赖</span><br><span class="line">-文件上 /下载</span><br><span class="line">-WebSocket 实时通信</span><br><span class="line"></span><br><span class="line">5-结论：</span><br><span class="line">OkHttp 是 Android 网络开发的“地基”，几乎不可替代。</span><br></pre></td></tr></table></figure><h3 id="2-2-Retrofit-最主流的上层网络框架"><a href="#2-2-Retrofit-最主流的上层网络框架" class="headerlink" title="2.2 Retrofit(最主流的上层网络框架)"></a>2.2 Retrofit(最主流的上层网络框架)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1-定位：RESTful API 封装框架</span><br><span class="line">2-底层：OkHttp</span><br><span class="line"></span><br><span class="line">3-核心特点：</span><br><span class="line">-接口 + 注解定义请求</span><br><span class="line">-自动拼接 URL 和参数</span><br><span class="line">-支持多种 Converter(Gson/Moshi/Kotlinx)</span><br><span class="line">-与 RxJava、Coroutine 深度集成</span><br><span class="line"></span><br><span class="line">4-优势：</span><br><span class="line">-代码简洁、结构清晰</span><br><span class="line">-接口定义标准化</span><br><span class="line">-易维护、易测试</span><br><span class="line"></span><br><span class="line">5-说明：</span><br><span class="line">当前 Android 项目首选方案</span><br></pre></td></tr></table></figure><h3 id="2-3-Volley-逐渐淘汰"><a href="#2-3-Volley-逐渐淘汰" class="headerlink" title="2.3  Volley(逐渐淘汰)"></a>2.3  Volley(逐渐淘汰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1-定位：请求队列框架（Google）</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-请求调度简单</span><br><span class="line">-适合轻量请求</span><br><span class="line"></span><br><span class="line">3-不足：</span><br><span class="line">-扩展性差</span><br><span class="line">-大文件支持不佳</span><br><span class="line">-不适合复杂项目</span><br><span class="line"></span><br><span class="line">4-结论：新项目基本不再推荐。</span><br></pre></td></tr></table></figure><h3 id="2-4-Ktor-Client-Kotlin-KMP常用"><a href="#2-4-Ktor-Client-Kotlin-KMP常用" class="headerlink" title="2.4 Ktor Client(Kotlin&#x2F;KMP常用)"></a>2.4 Ktor Client(Kotlin&#x2F;KMP常用)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1-定位：Kotlin 原生网络客户端</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-协程原生支持</span><br><span class="line">-插件化设计</span><br><span class="line">-跨平台(Android/iOS/Desktop/Web)</span><br><span class="line"></span><br><span class="line">3-适用场景：</span><br><span class="line">-Kotlin Multiplatform（KMP）</span><br><span class="line">-Compose Multiplatform 项目</span><br><span class="line"></span><br><span class="line">4-说明：</span><br><span class="line">KMP 项目首选网络库</span><br></pre></td></tr></table></figure><h3 id="2-5-WebSocket-库"><a href="#2-5-WebSocket-库" class="headerlink" title="2.5 WebSocket 库"></a>2.5 WebSocket 库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1-常见实现方式：</span><br><span class="line">-OkHttp WebSocket</span><br><span class="line">-STOMP/Socket.IO(基于业务需求)</span><br><span class="line"></span><br><span class="line">2-使用场景：</span><br><span class="line">-即时聊天</span><br><span class="line">-实时推送</span><br><span class="line">-弹幕/直播互动</span><br></pre></td></tr></table></figure><h2 id="三-Android-常用数据解析方式"><a href="#三-Android-常用数据解析方式" class="headerlink" title="三 Android 常用数据解析方式"></a>三 Android 常用数据解析方式</h2><h3 id="3-1-JSON-绝对主流格式"><a href="#3-1-JSON-绝对主流格式" class="headerlink" title="3.1 JSON(绝对主流格式)"></a>3.1 JSON(绝对主流格式)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前 Android 与后端交互中，90% 以上使用 JSON。</span><br></pre></td></tr></table></figure><h3 id="3-2-Gson-使用最广"><a href="#3-2-Gson-使用最广" class="headerlink" title="3.2 Gson(使用最广)"></a>3.2 Gson(使用最广)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1-作者：Google</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-上手简单</span><br><span class="line">-容错性强</span><br><span class="line">-Retrofit 默认支持</span><br><span class="line"></span><br><span class="line">3-优点：</span><br><span class="line">-对字段缺失 / 多余不敏感</span><br><span class="line">-学习成本低</span><br><span class="line"></span><br><span class="line">4-缺点：</span><br><span class="line">-反射多，性能一般</span><br><span class="line">-Kotlin 空安全支持一般</span><br><span class="line"></span><br><span class="line">5-说明：</span><br><span class="line">老项目/快速开发常用</span><br></pre></td></tr></table></figure><h3 id="3-3-Moshi-现代-Android-首选"><a href="#3-3-Moshi-现代-Android-首选" class="headerlink" title="3.3 Moshi(现代 Android 首选)"></a>3.3 Moshi(现代 Android 首选)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1-作者：Square</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-Kotlin 友好</span><br><span class="line">-支持 codegen（编译期生成）</span><br><span class="line">-Retrofit 官方推荐之一</span><br><span class="line"></span><br><span class="line">3-优点：</span><br><span class="line">-性能优于 Gson</span><br><span class="line">-对 Kotlin data class 支持好</span><br><span class="line">-空安全更合理</span><br><span class="line"></span><br><span class="line">4-说明：</span><br><span class="line">新项目强烈推荐</span><br></pre></td></tr></table></figure><h3 id="3-4-kotlinx-serialization-Kotlin-官方"><a href="#3-4-kotlinx-serialization-Kotlin-官方" class="headerlink" title="3.4 kotlinx.serialization(Kotlin 官方)"></a>3.4 kotlinx.serialization(Kotlin 官方)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1-定位：Kotlin 原生序列化方案</span><br><span class="line"></span><br><span class="line">2-特点：</span><br><span class="line">-编译期生成代码(无反射)</span><br><span class="line">-跨平台支持</span><br><span class="line">-类型安全</span><br><span class="line"></span><br><span class="line">3-优点：</span><br><span class="line">-性能好</span><br><span class="line">-KMP 项目首选</span><br><span class="line"></span><br><span class="line">4-缺点：</span><br><span class="line">-对后端字段变化较敏感</span><br><span class="line">-注解侵入性稍高</span><br></pre></td></tr></table></figure><h3 id="3-5-XML-解析-较少"><a href="#3-5-XML-解析-较少" class="headerlink" title="3.5 XML 解析(较少)"></a>3.5 XML 解析(较少)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1-使用场景：</span><br><span class="line">-老系统接口</span><br><span class="line">-RSS / SOAP</span><br><span class="line"></span><br><span class="line">2-常见方式：</span><br><span class="line">-PullParser</span><br><span class="line">-SAX</span><br><span class="line">-DOM</span><br><span class="line"></span><br><span class="line">3-说明：</span><br><span class="line">现代 Android 项目较少使用</span><br></pre></td></tr></table></figure><h2 id="四-网络库-解析库的常见组合"><a href="#四-网络库-解析库的常见组合" class="headerlink" title="四 网络库 + 解析库的常见组合"></a>四 网络库 + 解析库的常见组合</h2><h3 id="4-1-传统-Android-项目"><a href="#4-1-传统-Android-项目" class="headerlink" title="4.1 传统 Android 项目"></a>4.1 传统 Android 项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Retrofit + OkHttp + Gson</span><br><span class="line">Retrofit + OkHttp + Moshi（推荐）</span><br></pre></td></tr></table></figure><h3 id="4-2-Kotlin-协程项目"><a href="#4-2-Kotlin-协程项目" class="headerlink" title="4.2 Kotlin &#x2F; 协程项目"></a>4.2 Kotlin &#x2F; 协程项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Retrofit + OkHttp + Moshi</span><br><span class="line">Retrofit + OkHttp + kotlinx.serialization</span><br></pre></td></tr></table></figure><h3 id="4-3-KMP-项目"><a href="#4-3-KMP-项目" class="headerlink" title="4.3 KMP 项目"></a>4.3 KMP 项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ktor Client + kotlinx.serialization</span><br></pre></td></tr></table></figure><h2 id="五-选型建议"><a href="#五-选型建议" class="headerlink" title="五 选型建议"></a>五 选型建议</h2><table><thead><tr><th align="center">场景</th><th align="center">推荐方案</th></tr></thead><tbody><tr><td align="center">传统项目</td><td align="center">Retrofit + OkHttp + Gson</td></tr><tr><td align="center">新项目</td><td align="center">Retrofit + OkHttp + Moshi</td></tr><tr><td align="center">Kotlin &#x2F; 协程</td><td align="center">Retrofit + OkHttp + Moshi</td></tr><tr><td align="center">跨平台 KMP</td><td align="center">Ktor + kotlinx.serialization</td></tr><tr><td align="center">实时通信</td><td align="center">OkHttp WebSocket</td></tr></tbody></table><h2 id="六-面试高频问题总结"><a href="#六-面试高频问题总结" class="headerlink" title="六 面试高频问题总结"></a>六 面试高频问题总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.OkHttp 和 Retrofit 的关系</span><br><span class="line">2.Gson 和 Moshi 的区别</span><br><span class="line">3.JSON 解析性能对比</span><br><span class="line">4.协程网络请求如何实现</span><br><span class="line">5.网络层如何封装</span><br><span class="line">6.Token 失效如何处理</span><br><span class="line">7.网络异常统一处理方案</span><br></pre></td></tr></table></figure><h2 id="七-总结一句话"><a href="#七-总结一句话" class="headerlink" title="七 总结一句话"></a>七 总结一句话</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttp 负责网络通信，Retrofit 负责接口规范，解析库负责数据映射，Repository 负责业务解耦。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在 Android 应用开发中，网络层通常由 网络请求库 + 数据解析库 两部分组成。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;合理的选择和组合，直接影响项目的可维护性、性能和扩展性。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="Android" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/Android/"/>
    
    
    <category term="Android" scheme="https://pgzxc.github.io/tags/Android/"/>
    
    <category term="网络请求" scheme="https://pgzxc.github.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
    <category term="数据解析" scheme="https://pgzxc.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之——常用状态管理</title>
    <link href="https://pgzxc.github.io/posts/af42baba.html"/>
    <id>https://pgzxc.github.io/posts/af42baba.html</id>
    <published>2026-02-12T04:33:05.000Z</published>
    <updated>2026-02-22T02:43:05.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文介绍Android状态管理：</span><br><span class="line">-Android 主流状态管理 = ViewModel + StateFlow（或 LiveData）</span><br><span class="line">-如果用Jetpack Compose：StateFlow + collectAsState()</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-状态管理"><a href="#二-状态管理" class="headerlink" title="二 状态管理"></a>二 状态管理</h2><h3 id="2-1-早期-Activity-Fragment-时代"><a href="#2-1-早期-Activity-Fragment-时代" class="headerlink" title="2.1 早期(Activity &#x2F; Fragment 时代)"></a>2.1 早期(Activity &#x2F; Fragment 时代)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-状态管理</span><br><span class="line">-成员变量</span><br><span class="line">-onSaveInstanceState</span><br><span class="line">-Bundle</span><br><span class="line"></span><br><span class="line">2-问题</span><br><span class="line">-易丢失状态</span><br><span class="line">-生命周期复杂</span><br><span class="line">-配置变更难处理</span><br></pre></td></tr></table></figure><h3 id="2-2-Jetpack-官方体系-主流"><a href="#2-2-Jetpack-官方体系-主流" class="headerlink" title="2.2 Jetpack 官方体系(主流)"></a>2.2 Jetpack 官方体系(主流)</h3><p>1-ViewModel(核心)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2-代码</span><br><span class="line">class CounterViewModel : ViewModel() &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-作用</span><br><span class="line">-生命周期感知</span><br><span class="line">-配置变更不丢状态</span><br><span class="line"></span><br><span class="line">几乎所有现代 Android 项目都会用</span><br></pre></td></tr></table></figure><p>2-LiveData(传统主流)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">val count = MutableLiveData(0)</span><br><span class="line">count.observe(this) &#123; value -&gt;</span><br><span class="line">    textView.text = value.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-优点</span><br><span class="line">-简单</span><br><span class="line">-生命周期安全</span><br><span class="line"></span><br><span class="line">3-缺点</span><br><span class="line">-表达能力有限</span><br><span class="line">-协程支持一般</span><br><span class="line"></span><br><span class="line">维护旧项目仍常见</span><br></pre></td></tr></table></figure><p>3-StateFlow(当前推荐)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line"></span><br><span class="line">private val _state = MutableStateFlow(State())</span><br><span class="line">val state: StateFlow&lt;State&gt; = _state</span><br><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    viewModel.state.collect &#123; state -&gt;</span><br><span class="line">        // update UI</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或（Compose）：</span><br><span class="line">val state by viewModel.state.collectAsState()</span><br><span class="line"></span><br><span class="line">2-优点</span><br><span class="line">-官方协程体系</span><br><span class="line">-可组合、可测试</span><br><span class="line">-多端一致（KMP）</span><br><span class="line"></span><br><span class="line">3-场景：新项目首选</span><br></pre></td></tr></table></figure><h3 id="2-3-Jetpack-Compose-时代"><a href="#2-3-Jetpack-Compose-时代" class="headerlink" title="2.3 Jetpack Compose 时代"></a>2.3 Jetpack Compose 时代</h3><p>1- Compose State(UI 层)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">var text by remember &#123; mutableStateOf(&quot;&quot;) &#125;</span><br><span class="line"></span><br><span class="line">2-特点</span><br><span class="line">-仅限 UI 状态</span><br><span class="line">-不适合业务状态</span><br></pre></td></tr></table></figure><p>2- ViewModel + StateFlow + Compose(黄金组合)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">@Composable</span><br><span class="line">fun CounterScreen(vm: CounterViewModel) &#123;</span><br><span class="line">    val state by vm.state.collectAsState()</span><br><span class="line">    Text(&quot;$&#123;state.count&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-说明</span><br><span class="line">UI = State 的纯函数</span><br></pre></td></tr></table></figure><h3 id="2-4-Redux-MVI-思想在-Android"><a href="#2-4-Redux-MVI-思想在-Android" class="headerlink" title="2.4 Redux &#x2F; MVI 思想在 Android"></a>2.4 Redux &#x2F; MVI 思想在 Android</h3><p>1-MVI(Intent → State)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1-代码</span><br><span class="line">sealed interface Intent &#123;</span><br><span class="line">    object Load : Intent</span><br><span class="line">&#125;</span><br><span class="line">fun reduce(state: State, intent: Intent): State</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2-特点</span><br><span class="line">-单向数据流</span><br><span class="line">-可回溯</span><br><span class="line">-非常适合复杂页面</span><br></pre></td></tr></table></figure><p>2- Android 常用 MVI 框架</p><table><thead><tr><th align="center">框架</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Orbit MVI</td><td align="center">官方协程友好</td></tr><tr><td align="center">Mavericks</td><td align="center">Airbnb 出品</td></tr><tr><td align="center">ReduxKotlin</td><td align="center">Redux 直译</td></tr></tbody></table><h3 id="2-5-第三方轻量方案-了解"><a href="#2-5-第三方轻量方案-了解" class="headerlink" title="2.5 第三方轻量方案(了解)"></a>2.5 第三方轻量方案(了解)</h3><p>1- RxJava(老项目)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BehaviorSubject</span><br><span class="line">PublishSubject</span><br><span class="line"></span><br><span class="line">新项目不推荐</span><br></pre></td></tr></table></figure><p>2-EventBus &#x2F; LiveEvent</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决事件</span><br><span class="line">不适合作为状态管理</span><br></pre></td></tr></table></figure><h2 id="三-Android-状态管理方案对比"><a href="#三-Android-状态管理方案对比" class="headerlink" title="三 Android 状态管理方案对比"></a>三 Android 状态管理方案对比</h2><table><thead><tr><th align="center">方案</th><th align="center">生命周期安全</th><th align="center">Compose 友好</th><th align="center">推荐指数</th></tr></thead><tbody><tr><td align="center">成员变量</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">1颗星</td></tr><tr><td align="center">LiveData</td><td align="center">支持</td><td align="center">一般</td><td align="center">3颗星</td></tr><tr><td align="center">StateFlow</td><td align="center">支持</td><td align="center">支持</td><td align="center">5颗星</td></tr><tr><td align="center">MVI</td><td align="center">支持</td><td align="center">支持</td><td align="center">4颗星</td></tr><tr><td align="center">EventBus</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">1颗星</td></tr></tbody></table><h2 id="四-和-RN-Flutter-KMP-的对照"><a href="#四-和-RN-Flutter-KMP-的对照" class="headerlink" title="四 和 RN &#x2F; Flutter &#x2F; KMP 的对照"></a>四 和 RN &#x2F; Flutter &#x2F; KMP 的对照</h2><table><thead><tr><th align="center">平台</th><th align="center">主流状态管理</th></tr></thead><tbody><tr><td align="center">RN</td><td align="center">Zustand &#x2F; RTK</td></tr><tr><td align="center">Flutter</td><td align="center">Riverpod &#x2F; Bloc</td></tr><tr><td align="center">KMP</td><td align="center">StateFlow + VM</td></tr><tr><td align="center">Android</td><td align="center">StateFlow + VM</td></tr></tbody></table><h2 id="五-实战选型建议"><a href="#五-实战选型建议" class="headerlink" title="五 实战选型建议"></a>五 实战选型建议</h2><h3 id="5-1-新项目-强烈推荐"><a href="#5-1-新项目-强烈推荐" class="headerlink" title="5.1 新项目(强烈推荐)"></a>5.1 新项目(强烈推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ViewModel</span><br><span class="line"> + StateFlow</span><br><span class="line"> + Repository</span><br><span class="line"> + Compose</span><br></pre></td></tr></table></figure><h3 id="5-2-中大型项目"><a href="#5-2-中大型项目" class="headerlink" title="5.2 中大型项目"></a>5.2 中大型项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewModel</span><br><span class="line"> + StateFlow</span><br><span class="line"> + MVI（Orbit / 自实现）</span><br></pre></td></tr></table></figure><h3 id="5-3-不推荐"><a href="#5-3-不推荐" class="headerlink" title="5.3 不推荐"></a>5.3 不推荐</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Activity 持有业务状态</span><br><span class="line">EventBus 当状态管理</span><br><span class="line">RxJava 新项目</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍Android状态管理：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Android 主流状态管理 = ViewModel + StateFlow（或 LiveData）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-如果用Jetpack Compose：StateFlow + collectAsState()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="D-移动开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="Android" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/D-%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/Android/"/>
    
    
    <category term="Android" scheme="https://pgzxc.github.io/tags/Android/"/>
    
    <category term="状态管理" scheme="https://pgzxc.github.io/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NAS入门之——MyCloudEx2通过网线与电脑连接访问(20)</title>
    <link href="https://pgzxc.github.io/posts/84874c6b.html"/>
    <id>https://pgzxc.github.io/posts/84874c6b.html</id>
    <published>2026-02-11T11:35:29.000Z</published>
    <updated>2026-02-22T02:43:05.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文介绍：在没有路由器情况下NAS通过网线与电脑直连</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-物理连接"><a href="#二-物理连接" class="headerlink" title="二 物理连接"></a>二 物理连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.用千兆网线一头插 My Cloud EX2 网口，另一头插 Mac 网口(无网口用 USB‑C 转 RJ45 网卡)</span><br><span class="line">2.给 NAS 通电，等蓝色常亮(约 3 分钟)</span><br></pre></td></tr></table></figure><h2 id="三-访问NAS-3种方法"><a href="#三-访问NAS-3种方法" class="headerlink" title="三 访问NAS(3种方法)"></a>三 访问NAS(3种方法)</h2><h3 id="3-1-方法-1：Finder-自动发现-推荐"><a href="#3-1-方法-1：Finder-自动发现-推荐" class="headerlink" title="3.1 方法 1：Finder 自动发现(推荐)"></a>3.1 方法 1：Finder 自动发现(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.打开 Finder → 左侧共享</span><br><span class="line">2.找到 MyCloudEX2Ultra（或 MyCloudEX2）→ 点击</span><br><span class="line">3.选注册用户，输入 NAS 管理员账号密码 → 连接</span><br></pre></td></tr></table></figure><h3 id="3-2-方法-2：手动连接-最稳"><a href="#3-2-方法-2：手动连接-最稳" class="headerlink" title="3.2 方法 2：手动连接(最稳)"></a>3.2 方法 2：手动连接(最稳)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.按 Command+K（或 Finder → 前往 → 连接服务器）</span><br><span class="line">2.输入：smb://MyCloudEX2Ultra.local</span><br><span class="line">3.连接 → 输入账号密码 → 选择共享文件夹</span><br></pre></td></tr></table></figure><h3 id="3-3-方法-3：网页管理后台"><a href="#3-3-方法-3：网页管理后台" class="headerlink" title="3.3 方法 3：网页管理后台"></a>3.3 方法 3：网页管理后台</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器打开: http://MyCloudEX2Ultra.local</span><br><span class="line">2.登录管理员账号，可管理文件、用户、设置</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍：在没有路由器情况下NAS通过网线与电脑直连&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="J-NAS" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/J-NAS/"/>
    
    <category term="My Cloud EX2" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/J-NAS/My-Cloud-EX2/"/>
    
    
    <category term="My Cloud EX2" scheme="https://pgzxc.github.io/tags/My-Cloud-EX2/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——实战案例(9)</title>
    <link href="https://pgzxc.github.io/posts/786c0ca3.html"/>
    <id>https://pgzxc.github.io/posts/786c0ca3.html</id>
    <published>2026-02-10T00:33:39.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.人像生成完整项目</span><br><span class="line"> 2.商品图生成流水线</span><br><span class="line"> 3.短视频自动生成系统</span><br><span class="line"> 4.AI 插画生产工作流</span><br><span class="line"> 5.AI 内容工厂(LLM + Image + Video)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-人像生成完整项目-商业级"><a href="#二-人像生成完整项目-商业级" class="headerlink" title="二 人像生成完整项目(商业级)"></a>二 人像生成完整项目(商业级)</h2><h3 id="2-1-项目目标"><a href="#2-1-项目目标" class="headerlink" title="2.1 项目目标"></a>2.1 项目目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.构建一个 高一致性、可控的人像生成系统，适用于：</span><br><span class="line">-AI 写真</span><br><span class="line">-虚拟形象</span><br><span class="line">-商业肖像</span><br><span class="line"></span><br><span class="line">2.核心要求：</span><br><span class="line">-人脸稳定</span><br><span class="line">-风格可控</span><br><span class="line">-可批量生成</span><br></pre></td></tr></table></figure><h3 id="2-2-核心技术组合"><a href="#2-2-核心技术组合" class="headerlink" title="2.2 核心技术组合"></a>2.2 核心技术组合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Checkpoint（写实 / 半写实）</span><br><span class="line">+ 人物 LoRA</span><br><span class="line">+ ControlNet（OpenPose / Depth）</span><br><span class="line">+ Inpainting</span><br><span class="line">+ Hires 修复</span><br></pre></td></tr></table></figure><h3 id="2-3-Workflow-结构拆解"><a href="#2-3-Workflow-结构拆解" class="headerlink" title="2.3 Workflow 结构拆解"></a>2.3 Workflow 结构拆解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"> ├─ Prompt / Negative</span><br><span class="line"> ├─ 姿态参考图</span><br><span class="line"> └─ 参数（CFG / Steps / Seed）</span><br><span class="line">      ↓</span><br><span class="line">LoRA 模块</span><br><span class="line">      ↓</span><br><span class="line">ControlNet（锁姿态）</span><br><span class="line">      ↓</span><br><span class="line">KSampler（文生图 / 图生图）</span><br><span class="line">      ↓</span><br><span class="line">Hires 修复</span><br><span class="line">      ↓</span><br><span class="line">Inpainting（修脸）</span><br><span class="line">      ↓</span><br><span class="line">Output</span><br></pre></td></tr></table></figure><h3 id="2-4-工程化要点"><a href="#2-4-工程化要点" class="headerlink" title="2.4 工程化要点"></a>2.4 工程化要点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">固定 Seed + 微调 Prompt</span><br><span class="line">LoRA 权重 &lt; 1</span><br><span class="line">修脸单独走 Inpainting 子流程</span><br><span class="line">输出自动命名（人物 / 场景 / 时间）</span><br><span class="line"></span><br><span class="line">这是目前最成熟、最赚钱的一类 ComfyUI 项目</span><br></pre></td></tr></table></figure><h2 id="三-商品图生成流水线-电商级"><a href="#三-商品图生成流水线-电商级" class="headerlink" title="三 商品图生成流水线(电商级)"></a>三 商品图生成流水线(电商级)</h2><h3 id="3-1-项目目标"><a href="#3-1-项目目标" class="headerlink" title="3.1 项目目标"></a>3.1 项目目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构建 标准化、批量化商品图生成系统：</span><br><span class="line">-白底 / 场景图</span><br><span class="line">-角度一致</span><br><span class="line">-可替换背景</span><br></pre></td></tr></table></figure><h3 id="3-2-技术选型"><a href="#3-2-技术选型" class="headerlink" title="3.2 技术选型"></a>3.2 技术选型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.图生图</span><br><span class="line">+ ControlNet Canny</span><br><span class="line">+ ControlNet Depth</span><br><span class="line">+ Upscale</span><br><span class="line"></span><br><span class="line">2.不追求“艺术”，只追求：</span><br><span class="line">-稳定</span><br><span class="line">-可控</span><br><span class="line">-一致</span><br></pre></td></tr></table></figure><h3 id="3-3-Workflow-流水线设计"><a href="#3-3-Workflow-流水线设计" class="headerlink" title="3.3 Workflow 流水线设计"></a>3.3 Workflow 流水线设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">商品原图</span><br><span class="line"> → Canny（锁轮廓）</span><br><span class="line"> → Depth（锁空间）</span><br><span class="line"> → 图生图（低 denoise）</span><br><span class="line"> → 背景生成</span><br><span class="line"> → Upscale</span><br><span class="line"> → 批量输出</span><br></pre></td></tr></table></figure><h3 id="3-4-自动化落地"><a href="#3-4-自动化落地" class="headerlink" title="3.4 自动化落地"></a>3.4 自动化落地</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CSV / JSON 输入商品参数</span><br><span class="line">API 批量调用</span><br><span class="line">输出直传 OSS / CDN</span><br><span class="line"></span><br><span class="line">非常适合做成 SaaS 或内部工具</span><br></pre></td></tr></table></figure><h2 id="四-短视频自动生成系统-内容级"><a href="#四-短视频自动生成系统-内容级" class="headerlink" title="四 短视频自动生成系统(内容级)"></a>四 短视频自动生成系统(内容级)</h2><h3 id="4-1-项目目标"><a href="#4-1-项目目标" class="headerlink" title="4.1 项目目标"></a>4.1 项目目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构建一个 “无人值守”的短视频生成系统：</span><br><span class="line">-图 → 视频</span><br><span class="line">-自动配音</span><br><span class="line">-自动剪辑</span><br></pre></td></tr></table></figure><h3 id="4-2-技术组合"><a href="#4-2-技术组合" class="headerlink" title="4.2 技术组合"></a>4.2 技术组合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image → Video</span><br><span class="line">+ AnimateDiff / Video Diffusion</span><br><span class="line">+ LLM 文案生成</span><br><span class="line">+ TTS 音频</span><br></pre></td></tr></table></figure><h3 id="4-3-系统级-Workflow"><a href="#4-3-系统级-Workflow" class="headerlink" title="4.3 系统级 Workflow"></a>4.3 系统级 Workflow</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主题输入</span><br><span class="line"> → LLM 拆分分镜</span><br><span class="line"> → 图像生成</span><br><span class="line"> → Image → Video</span><br><span class="line"> → 音频生成</span><br><span class="line"> → 合成输出</span><br></pre></td></tr></table></figure><h3 id="4-4-稳定性关键点"><a href="#4-4-稳定性关键点" class="headerlink" title="4.4 稳定性关键点"></a>4.4 稳定性关键点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首帧质量 &gt; 一切</span><br><span class="line">低 Motion / 低 Denoise</span><br><span class="line">固定模型 / Prompt 模板化</span><br><span class="line"></span><br><span class="line">适合短视频矩阵、AIGC 工作室</span><br></pre></td></tr></table></figure><h2 id="五-AI-插画生产工作流-创作级"><a href="#五-AI-插画生产工作流-创作级" class="headerlink" title="五 AI 插画生产工作流(创作级)"></a>五 AI 插画生产工作流(创作级)</h2><h3 id="5-1-项目目标"><a href="#5-1-项目目标" class="headerlink" title="5.1 项目目标"></a>5.1 项目目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构建 可持续产出插画的生产流：</span><br><span class="line">-统一画风</span><br><span class="line">-高出图率</span><br><span class="line">-可迭代创作</span><br></pre></td></tr></table></figure><h3 id="5-2-技术选型"><a href="#5-2-技术选型" class="headerlink" title="5.2 技术选型"></a>5.2 技术选型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">插画 Checkpoint</span><br><span class="line">+ 风格 LoRA</span><br><span class="line">+ ControlNet Lineart</span><br><span class="line">+ Hires + ESRGAN</span><br></pre></td></tr></table></figure><h3 id="5-3-创作型-Workflow-特点"><a href="#5-3-创作型-Workflow-特点" class="headerlink" title="5.3 创作型 Workflow 特点"></a>5.3 创作型 Workflow 特点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prompt 模板</span><br><span class="line"> + 随机种子</span><br><span class="line"> + 可调风格强度</span><br><span class="line"> </span><br><span class="line">2.与商业图不同：</span><br><span class="line">-允许随机性</span><br><span class="line">-强调“变化中的统一” </span><br></pre></td></tr></table></figure><h3 id="5-4-创作者效率提升点"><a href="#5-4-创作者效率提升点" class="headerlink" title="5.4 创作者效率提升点"></a>5.4 创作者效率提升点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Prompt 模板库</span><br><span class="line">风格 LoRA 版本化</span><br><span class="line">批量生成 + 人工精选</span><br><span class="line"></span><br><span class="line">非常适合插画师 / IP 创作者</span><br></pre></td></tr></table></figure><h2 id="六-AI-内容工厂-终极形态"><a href="#六-AI-内容工厂-终极形态" class="headerlink" title="六 AI 内容工厂(终极形态)"></a>六 AI 内容工厂(终极形态)</h2><h3 id="6-1-项目目标"><a href="#6-1-项目目标" class="headerlink" title="6.1 项目目标"></a>6.1 项目目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构建一个 AI 全自动内容生产系统：</span><br><span class="line">-有“大脑”</span><br><span class="line">-有“流水线”</span><br><span class="line">-有“输出渠道”</span><br></pre></td></tr></table></figure><h3 id="6-2-系统整体架构"><a href="#6-2-系统整体架构" class="headerlink" title="6.2 系统整体架构"></a>6.2 系统整体架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户需求</span><br><span class="line"> → LLM（Agent）</span><br><span class="line"> → 决策 Workflow</span><br><span class="line"> → Image / Video</span><br><span class="line"> → Audio</span><br><span class="line"> → 文案</span><br><span class="line"> → 发布</span><br></pre></td></tr></table></figure><h3 id="6-3-Agent-在其中的角色"><a href="#6-3-Agent-在其中的角色" class="headerlink" title="6.3 Agent 在其中的角色"></a>6.3 Agent 在其中的角色</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.LLM 不直接“画图”，而是：</span><br><span class="line">-分析需求</span><br><span class="line">-选择模型</span><br><span class="line">-决定参数</span><br><span class="line">-控制执行顺序</span><br><span class="line"></span><br><span class="line">2.ComfyUI = 执行引擎</span><br><span class="line">LLM = 调度大脑</span><br></pre></td></tr></table></figure><h3 id="6-4-真实落地场景"><a href="#6-4-真实落地场景" class="headerlink" title="6.4 真实落地场景"></a>6.4 真实落地场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自媒体矩阵</span><br><span class="line">电商内容</span><br><span class="line">品牌视觉生成</span><br><span class="line">内部创意工具</span><br></pre></td></tr></table></figure><h2 id="七-小结"><a href="#七-小结" class="headerlink" title="七 小结"></a>七 小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.ComfyUI 不是玩具：ComfyUI = 用“节点”写 AI 系统</span><br><span class="line"></span><br><span class="line">2.它可以是：</span><br><span class="line">-人像系统</span><br><span class="line">-商品流水线</span><br><span class="line">-视频工厂</span><br><span class="line">-内容平台</span><br><span class="line"></span><br><span class="line">3.真正的上限在于：工程 + 自动化 + Agent</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.人像生成完整项目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.商品图生成流水线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.短视频自动生成系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4.AI 插画生产工作流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 5.AI 内容工厂(LLM + Image + Video)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——性能与部署(8)</title>
    <link href="https://pgzxc.github.io/posts/e110a654.html"/>
    <id>https://pgzxc.github.io/posts/e110a654.html</id>
    <published>2026-02-09T00:55:05.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.显存与性能优化</span><br><span class="line"> 2.服务器部署</span><br><span class="line"> 3.稳定性与安全</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-显存与性能优化"><a href="#二-显存与性能优化" class="headerlink" title="二 显存与性能优化"></a>二 显存与性能优化</h2><h3 id="2-1-显存消耗从哪里来"><a href="#2-1-显存消耗从哪里来" class="headerlink" title="2.1 显存消耗从哪里来"></a>2.1 显存消耗从哪里来</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.在 ComfyUI 中，显存主要被以下部分占用：</span><br><span class="line">-Checkpoint（基础模型）</span><br><span class="line">-ControlNet / LoRA</span><br><span class="line">-Latent 分辨率</span><br><span class="line">-Steps × Batch</span><br><span class="line">-视频帧缓存</span><br><span class="line"></span><br><span class="line">2.核心公式（经验）：</span><br><span class="line">-显存 ≈ 分辨率 × 批量 × 模型复杂度 × 步数</span><br></pre></td></tr></table></figure><h3 id="2-2-低显存运行技巧"><a href="#2-2-低显存运行技巧" class="headerlink" title="2.2 低显存运行技巧"></a>2.2 低显存运行技巧</h3><p>1-降低 Latent 分辨率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不要一开始就 1024 / 2048：</span><br><span class="line">先 512 / 768 确认构图</span><br><span class="line">再 Hires / Upscale</span><br><span class="line"></span><br><span class="line">小图定结构，大图补细节</span><br></pre></td></tr></table></figure><p>2-合理使用 Batch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Batch &gt; 1 ≠ 一定更快</span><br><span class="line"></span><br><span class="line">在显存紧张时：</span><br><span class="line">-Batch = 1</span><br><span class="line">-多次排队执行</span><br></pre></td></tr></table></figure><p>3-精简 ControlNet &#x2F; LoRA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-ControlNet 是显存大户</span><br><span class="line">-多个 ControlNet 同时启用 ≈ 显存翻倍</span><br><span class="line"></span><br><span class="line">建议：</span><br><span class="line">-非必要不叠加</span><br><span class="line">-权重低于 1.0</span><br><span class="line">-用完即关</span><br></pre></td></tr></table></figure><h3 id="2-3-模型加载策略"><a href="#2-3-模型加载策略" class="headerlink" title="2.3 模型加载策略"></a>2.3 模型加载策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.问题：频繁 OOM / 卡顿</span><br><span class="line"></span><br><span class="line">原因通常是：</span><br><span class="line">-模型反复加载</span><br><span class="line">-同时驻留多个大模型</span><br><span class="line"></span><br><span class="line">2.策略一：固定主模型</span><br><span class="line">一个服务只跑一个 Checkpoint</span><br><span class="line">LoRA / ControlNet 动态切换</span><br><span class="line"></span><br><span class="line">适合：</span><br><span class="line">-API 服务</span><br><span class="line">-批量生成</span><br><span class="line"></span><br><span class="line">3.策略二：分实例运行</span><br><span class="line">ComfyUI 实例 A → 人像</span><br><span class="line">ComfyUI 实例 B → 产品</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">-显存隔离</span><br><span class="line">-稳定性高</span><br></pre></td></tr></table></figure><h3 id="2-4-批处理优化"><a href="#2-4-批处理优化" class="headerlink" title="2.4 批处理优化"></a>2.4 批处理优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.批处理两种方式</span><br><span class="line">-Batch Size</span><br><span class="line">-队列任务</span><br><span class="line"></span><br><span class="line">2.工程推荐：小 Batch + 多任务队列</span><br><span class="line"></span><br><span class="line">3.原因：</span><br><span class="line">-更稳定</span><br><span class="line">-易恢复</span><br><span class="line">-不容易 OOM</span><br></pre></td></tr></table></figure><h2 id="三-服务器部署"><a href="#三-服务器部署" class="headerlink" title="三 服务器部署"></a>三 服务器部署</h2><h3 id="3-1-部署形态对比"><a href="#3-1-部署形态对比" class="headerlink" title="3.1 部署形态对比"></a>3.1 部署形态对比</h3><table><thead><tr><th align="center">方式</th><th align="center">适合</th></tr></thead><tbody><tr><td align="center">本地</td><td align="center">个人使用 &#x2F; 调试</td></tr><tr><td align="center">局域网</td><td align="center">工作室 &#x2F; 团队</td></tr><tr><td align="center">云服务器</td><td align="center">对外服务 &#x2F; API</td></tr></tbody></table><h3 id="3-2-本地-局域网部署"><a href="#3-2-本地-局域网部署" class="headerlink" title="3.2 本地 &#x2F; 局域网部署"></a>3.2 本地 &#x2F; 局域网部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、启动方式</span><br><span class="line">python main.py --listen 0.0.0.0 --port 8188</span><br><span class="line"></span><br><span class="line">2.即可：</span><br><span class="line">-局域网访问</span><br><span class="line">-多设备共享</span><br><span class="line"></span><br><span class="line">3.注意：</span><br><span class="line">-局域网≠安全</span><br><span class="line">-需配合防火墙</span><br></pre></td></tr></table></figure><h3 id="3-3-Docker-部署-推荐"><a href="#3-3-Docker-部署-推荐" class="headerlink" title="3.3 Docker 部署(推荐)"></a>3.3 Docker 部署(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.Docker 的价值：</span><br><span class="line">-环境隔离</span><br><span class="line">-易部署</span><br><span class="line">-易迁移</span><br><span class="line"></span><br><span class="line">2.基本思路：</span><br><span class="line"></span><br><span class="line">Docker</span><br><span class="line"> ├─ ComfyUI</span><br><span class="line"> ├─ models 挂载</span><br><span class="line"> └─ output 挂载</span><br><span class="line"></span><br><span class="line">3.优势：</span><br><span class="line">-模型不进镜像</span><br><span class="line">-数据可持久化</span><br><span class="line">-一次部署，多处运行</span><br></pre></td></tr></table></figure><h3 id="3-4-多用户访问架构"><a href="#3-4-多用户访问架构" class="headerlink" title="3.4 多用户访问架构"></a>3.4 多用户访问架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.原生 ComfyUI 不是多租户系统</span><br><span class="line"></span><br><span class="line">2.常见解决方案：</span><br><span class="line">-前置 API 服务</span><br><span class="line">-任务队列</span><br><span class="line">-用户隔离输出目录</span><br><span class="line"></span><br><span class="line">3.典型结构：</span><br><span class="line"></span><br><span class="line">用户</span><br><span class="line"> → 后端服务</span><br><span class="line"> → 队列</span><br><span class="line"> → ComfyUI Worker</span><br></pre></td></tr></table></figure><h2 id="四-稳定性与安全-长期运行必看"><a href="#四-稳定性与安全-长期运行必看" class="headerlink" title="四 稳定性与安全(长期运行必看)"></a>四 稳定性与安全(长期运行必看)</h2><h3 id="4-1-API-Key-管理"><a href="#4-1-API-Key-管理" class="headerlink" title="4.1 API Key 管理"></a>4.1 API Key 管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.如果 ComfyUI 对外提供能力：</span><br><span class="line"></span><br><span class="line">-不要直接暴露 ComfyUI</span><br><span class="line">-API Key 放在 后端</span><br><span class="line">-前端只访问你的服务</span><br><span class="line"></span><br><span class="line">2.原则：</span><br><span class="line">模型服务永远不直连公网用户</span><br></pre></td></tr></table></figure><h3 id="4-2-任务隔离-防止互相影响"><a href="#4-2-任务隔离-防止互相影响" class="headerlink" title="4.2 任务隔离(防止互相影响)"></a>4.2 任务隔离(防止互相影响)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.问题场景：</span><br><span class="line">-一个任务 OOM</span><br><span class="line">-全部任务挂掉</span><br><span class="line"></span><br><span class="line">2.解决方式：</span><br><span class="line">-任务队列</span><br><span class="line">-子进程执行</span><br><span class="line">-实例级隔离</span><br><span class="line"></span><br><span class="line">3.进阶方案：</span><br><span class="line">-每类任务一个 Worker</span><br><span class="line">-GPU 资源按需分配</span><br></pre></td></tr></table></figure><h3 id="4-3-数据安全与隐私"><a href="#4-3-数据安全与隐私" class="headerlink" title="4.3 数据安全与隐私"></a>4.3 数据安全与隐私</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.需要重点关注：</span><br><span class="line">-Prompt 是否存储</span><br><span class="line">-生成内容归属</span><br><span class="line">-输出文件权限</span><br><span class="line"></span><br><span class="line">2.建议：</span><br><span class="line">-输出目录隔离</span><br><span class="line">-定期清理缓存</span><br><span class="line">-日志脱敏</span><br></pre></td></tr></table></figure><h2 id="五-小结"><a href="#五-小结" class="headerlink" title="五 小结"></a>五 小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显存优化 = 生存线</span><br><span class="line">Hires / Upscale 是性能武器</span><br><span class="line">Docker 是部署基石</span><br><span class="line">不要裸奔暴露 ComfyUI</span><br><span class="line">工程思维 &gt; 参数技巧</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.显存与性能优化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.服务器部署&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.稳定性与安全&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——工程化与自动化(7)</title>
    <link href="https://pgzxc.github.io/posts/e4c8c157.html"/>
    <id>https://pgzxc.github.io/posts/e4c8c157.html</id>
    <published>2026-02-08T01:37:24.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.Workflow 设计方法论</span><br><span class="line"> 2.Workflow JSON 深度解析</span><br><span class="line"> 3.自定义节点(Custom Nodes)</span><br><span class="line"> 4.ComfyUI API 使用</span><br><span class="line"> 5.ComfyUI + Agent 架构(终极形态)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-Workflow-设计方法论"><a href="#二-Workflow-设计方法论" class="headerlink" title="二 Workflow 设计方法论"></a>二 Workflow 设计方法论</h2><h3 id="2-1-为什么要“设计”Workflow？"><a href="#2-1-为什么要“设计”Workflow？" class="headerlink" title="2.1 为什么要“设计”Workflow？"></a>2.1 为什么要“设计”Workflow？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.新手常见 Workflow 特点：</span><br><span class="line">-节点一大坨</span><br><span class="line">-只适合当前任务</span><br><span class="line">-改一个参数要全图找</span><br><span class="line">-不能复用、不能扩展</span><br><span class="line"></span><br><span class="line">2.工程化 Workflow 的目标是：</span><br><span class="line">像写代码一样搭流程</span><br></pre></td></tr></table></figure><h3 id="2-2-拆分-复用-模块化"><a href="#2-2-拆分-复用-模块化" class="headerlink" title="2.2 拆分 &#x2F; 复用 &#x2F; 模块化"></a>2.2 拆分 &#x2F; 复用 &#x2F; 模块化</h3><p>1-拆分(Separation)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.把一个大 Workflow 拆成：</span><br><span class="line">输入模块（Input）</span><br><span class="line">生成模块（Generate）</span><br><span class="line">控制模块（Control）</span><br><span class="line">后处理模块（Post）</span><br><span class="line"></span><br><span class="line">2.示意结构：</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line"> ├─ Prompt</span><br><span class="line"> ├─ Image</span><br><span class="line"> └─ Params</span><br><span class="line">      ↓</span><br><span class="line">Generate</span><br><span class="line">      ↓</span><br><span class="line">Post Process</span><br><span class="line">      ↓</span><br><span class="line">Output</span><br></pre></td></tr></table></figure><p>2-复用(Reuse)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.常见可复用模块：</span><br><span class="line">-LoRA 组合模块</span><br><span class="line">-ControlNet 模块</span><br><span class="line">-Upscale 模块</span><br><span class="line">-Hires 修复模块</span><br><span class="line"></span><br><span class="line">2.思想：</span><br><span class="line">一个模块 = 一个职责</span><br></pre></td></tr></table></figure><p>3-模块化(Modular)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.工程级 Workflow 特点：</span><br><span class="line">-模块之间 弱耦合</span><br><span class="line">-可插拔</span><br><span class="line">-可替换</span><br><span class="line"></span><br><span class="line">2.例如：</span><br><span class="line"></span><br><span class="line">Upscale Module</span><br><span class="line">  ├─ ESRGAN</span><br><span class="line">  └─ Real-ESRGAN</span><br></pre></td></tr></table></figure><h3 id="2-3-参数抽象"><a href="#2-3-参数抽象" class="headerlink" title="2.3 参数抽象"></a>2.3 参数抽象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.不要把参数“写死”在节点里。</span><br><span class="line"></span><br><span class="line">2.做法：</span><br><span class="line">-使用统一参数节点</span><br><span class="line">-通过 reroute / primitive 控制</span><br><span class="line">-暴露关键参数</span><br><span class="line"></span><br><span class="line">3.典型抽象参数：</span><br><span class="line">-Steps</span><br><span class="line">-CFG</span><br><span class="line">-Denoise</span><br><span class="line">-Seed</span><br><span class="line">-分辨率</span><br><span class="line"></span><br><span class="line">4.好处：</span><br><span class="line">-调参效率极高</span><br><span class="line">-方便 API 调用</span><br><span class="line">-方便 LLM 控制</span><br></pre></td></tr></table></figure><h2 id="三-Workflow-JSON-深度解析"><a href="#三-Workflow-JSON-深度解析" class="headerlink" title="三 Workflow JSON 深度解析"></a>三 Workflow JSON 深度解析</h2><h3 id="3-1-Workflow-本质就是-JSON"><a href="#3-1-Workflow-本质就是-JSON" class="headerlink" title="3.1 Workflow 本质就是 JSON"></a>3.1 Workflow 本质就是 JSON</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.ComfyUI 的 Workflow：100% 可序列化 JSON</span><br><span class="line"></span><br><span class="line">2.JSON 中包含：</span><br><span class="line">-节点定义</span><br><span class="line">-节点参数</span><br><span class="line">-节点连接关系</span><br><span class="line">-UI 位置信息</span><br></pre></td></tr></table></figure><h3 id="3-2-JSON-核心结构-简化"><a href="#3-2-JSON-核心结构-简化" class="headerlink" title="3.2 JSON 核心结构(简化)"></a>3.2 JSON 核心结构(简化)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;nodes&quot;: &#123;</span><br><span class="line">    &quot;1&quot;: &#123;</span><br><span class="line">      &quot;class_type&quot;: &quot;KSampler&quot;,</span><br><span class="line">      &quot;inputs&quot;: &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;links&quot;: [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.关键概念：</span><br><span class="line">-class_type：节点类型</span><br><span class="line">-inputs：参数或输入连接</span><br><span class="line">-links：节点之间的数据流</span><br></pre></td></tr></table></figure><h3 id="3-3-手写-vs-自动生成"><a href="#3-3-手写-vs-自动生成" class="headerlink" title="3.3 手写 vs 自动生成"></a>3.3 手写 vs 自动生成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.自动生成（UI）</span><br><span class="line">-直观</span><br><span class="line">-易出错但好理解</span><br><span class="line">-适合学习</span><br><span class="line"></span><br><span class="line">2.手写 / 程序生成（高阶）</span><br><span class="line">-批量生成 Workflow</span><br><span class="line">-动态拼装流程</span><br><span class="line">-与后端系统结合</span><br><span class="line"></span><br><span class="line">3.实际工程中：</span><br><span class="line">UI 用于设计，JSON 用于生产</span><br></pre></td></tr></table></figure><h3 id="3-4-Workflow-的版本管理"><a href="#3-4-Workflow-的版本管理" class="headerlink" title="3.4 Workflow 的版本管理"></a>3.4 Workflow 的版本管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.强烈建议：</span><br><span class="line">-Workflow JSON 纳入 Git</span><br><span class="line">-每次修改即提交</span><br><span class="line">-模型版本写清楚</span><br><span class="line"></span><br><span class="line">2.最佳实践：</span><br><span class="line"></span><br><span class="line">workflow/</span><br><span class="line"> ├─ image_v1.json</span><br><span class="line"> ├─ image_v2_controlnet.json</span><br><span class="line"> └─ video_v1.json</span><br></pre></td></tr></table></figure><h2 id="四-自定义节点-Custom-Nodes"><a href="#四-自定义节点-Custom-Nodes" class="headerlink" title="四 自定义节点(Custom Nodes)"></a>四 自定义节点(Custom Nodes)</h2><h3 id="4-1-为什么要自定义节点？"><a href="#4-1-为什么要自定义节点？" class="headerlink" title="4.1  为什么要自定义节点？"></a>4.1  为什么要自定义节点？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当你遇到：</span><br><span class="line">-逻辑重复</span><br><span class="line">-参数组合复杂</span><br><span class="line">-需要调用外部服务</span><br><span class="line">-官方节点不够用</span><br><span class="line"></span><br><span class="line">就该写 Custom Node 了。</span><br></pre></td></tr></table></figure><h3 id="4-2-ComfyUI-节点机制简介"><a href="#4-2-ComfyUI-节点机制简介" class="headerlink" title="4.2 ComfyUI 节点机制简介"></a>4.2 ComfyUI 节点机制简介</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.一个节点本质是：</span><br><span class="line">-Python 类</span><br><span class="line">-输入定义</span><br><span class="line">-输出定义</span><br><span class="line">-执行函数</span><br><span class="line"></span><br><span class="line">2.核心文件结构：</span><br><span class="line"></span><br><span class="line">custom_nodes/</span><br><span class="line"> └─ my_node/</span><br><span class="line">     ├─ __init__.py</span><br><span class="line">     └─ node.py</span><br></pre></td></tr></table></figure><h3 id="4-3-Python-自定义节点核心要点"><a href="#4-3-Python-自定义节点核心要点" class="headerlink" title="4.3 Python 自定义节点核心要点"></a>4.3 Python 自定义节点核心要点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.核心元素：</span><br><span class="line">-INPUT_TYPES</span><br><span class="line">-RETURN_TYPES</span><br><span class="line">-FUNCTION</span><br><span class="line">-CATEGORY</span><br><span class="line"></span><br><span class="line">2.节点思维：</span><br><span class="line">输入 → 处理 → 输出</span><br><span class="line"></span><br><span class="line">3.重要原则：</span><br><span class="line">-节点要“纯”</span><br><span class="line">-不要有副作用</span><br><span class="line">-输入输出清晰</span><br></pre></td></tr></table></figure><h3 id="4-4-调试与发布"><a href="#4-4-调试与发布" class="headerlink" title="4.4 调试与发布"></a>4.4 调试与发布</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.调试技巧</span><br><span class="line">-控制台日志</span><br><span class="line">-打印输入输出</span><br><span class="line">-小数据先测</span><br><span class="line"></span><br><span class="line">2.发布方式</span><br><span class="line">-GitHub 仓库</span><br><span class="line">-pip 安装</span><br><span class="line">-子模块引用</span><br></pre></td></tr></table></figure><h2 id="五-ComfyUI-API-使用"><a href="#五-ComfyUI-API-使用" class="headerlink" title="五 ComfyUI API 使用"></a>五 ComfyUI API 使用</h2><h3 id="5-1-为什么用-API？"><a href="#5-1-为什么用-API？" class="headerlink" title="5.1 为什么用 API？"></a>5.1 为什么用 API？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.API 让 ComfyUI 从：手工工具 升级为：AI 服务</span><br></pre></td></tr></table></figure><h3 id="5-2-HTTP-API-基本能力"><a href="#5-2-HTTP-API-基本能力" class="headerlink" title="5.2 HTTP API 基本能力"></a>5.2 HTTP API 基本能力</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.常见能力：</span><br><span class="line">-提交 Workflow</span><br><span class="line">-传入参数</span><br><span class="line">-获取结果</span><br><span class="line">-批量任务</span><br><span class="line"></span><br><span class="line">2.基本流程：</span><br><span class="line"></span><br><span class="line">Client</span><br><span class="line"> → POST Workflow JSON</span><br><span class="line"> → ComfyUI 执行</span><br><span class="line"> → 返回结果</span><br></pre></td></tr></table></figure><h3 id="5-3-批量生成-生产级"><a href="#5-3-批量生成-生产级" class="headerlink" title="5.3 批量生成(生产级)"></a>5.3 批量生成(生产级)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.批量生成常用策略：</span><br><span class="line">-固定 Workflow</span><br><span class="line">-动态参数</span><br><span class="line">-队列执行</span><br><span class="line"></span><br><span class="line">2.应用场景：</span><br><span class="line">-电商商品图</span><br><span class="line">-短视频封面</span><br><span class="line">-素材库生成</span><br></pre></td></tr></table></figure><h3 id="5-4-与后端服务集成"><a href="#5-4-与后端服务集成" class="headerlink" title="5.4 与后端服务集成"></a>5.4 与后端服务集成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.常见架构：</span><br><span class="line">前端</span><br><span class="line"> → 后端 API</span><br><span class="line"> → ComfyUI</span><br><span class="line"> → 存储 / CDN</span><br><span class="line"></span><br><span class="line">2.优势：</span><br><span class="line">-前端不接触模型</span><br><span class="line">-权限可控</span><br><span class="line">-易扩展</span><br></pre></td></tr></table></figure><h2 id="六-ComfyUI-Agent-架构"><a href="#六-ComfyUI-Agent-架构" class="headerlink" title="六 ComfyUI + Agent 架构"></a>六 ComfyUI + Agent 架构</h2><h3 id="6-1-为什么要-Agent？"><a href="#6-1-为什么要-Agent？" class="headerlink" title="6.1 为什么要 Agent？"></a>6.1 为什么要 Agent？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.传统流程：人 → 调参数 → 出图</span><br><span class="line"></span><br><span class="line">2.Agent 流程：</span><br><span class="line"></span><br><span class="line">人 → 需求</span><br><span class="line">   → LLM 规划</span><br><span class="line">   → 自动执行 Workflow</span><br><span class="line">   → 输出结果</span><br></pre></td></tr></table></figure><h3 id="6-2-LLM-控制-Workflow-的方式"><a href="#6-2-LLM-控制-Workflow-的方式" class="headerlink" title="6.2 LLM 控制 Workflow 的方式"></a>6.2 LLM 控制 Workflow 的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.LLM 可以：</span><br><span class="line">-生成 Prompt</span><br><span class="line">-决定参数</span><br><span class="line">-选择 Workflow</span><br><span class="line">-控制执行顺序</span><br><span class="line"></span><br><span class="line">2.示例逻辑：</span><br><span class="line"></span><br><span class="line">用户需求</span><br><span class="line"> → LLM 解析</span><br><span class="line"> → Workflow JSON 拼装</span><br><span class="line"> → ComfyUI 执行</span><br></pre></td></tr></table></figure><h3 id="6-3-自动化内容生产线"><a href="#6-3-自动化内容生产线" class="headerlink" title="6.3 自动化内容生产线"></a>6.3 自动化内容生产线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.完整生产线示例：</span><br><span class="line"></span><br><span class="line">需求输入</span><br><span class="line"> → LLM 生成方案</span><br><span class="line"> → Image / Video</span><br><span class="line"> → Upscale</span><br><span class="line"> → Audio</span><br><span class="line"> → 文案生成</span><br><span class="line"> → 发布</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.说明：这已经是 AI 工厂级架构</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.Workflow 设计方法论&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.Workflow JSON 深度解析&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.自定义节点(Custom Nodes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4.ComfyUI API 使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 5.ComfyUI + Agent 架构(终极形态)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——视频与多模态(6)</title>
    <link href="https://pgzxc.github.io/posts/93828428.html"/>
    <id>https://pgzxc.github.io/posts/93828428.html</id>
    <published>2026-02-07T01:10:46.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.ComfyUI 视频生成架构</span><br><span class="line"> 2.图像-&gt;视频流程(Image to Video)</span><br><span class="line"> 3.多模态联动(ComfyUI 的真正上限)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-ComfyUI-视频生成架构"><a href="#二-ComfyUI-视频生成架构" class="headerlink" title="二 ComfyUI 视频生成架构"></a>二 ComfyUI 视频生成架构</h2><h3 id="2-1-为什么视频生成比图像难？"><a href="#2-1-为什么视频生成比图像难？" class="headerlink" title="2.1 为什么视频生成比图像难？"></a>2.1 为什么视频生成比图像难？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.图像生成只关心：空间一致性（Spatial）</span><br><span class="line">2.而视频生成同时要保证：空间一致性 + 时间一致性（Temporal）</span><br><span class="line">3.视频的本质是：Image₁ → Image₂ → Image₃ → ... → Imageₙ</span><br><span class="line"></span><br><span class="line">4.如果每一帧都“随意生成”，就会出现：</span><br><span class="line">-画面闪烁</span><br><span class="line">-人脸漂移</span><br><span class="line">-风格不稳定</span><br></pre></td></tr></table></figure><h3 id="2-2-视频-Diffusion-的基本原理-简化"><a href="#2-2-视频-Diffusion-的基本原理-简化" class="headerlink" title="2.2 视频 Diffusion 的基本原理(简化)"></a>2.2 视频 Diffusion 的基本原理(简化)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.当前主流视频生成思路：</span><br><span class="line">-以图像 Diffusion 为基础</span><br><span class="line">-引入 时间维度（Time Axis）</span><br><span class="line">-在采样过程中约束相邻帧变化</span><br><span class="line"></span><br><span class="line">2.可以理解为：</span><br><span class="line">“在 KSampler 的基础上，让模型同时考虑前后帧”</span><br></pre></td></tr></table></figure><h3 id="2-3-ComfyUI-中的视频生成定位"><a href="#2-3-ComfyUI-中的视频生成定位" class="headerlink" title="2.3 ComfyUI 中的视频生成定位"></a>2.3 ComfyUI 中的视频生成定位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.ComfyUI 本身不是“单一视频模型”，而是：视频生成工作流调度器</span><br><span class="line"></span><br><span class="line">2.它的优势在于：</span><br><span class="line">-可插拔模型（AnimateDiff、Video Diffusion）</span><br><span class="line">-帧级可控</span><br><span class="line">-能与 ControlNet / LoRA / Upscale 结合</span><br></pre></td></tr></table></figure><h3 id="2-4-帧-Frame-与时间维度的核心概念"><a href="#2-4-帧-Frame-与时间维度的核心概念" class="headerlink" title="2.4 帧(Frame)与时间维度的核心概念"></a>2.4 帧(Frame)与时间维度的核心概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.帧数（Frames）</span><br><span class="line">-决定视频长度</span><br><span class="line">-帧数越多 → 显存占用越高</span><br><span class="line"></span><br><span class="line">2.FPS（帧率）</span><br><span class="line">-影响流畅度</span><br><span class="line">-常见：8 / 12 / 24</span><br><span class="line"></span><br><span class="line">3.时间一致性来源</span><br><span class="line">-固定 Seed</span><br><span class="line">-Temporal 模块</span><br><span class="line">-帧间约束节点</span><br></pre></td></tr></table></figure><h2 id="三-图像-视频流程-Image-to-Video"><a href="#三-图像-视频流程-Image-to-Video" class="headerlink" title="三 图像-&gt;视频流程(Image to Video)"></a>三 图像-&gt;视频流程(Image to Video)</h2><p>这是 目前最实用、成功率最高的视频生成方式</p><h3 id="3-1-Image-Video-的基本思路"><a href="#3-1-Image-Video-的基本思路" class="headerlink" title="3.1 Image-&gt;Video 的基本思路"></a>3.1 Image-&gt;Video 的基本思路</h3><p>1-流程本质是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首帧图像</span><br><span class="line"> → 在保持结构的前提下</span><br><span class="line"> → 逐帧扩散变化</span><br></pre></td></tr></table></figure><p>2-相比 Text to Video</p><table><thead><tr><th align="center">方式</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">Text → Video</td><td align="center">低</td></tr><tr><td align="center">Image → Video</td><td align="center">高</td></tr></tbody></table><h3 id="3-2-ComfyUI-中典型流程结构"><a href="#3-2-ComfyUI-中典型流程结构" class="headerlink" title="3.2 ComfyUI 中典型流程结构"></a>3.2 ComfyUI 中典型流程结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、简化逻辑</span><br><span class="line">Load Image（首帧）</span><br><span class="line"> → Video Diffusion / AnimateDiff</span><br><span class="line"> → Frame Latents</span><br><span class="line"> → Decode Frames</span><br><span class="line"> → Video Combine</span><br><span class="line"></span><br><span class="line">2、核心思想</span><br><span class="line">-首帧决定一切</span><br><span class="line">-后续帧只允许“微变化”</span><br></pre></td></tr></table></figure><h3 id="3-3-定性控制关键点"><a href="#3-3-定性控制关键点" class="headerlink" title="3.3 定性控制关键点"></a>3.3 定性控制关键点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.固定 Seed</span><br><span class="line">-所有帧共用 Seed</span><br><span class="line">-减少随机漂移</span><br><span class="line"></span><br><span class="line">2.降低 Denoise</span><br><span class="line">-视频中 denoise 通常 &lt; 0.5</span><br><span class="line">-防止“每帧重画”</span><br><span class="line"></span><br><span class="line">3.控制 Motion 强度</span><br><span class="line">-动作太大 → 抖动</span><br><span class="line">-动作太小 → 像 GIF</span><br></pre></td></tr></table></figure><h3 id="3-4-风格一致性的保证方式"><a href="#3-4-风格一致性的保证方式" class="headerlink" title="3.4 风格一致性的保证方式"></a>3.4 风格一致性的保证方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.常用组合：</span><br><span class="line">-固定 Checkpoint</span><br><span class="line">-固定 LoRA</span><br><span class="line">-固定 CFG</span><br><span class="line">-统一 Prompt</span><br><span class="line"></span><br><span class="line">2.进阶手段：</span><br><span class="line">-ControlNet（Canny / Depth）</span><br><span class="line">-帧间特征共享</span><br></pre></td></tr></table></figure><h2 id="四-多模态联动-ComfyUI-的真正上限"><a href="#四-多模态联动-ComfyUI-的真正上限" class="headerlink" title="四 多模态联动(ComfyUI 的真正上限)"></a>四 多模态联动(ComfyUI 的真正上限)</h2><h3 id="4-1-Image-Audio"><a href="#4-1-Image-Audio" class="headerlink" title="4.1 Image + Audio"></a>4.1 Image + Audio</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.常见应用：</span><br><span class="line">-视频自动配音</span><br><span class="line">-AI 角色说话</span><br><span class="line">-动画配乐</span><br><span class="line"></span><br><span class="line">2.Workflow 思路：</span><br><span class="line"></span><br><span class="line">Image / Video</span><br><span class="line"> → Audio Generate（TTS / 音频模型）</span><br><span class="line"> → 时间轴对齐</span><br><span class="line"> → 合成输出</span><br><span class="line"></span><br><span class="line">3.关键点：</span><br><span class="line">-音频长度要匹配视频帧数</span><br><span class="line">-注意采样率与时长</span><br></pre></td></tr></table></figure><h3 id="4-2-Image-LLM"><a href="#4-2-Image-LLM" class="headerlink" title="4.2 Image + LLM"></a>4.2 Image + LLM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.这是 Agent 工作流的核心雏形。</span><br><span class="line"></span><br><span class="line">2.常见玩法：</span><br><span class="line">-LLM 生成 Prompt</span><br><span class="line">-LLM 自动拆分场景</span><br><span class="line">-LLM 决策参数</span><br><span class="line"></span><br><span class="line">3.示例逻辑：</span><br><span class="line">用户输入需求</span><br><span class="line"> → LLM 生成 Prompt</span><br><span class="line"> → Image Workflow</span><br><span class="line"> → 输出结果</span><br><span class="line"></span><br><span class="line">4.意义：</span><br><span class="line">-非专业用户也能用</span><br><span class="line">-AI 自动“指挥”绘画流程</span><br></pre></td></tr></table></figure><h3 id="4-3-Workflow-自动化-从工具到系统"><a href="#4-3-Workflow-自动化-从工具到系统" class="headerlink" title="4.3 Workflow 自动化(从工具到系统)"></a>4.3 Workflow 自动化(从工具到系统)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.ComfyUI 真正强大的地方在于：它是一个“可编排的多模态流水线”</span><br><span class="line"></span><br><span class="line">2.你可以做到：</span><br><span class="line">-批量生成</span><br><span class="line">-定时任务</span><br><span class="line">-自动出图 + 出视频 + 出文案</span><br><span class="line">-API 调用</span><br><span class="line"></span><br><span class="line">3.典型自动化结构：</span><br><span class="line">Input</span><br><span class="line"> → LLM 决策</span><br><span class="line"> → Image / Video</span><br><span class="line"> → Upscale</span><br><span class="line"> → Audio</span><br><span class="line"> → Output</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.ComfyUI 视频生成架构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.图像-&amp;gt;视频流程(Image to Video)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.多模态联动(ComfyUI 的真正上限)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——进阶控制(5)</title>
    <link href="https://pgzxc.github.io/posts/bd6cb003.html"/>
    <id>https://pgzxc.github.io/posts/bd6cb003.html</id>
    <published>2026-02-05T23:48:44.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.LoRA 使用与组合技巧</span><br><span class="line"> 2.ControlNet 全解析</span><br><span class="line"> 3.Inpainting/Outpainting(局部控制)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-LoRA-使用与组合技巧"><a href="#二-LoRA-使用与组合技巧" class="headerlink" title="二 LoRA 使用与组合技巧"></a>二 LoRA 使用与组合技巧</h2><h3 id="2-1-LoRA-是什么？为什么它这么重要？"><a href="#2-1-LoRA-是什么？为什么它这么重要？" class="headerlink" title="2.1 LoRA 是什么？为什么它这么重要？"></a>2.1 LoRA 是什么？为什么它这么重要？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.一句话理解：</span><br><span class="line">LoRA = 给大模型“外挂的小技能包”</span><br><span class="line"></span><br><span class="line">2.它不是完整模型，而是：</span><br><span class="line">-针对某个风格 / 人物 / 服装 / 画风</span><br><span class="line">-只训练很少的参数</span><br><span class="line">-叠加在 Checkpoint 上使用</span><br><span class="line"></span><br><span class="line">3.优点：</span><br><span class="line">-体积小（几十 MB）</span><br><span class="line">-切换快</span><br><span class="line">-可叠加</span><br><span class="line">-可精细控制</span><br></pre></td></tr></table></figure><h3 id="2-2-LoRA-的工作原理-简化版"><a href="#2-2-LoRA-的工作原理-简化版" class="headerlink" title="2.2 LoRA 的工作原理(简化版)"></a>2.2 LoRA 的工作原理(简化版)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.Stable Diffusion 原模型：</span><br><span class="line">基础能力（通用绘画）</span><br><span class="line"></span><br><span class="line">2.LoRA 做的事：</span><br><span class="line">-在不改动原模型的前提下</span><br><span class="line">-对特定层进行“偏移修正”</span><br><span class="line"></span><br><span class="line">3.所以效果是：</span><br><span class="line">-基础模型 + LoRA = 新风格</span><br><span class="line">-LoRA 本身不能单独用</span><br></pre></td></tr></table></figure><h3 id="2-3-ComfyUI-中如何使用-LoRA？"><a href="#2-3-ComfyUI-中如何使用-LoRA？" class="headerlink" title="2.3 ComfyUI 中如何使用 LoRA？"></a>2.3 ComfyUI 中如何使用 LoRA？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.核心节点</span><br><span class="line">Load LoRA</span><br><span class="line"></span><br><span class="line">2.连接方式（非常关键）：</span><br><span class="line">Checkpoint</span><br><span class="line">   ↓</span><br><span class="line">Load LoRA</span><br><span class="line">   ↓</span><br><span class="line">CLIP / Model</span><br><span class="line"></span><br><span class="line">3.注意：</span><br><span class="line">-LoRA 同时影响 Model 和 CLIP</span><br><span class="line">-不要只连一半</span><br></pre></td></tr></table></figure><h3 id="2-4-多-LoRA-叠加技巧"><a href="#2-4-多-LoRA-叠加技巧" class="headerlink" title="2.4 多 LoRA 叠加技巧"></a>2.4 多 LoRA 叠加技巧</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.ComfyUI 天生支持 LoRA 串联：</span><br><span class="line"></span><br><span class="line"> → LoRA A</span><br><span class="line"> → LoRA B</span><br><span class="line"> → LoRA C</span><br><span class="line"></span><br><span class="line">2.常见组合方式</span><br><span class="line">人物 LoRA + 画风 LoRA</span><br><span class="line">服装 LoRA + 表情 LoRA</span><br><span class="line">写实 LoRA + 光影 LoRA</span><br></pre></td></tr></table></figure><h3 id="2-5-权重控制-决定成败"><a href="#2-5-权重控制-决定成败" class="headerlink" title="2.5 权重控制(决定成败)"></a>2.5 权重控制(决定成败)</h3><p>1-LoRA 权重一般范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.3 ~ 1.2</span><br></pre></td></tr></table></figure><p>2-经验值</p><table><thead><tr><th align="center">场景</th><th align="center">权重</th></tr></thead><tbody><tr><td align="center">风格微调</td><td align="center">0.3 ~ 0.6</td></tr><tr><td align="center">明显特征</td><td align="center">0.7 ~ 0.9</td></tr><tr><td align="center">强风格</td><td align="center">1.0 ~ 1.2</td></tr></tbody></table><p>3-权重过高常见问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">脸崩</span><br><span class="line">画面脏</span><br><span class="line">风格过拟合</span><br><span class="line"></span><br><span class="line">多个 LoRA 时，单个权重要适当降低</span><br></pre></td></tr></table></figure><h2 id="三-ControlNet-全解析"><a href="#三-ControlNet-全解析" class="headerlink" title="三 ControlNet 全解析"></a>三 ControlNet 全解析</h2><h3 id="3-1-ControlNet-的本质"><a href="#3-1-ControlNet-的本质" class="headerlink" title="3.1 ControlNet 的本质"></a>3.1 ControlNet 的本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.一句话：</span><br><span class="line">用“结构信息”强制约束生成结果</span><br><span class="line"></span><br><span class="line">2.它不关心“画得漂不漂亮”，只关心：</span><br><span class="line">-姿势对不对</span><br><span class="line">-轮廓像不像</span><br><span class="line">-深度合不合理</span><br></pre></td></tr></table></figure><h3 id="3-2-ControlNet-基本结构"><a href="#3-2-ControlNet-基本结构" class="headerlink" title="3.2  ControlNet 基本结构"></a>3.2  ControlNet 基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.典型流程：</span><br><span class="line"> → ControlNet Preprocessor</span><br><span class="line"> → ControlNet Model</span><br><span class="line"> → KSampler</span><br><span class="line"></span><br><span class="line">2.关键点：</span><br><span class="line">ControlNet 不是单独生成</span><br><span class="line">它是 影响 KSampler 的去噪过程</span><br></pre></td></tr></table></figure><h3 id="3-3-常用-ControlNet-类型详解"><a href="#3-3-常用-ControlNet-类型详解" class="headerlink" title="3.3 常用 ControlNet 类型详解"></a>3.3 常用 ControlNet 类型详解</h3><p>1- Canny(边缘)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">提取轮廓线</span><br><span class="line">保持构图与外形</span><br><span class="line"></span><br><span class="line">2.适合：</span><br><span class="line">-建筑</span><br><span class="line">-产品</span><br><span class="line">-结构明确的物体</span><br><span class="line"></span><br><span class="line">3.提示：</span><br><span class="line">-Prompt 不要太冲突</span><br><span class="line">-否则容易“拉扯”</span><br></pre></td></tr></table></figure><p>2-OpenPose(姿态)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">人体骨骼</span><br><span class="line">动作锁定</span><br><span class="line"></span><br><span class="line">2.适合：</span><br><span class="line">-人物站姿 / 动作</span><br><span class="line">-跳舞 / 运动</span><br><span class="line">-角色一致性</span><br><span class="line"></span><br><span class="line">3.说明：人像 AI 必学 ControlNet</span><br></pre></td></tr></table></figure><p>3-Depth(深度)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">近大远小</span><br><span class="line">空间关系</span><br><span class="line"></span><br><span class="line">2.适合：</span><br><span class="line">-写实摄影</span><br><span class="line">-场景图</span><br><span class="line">-室内 / 室外</span><br></pre></td></tr></table></figure><h3 id="3-4-不同场景如何选-ControlNet？"><a href="#3-4-不同场景如何选-ControlNet？" class="headerlink" title="3.4 不同场景如何选 ControlNet？"></a>3.4 不同场景如何选 ControlNet？</h3><table><thead><tr><th align="center">场景</th><th align="center">推荐</th></tr></thead><tbody><tr><td align="center">人像</td><td align="center">OpenPose + Depth</td></tr><tr><td align="center">建筑</td><td align="center">Canny + Depth</td></tr><tr><td align="center">产品</td><td align="center">Canny</td></tr><tr><td align="center">插画</td><td align="center">Lineart &#x2F; SoftEdge</td></tr></tbody></table><h3 id="3-5-多-ControlNet-协同"><a href="#3-5-多-ControlNet-协同" class="headerlink" title="3.5 多 ControlNet 协同"></a>3.5 多 ControlNet 协同</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.ComfyUI 支持：多个 ControlNet 同时作用</span><br><span class="line"></span><br><span class="line">2.示例：</span><br><span class="line">-OpenPose：控制动作</span><br><span class="line">-Depth：控制空间</span><br><span class="line">-Canny：控制轮廓</span><br><span class="line"></span><br><span class="line">3.关键技巧：</span><br><span class="line">-每个 ControlNet 都要调权重</span><br><span class="line">-不要全部拉满</span><br><span class="line"></span><br><span class="line">4.推荐权重区间：0.5 ~ 1.0</span><br></pre></td></tr></table></figure><h2 id="四-Inpainting-Outpainting"><a href="#四-Inpainting-Outpainting" class="headerlink" title="四 Inpainting &#x2F; Outpainting"></a>四 Inpainting &#x2F; Outpainting</h2><h3 id="4-1-Inpainting-局部重绘-原理"><a href="#4-1-Inpainting-局部重绘-原理" class="headerlink" title="4.1 Inpainting(局部重绘)原理"></a>4.1 Inpainting(局部重绘)原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.一句话：只让模型“重画你指定的区域”</span><br><span class="line"></span><br><span class="line">2.核心要素：</span><br><span class="line">-原图</span><br><span class="line">-蒙版（Mask）</span><br><span class="line">-去噪强度</span><br></pre></td></tr></table></figure><h3 id="4-2-蒙版技巧"><a href="#4-2-蒙版技巧" class="headerlink" title="4.2 蒙版技巧"></a>4.2 蒙版技巧</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.白色 / 黑色规则</span><br><span class="line">-白色：重绘</span><br><span class="line">-黑色：保留</span><br><span class="line"></span><br><span class="line">2.常见错误：</span><br><span class="line">-画反了</span><br><span class="line">-边缘太硬</span><br></pre></td></tr></table></figure><h3 id="4-3-Inpainting-常用参数建议"><a href="#4-3-Inpainting-常用参数建议" class="headerlink" title="4.3 Inpainting 常用参数建议"></a>4.3 Inpainting 常用参数建议</h3><table><thead><tr><th align="center">场景</th><th align="center">Denoise</th></tr></thead><tbody><tr><td align="center">修脸</td><td align="center">0.2 ~ 0.4</td></tr><tr><td align="center">改衣服</td><td align="center">0.4 ~ 0.6</td></tr><tr><td align="center">大改</td><td align="center">0.6 ~ 0.8</td></tr></tbody></table><p>2-修脸时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Denoise 宁低不高</span><br><span class="line">Prompt 精确</span><br></pre></td></tr></table></figure><h3 id="4-4-Outpainting-画面扩展"><a href="#4-4-Outpainting-画面扩展" class="headerlink" title="4.4 Outpainting(画面扩展)"></a>4.4 Outpainting(画面扩展)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.Outpainting =</span><br><span class="line">在画面外继续生成内容</span><br><span class="line"></span><br><span class="line">2.常见用途：</span><br><span class="line">-横图变竖图</span><br><span class="line">-补背景</span><br><span class="line">-海报扩展</span><br><span class="line"></span><br><span class="line">3.技巧：</span><br><span class="line">-新区域 Prompt 要“弱引导”</span><br><span class="line">-避免喧宾夺主</span><br></pre></td></tr></table></figure><h3 id="4-5-常见坑点汇总"><a href="#4-5-常见坑点汇总" class="headerlink" title="4.5 常见坑点汇总"></a>4.5 常见坑点汇总</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.重绘区域风格不一致:CFG 太高 / LoRA 过强</span><br><span class="line">2.接缝明显:蒙版边缘不柔和</span><br><span class="line">3.修脸越修越怪: Denoise 太高 + 多次叠加</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.LoRA 使用与组合技巧&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.ControlNet 全解析&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.Inpainting/Outpainting(局部控制)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——核心生成流程(4)</title>
    <link href="https://pgzxc.github.io/posts/4401a601.html"/>
    <id>https://pgzxc.github.io/posts/4401a601.html</id>
    <published>2026-02-04T23:11:00.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.文生图 Workflow 原理拆解</span><br><span class="line"> 2.图生图 Workflow</span><br><span class="line"> 3.高清修复(Hires)流程</span><br><span class="line"> 4.Upscale 放大方案</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-文生图-Workflow-原理拆解"><a href="#二-文生图-Workflow-原理拆解" class="headerlink" title="二 文生图 Workflow 原理拆解"></a>二 文生图 Workflow 原理拆解</h2><h3 id="2-1-ComfyUI-文生图的本质"><a href="#2-1-ComfyUI-文生图的本质" class="headerlink" title="2.1 ComfyUI 文生图的本质"></a>2.1 ComfyUI 文生图的本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.一句话总结：</span><br><span class="line">Prompt → 编码 → 潜空间采样 → 解码成图片</span><br><span class="line"></span><br><span class="line">2.对应 ComfyUI 中的三大核心系统：</span><br><span class="line"></span><br><span class="line">文本（Prompt）</span><br><span class="line">  ↓</span><br><span class="line">CLIP 编码</span><br><span class="line">  ↓</span><br><span class="line">Latent（潜空间）</span><br><span class="line">  ↓</span><br><span class="line">Sampler（采样器）</span><br><span class="line">  ↓</span><br><span class="line">VAE 解码</span><br><span class="line">  ↓</span><br><span class="line">Image</span><br></pre></td></tr></table></figure><h3 id="2-2-CLIP-Latent-Sampler-各自做什么？"><a href="#2-2-CLIP-Latent-Sampler-各自做什么？" class="headerlink" title="2.2 CLIP &#x2F; Latent &#x2F; Sampler 各自做什么？"></a>2.2 CLIP &#x2F; Latent &#x2F; Sampler 各自做什么？</h3><p>1-CLIP(文本编码器)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.将自然语言 Prompt 转为模型能理解的向量</span><br><span class="line"></span><br><span class="line">2.分为：</span><br><span class="line">-正向 Prompt（你想要什么）</span><br><span class="line">-反向 Prompt（你不想要什么）</span><br><span class="line"></span><br><span class="line">3.常见节点：</span><br><span class="line">-CLIP Text Encode (Prompt)</span><br><span class="line">-CLIP Text Encode (Negative)</span><br><span class="line"></span><br><span class="line">4.重点理解：</span><br><span class="line">-CLIP 不生成图片</span><br><span class="line">-它只负责 “理解文字”</span><br></pre></td></tr></table></figure><p>2-Latent(潜空间)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.Stable Diffusion 不是直接在像素空间画图，而是：</span><br><span class="line">-在一个低维“潜空间”中生成</span><br><span class="line">-最后再通过 VAE 解码成真实图片</span><br><span class="line"></span><br><span class="line">2.常见节点：</span><br><span class="line">-Empty Latent Image</span><br><span class="line">-VAE Encode</span><br><span class="line">-VAE Decode</span><br><span class="line"></span><br><span class="line">3.优点：</span><br><span class="line">-运算更快</span><br><span class="line">-更稳定</span><br><span class="line">-适合迭代生成</span><br></pre></td></tr></table></figure><p>3-Sampler(采样器)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Sampler 是 真正“画图”的地方。</span><br><span class="line">2.在 ComfyUI 中，核心节点是：KSampler</span><br><span class="line"></span><br><span class="line">3.它负责：</span><br><span class="line">-从随机噪声开始</span><br><span class="line">-1步步“去噪”</span><br><span class="line">-最终生成符合 Prompt 的 Latent</span><br></pre></td></tr></table></figure><h3 id="2-3-KSampler-参数详解-必背"><a href="#2-3-KSampler-参数详解-必背" class="headerlink" title="2.3 KSampler 参数详解(必背)"></a>2.3 KSampler 参数详解(必背)</h3><p>这是 ComfyUI 最重要的节点，没有之一。</p><p>1-Steps(采样步数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">去噪的次数</span><br><span class="line">越高 → 越精细 → 越慢</span><br></pre></td></tr></table></figure><p>常见范围</p><table><thead><tr><th align="center">场景</th><th align="center">Steps</th></tr></thead><tbody><tr><td align="center">测试</td><td align="center">15~20</td></tr><tr><td align="center">正常出图</td><td align="center">20~30</td></tr><tr><td align="center">高质量</td><td align="center">30~40</td></tr></tbody></table><p>2-CFG(提示词引导强度)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.说明：“模型有多听你的话？”</span><br><span class="line"></span><br><span class="line">低 CFG：更自由、更随机</span><br><span class="line">高 CFG：更贴合 Prompt，但容易崩</span><br><span class="line"></span><br><span class="line">2.推荐范围：</span><br><span class="line">5 ~ 9（最常用）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.CFG 太高的问题：</span><br><span class="line">-画面僵硬</span><br><span class="line">-过度锐化</span><br><span class="line">-奇怪构图</span><br></pre></td></tr></table></figure><p>3-Seed(随机种子)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">决定“随机起点”</span><br><span class="line">同 Seed + 同参数 = 基本相同画面</span><br><span class="line"></span><br><span class="line">2.用法技巧：</span><br><span class="line">-1：每次随机</span><br><span class="line">固定 Seed：用于微调、对比参数</span><br></pre></td></tr></table></figure><p>4-Sampler &#x2F; Scheduler</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sampler：去噪算法</span><br><span class="line">Scheduler：步数分配方式</span><br><span class="line"></span><br><span class="line">2.常用组合（新手）：</span><br><span class="line">Sampler: DPM++ 2M</span><br><span class="line">Scheduler: Karras</span><br></pre></td></tr></table></figure><h2 id="三-图生图-Workflow-Image-to-Image"><a href="#三-图生图-Workflow-Image-to-Image" class="headerlink" title="三 图生图 Workflow(Image to Image)"></a>三 图生图 Workflow(Image to Image)</h2><p>图生图 &#x3D; 在已有图片基础上“再创作”</p><h3 id="3-1-图生图与文生图的核心区别"><a href="#3-1-图生图与文生图的核心区别" class="headerlink" title="3.1 图生图与文生图的核心区别"></a>3.1 图生图与文生图的核心区别</h3><table><thead><tr><th align="center">文生图</th><th align="center">图生图</th></tr></thead><tbody><tr><td align="center">从纯噪声开始</td><td align="center">从已有图像开始</td></tr><tr><td align="center">全新生成</td><td align="center">保留原图结构</td></tr><tr><td align="center">不可控性更高</td><td align="center">可控性更强</td></tr></tbody></table><h3 id="3-2-图生图核心节点变化"><a href="#3-2-图生图核心节点变化" class="headerlink" title="3.2 图生图核心节点变化"></a>3.2 图生图核心节点变化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.新增关键节点：</span><br><span class="line">-Load Image</span><br><span class="line">-VAE Encode</span><br><span class="line">-去掉 Empty Latent Image</span><br><span class="line"></span><br><span class="line">2.流程变为：</span><br><span class="line">Image</span><br><span class="line"> → VAE Encode</span><br><span class="line"> → Latent</span><br><span class="line"> → KSampler</span><br><span class="line"> → VAE Decode</span><br></pre></td></tr></table></figure><h3 id="3-3-去噪强度-Denoise-Strength"><a href="#3-3-去噪强度-Denoise-Strength" class="headerlink" title="3.3 去噪强度(Denoise Strength)"></a>3.3 去噪强度(Denoise Strength)</h3><p>这是 图生图最关键参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 KSampler 中体现为：denoise = 0 ~ 1</span><br></pre></td></tr></table></figure><p>2-含义</p><table><thead><tr><th align="center">Denoise</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">0.1~0.3</td><td align="center">微调</td></tr><tr><td align="center">0.4~0.6</td><td align="center">风格迁移</td></tr><tr><td align="center">0.7~0.9</td><td align="center">大幅重绘</td></tr><tr><td align="center">1.0</td><td align="center">接近文生图</td></tr></tbody></table><h3 id="3-4-风格迁移-局部保持"><a href="#3-4-风格迁移-局部保持" class="headerlink" title="3.4 风格迁移 &amp; 局部保持"></a>3.4 风格迁移 &amp; 局部保持</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.风格迁移</span><br><span class="line">-保留结构</span><br><span class="line">-改变画风</span><br><span class="line">-常用 denoise：0.4~0.6</span><br><span class="line"></span><br><span class="line">2.局部保持技巧</span><br><span class="line">-降低 denoise</span><br><span class="line">-使用 ControlNet（后续章节）</span><br><span class="line">-使用 Inpainting</span><br></pre></td></tr></table></figure><h2 id="四-高清修复-Hires-流程"><a href="#四-高清修复-Hires-流程" class="headerlink" title="四 高清修复(Hires)流程"></a>四 高清修复(Hires)流程</h2><h3 id="4-1-说明"><a href="#4-1-说明" class="headerlink" title="4.1 说明"></a>4.1 说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高清修复 ≠ 单纯放大</span><br><span class="line">而是 “先生成 → 再精修”</span><br></pre></td></tr></table></figure><h3 id="4-2-两阶段采样原理"><a href="#4-2-两阶段采样原理" class="headerlink" title="4.2 两阶段采样原理"></a>4.2 两阶段采样原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">阶段一：</span><br><span class="line">-小分辨率生成</span><br><span class="line">-保证构图、姿态正确</span><br><span class="line"></span><br><span class="line">阶段二：</span><br><span class="line">-放大 Latent</span><br><span class="line">-再采样补细节</span><br><span class="line"></span><br><span class="line">好处：</span><br><span class="line">-更清晰</span><br><span class="line">-不容易崩脸</span><br><span class="line">-性能友好</span><br></pre></td></tr></table></figure><h3 id="4-3-Latent-Upscale-是什么？"><a href="#4-3-Latent-Upscale-是什么？" class="headerlink" title="4.3 Latent Upscale 是什么？"></a>4.3 Latent Upscale 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在潜空间中放大</span><br><span class="line">再进行二次采样</span><br><span class="line"></span><br><span class="line">常见节点：</span><br><span class="line">-Latent Upscale</span><br><span class="line">-第二个 KSampler</span><br></pre></td></tr></table></figure><h3 id="4-4-常见问题"><a href="#4-4-常见问题" class="headerlink" title="4.4 常见问题"></a>4.4 常见问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.画面糊</span><br><span class="line">Steps 太低 / CFG 太低</span><br><span class="line"></span><br><span class="line">2.脸崩</span><br><span class="line">Denoise 太高 / 二次采样过强</span><br><span class="line"></span><br><span class="line">3.显存爆</span><br><span class="line">放大倍数太大 / 分辨率过高</span><br></pre></td></tr></table></figure><h2 id="五-Upscale-放大方案"><a href="#五-Upscale-放大方案" class="headerlink" title="五 Upscale 放大方案"></a>五 Upscale 放大方案</h2><h3 id="5-1-Latent-放大-vs-像素放大"><a href="#5-1-Latent-放大-vs-像素放大" class="headerlink" title="5.1 Latent 放大 vs 像素放大"></a>5.1 Latent 放大 vs 像素放大</h3><table><thead><tr><th align="center">方式</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">Latent 放大</td><td align="center">质量高，可再创作</td></tr><tr><td align="center">像素放大</td><td align="center">快，不改变内容</td></tr></tbody></table><h3 id="5-2-ESRGAN-Real-ESRGAN"><a href="#5-2-ESRGAN-Real-ESRGAN" class="headerlink" title="5.2 ESRGAN &#x2F; Real-ESRGAN"></a>5.2 ESRGAN &#x2F; Real-ESRGAN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.ESRGAN</span><br><span class="line">-偏向插画 / 二次元</span><br><span class="line">-锐利感强</span><br><span class="line"></span><br><span class="line">2.Real-ESRGAN</span><br><span class="line">-偏向真实照片</span><br><span class="line">-更自然</span><br></pre></td></tr></table></figure><h3 id="5-3-清晰度与速度的平衡"><a href="#5-3-清晰度与速度的平衡" class="headerlink" title="5.3 清晰度与速度的平衡"></a>5.3 清晰度与速度的平衡</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">推荐策略：</span><br><span class="line">先 Latent Upscale ×2</span><br><span class="line">再 Real-ESRGAN ×2</span><br><span class="line"></span><br><span class="line">兼顾质量与效率</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.文生图 Workflow 原理拆解&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.图生图 Workflow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.高清修复(Hires)流程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4.Upscale 放大方案&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——模型与资源管理(3)</title>
    <link href="https://pgzxc.github.io/posts/9af56ac2.html"/>
    <id>https://pgzxc.github.io/posts/9af56ac2.html</id>
    <published>2026-02-03T23:22:05.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.模型体系总览</span><br><span class="line"> 2.Checkpoint(主模型)</span><br><span class="line"> 3.VAE</span><br><span class="line"> 4.LoRA</span><br><span class="line"> 5.ControlNet(结构控制核心)</span><br><span class="line"> 6.Embedding(文本增强)</span><br><span class="line"> 7.Upscaler(放大模型)</span><br><span class="line"> 8.模型来源与选择建议</span><br><span class="line"> 9.模型管理经验总结</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-模型体系总览"><a href="#二-模型体系总览" class="headerlink" title="二 模型体系总览"></a>二 模型体系总览</h2><h3 id="2-1-为什么模型管理如此重要？"><a href="#2-1-为什么模型管理如此重要？" class="headerlink" title="2.1 为什么模型管理如此重要？"></a>2.1 为什么模型管理如此重要？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.在 ComfyUI 中：</span><br><span class="line">Workflow 是骨架，模型是灵魂。</span><br><span class="line"></span><br><span class="line">2.同一个 Workflow：</span><br><span class="line">-模型不同 → 风格、质量、能力完全不同</span><br><span class="line">-模型放错位置 → Workflow 直接跑不起来</span><br></pre></td></tr></table></figure><h3 id="2-2-ComfyUI-中常见的模型类型"><a href="#2-2-ComfyUI-中常见的模型类型" class="headerlink" title="2.2 ComfyUI 中常见的模型类型"></a>2.2 ComfyUI 中常见的模型类型</h3><table><thead><tr><th align="center">模型类型</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Checkpoint</td><td align="center">主模型，决定整体能力</td></tr><tr><td align="center">VAE</td><td align="center">解码潜空间，影响色彩与细节</td></tr><tr><td align="center">LoRA</td><td align="center">微调模型，控制风格 &#x2F; 人物</td></tr><tr><td align="center">ControlNet</td><td align="center">结构控制</td></tr><tr><td align="center">Embedding</td><td align="center">词向量，增强 Prompt</td></tr><tr><td align="center">Upscaler</td><td align="center">放大清晰度</td></tr><tr><td align="center">Video Model</td><td align="center">视频生成</td></tr><tr><td align="center">Audio Model</td><td align="center">音频生成</td></tr></tbody></table><h2 id="三-Checkpoint-主模型"><a href="#三-Checkpoint-主模型" class="headerlink" title="三 Checkpoint(主模型)"></a>三 Checkpoint(主模型)</h2><h3 id="3-1-什么是-Checkpoint"><a href="#3-1-什么是-Checkpoint" class="headerlink" title="3.1 什么是 Checkpoint"></a>3.1 什么是 Checkpoint</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Checkpoint 通常是：</span><br><span class="line">-.ckpt</span><br><span class="line">-.safetensors</span><br><span class="line"></span><br><span class="line">2.它包含：</span><br><span class="line">-大量参数</span><br><span class="line">-已训练好的权重</span><br><span class="line">-决定模型「能画什么、画成什么样」</span><br></pre></td></tr></table></figure><h3 id="3-2-SD-SDXL-的区别"><a href="#3-2-SD-SDXL-的区别" class="headerlink" title="3.2 SD &#x2F; SDXL 的区别"></a>3.2 SD &#x2F; SDXL 的区别</h3><table><thead><tr><th align="center">项目</th><th align="center">SD 1.5</th><th align="center">SDXL</th></tr></thead><tbody><tr><td align="center">分辨率</td><td align="center">512×512</td><td align="center">1024×1024</td></tr><tr><td align="center">显存</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">质量</td><td align="center">尚可</td><td align="center">更好</td></tr><tr><td align="center">速度</td><td align="center">快</td><td align="center">慢</td></tr></tbody></table><p>新手建议：</p><ul><li>显存 ≤ 8GB：SD 1.5</li><li>显存 ≥ 10GB：SDXL</li></ul><h3 id="3-3-Checkpoint-放哪里？"><a href="#3-3-Checkpoint-放哪里？" class="headerlink" title="3.3 Checkpoint 放哪里？"></a>3.3 Checkpoint 放哪里？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.位置</span><br><span class="line">ComfyUI/models/checkpoints/</span><br><span class="line"></span><br><span class="line">2.放进去后：</span><br><span class="line">-刷新 UI</span><br><span class="line">-在 Load Checkpoint 节点中选择</span><br></pre></td></tr></table></figure><h2 id="四-VAE"><a href="#四-VAE" class="headerlink" title="四 VAE"></a>四 VAE</h2><h3 id="4-1-VAE-是什么？"><a href="#4-1-VAE-是什么？" class="headerlink" title="4.1 VAE 是什么？"></a>4.1 VAE 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.VAE(变分自编码器)负责：把 AI 的“潜空间结果”转成你看到的图片</span><br><span class="line"></span><br><span class="line">2.影响：</span><br><span class="line">-颜色</span><br><span class="line">-对比度</span><br><span class="line">-细节层次</span><br></pre></td></tr></table></figure><h3 id="4-2-是否必须单独使用-VAE？"><a href="#4-2-是否必须单独使用-VAE？" class="headerlink" title="4.2 是否必须单独使用 VAE？"></a>4.2 是否必须单独使用 VAE？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.如何使用</span><br><span class="line">有些 Checkpoint 内置 VAE</span><br><span class="line">有些需要 外置 VAE</span><br><span class="line"></span><br><span class="line">2.经验建议：</span><br><span class="line">模型作者推荐什么 VAE，就用什么</span><br></pre></td></tr></table></figure><h3 id="4-3-VAE-目录"><a href="#4-3-VAE-目录" class="headerlink" title="4.3 VAE 目录"></a>4.3 VAE 目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComfyUI/models/vae/</span><br></pre></td></tr></table></figure><h2 id="五-LoRA"><a href="#五-LoRA" class="headerlink" title="五 LoRA"></a>五 LoRA</h2><h3 id="5-1-LoRA-是什么？"><a href="#5-1-LoRA-是什么？" class="headerlink" title="5.1  LoRA 是什么？"></a>5.1  LoRA 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.LoRA 是：</span><br><span class="line">在不改变主模型的情况下，对某一风格 / 人物 / 特征进行增强</span><br><span class="line"></span><br><span class="line">2.特点：</span><br><span class="line">-文件小(几十 MB)</span><br><span class="line">-可叠加</span><br><span class="line">-可调权重</span><br></pre></td></tr></table></figure><h3 id="5-2-LoRA-的常见用途"><a href="#5-2-LoRA-的常见用途" class="headerlink" title="5.2 LoRA 的常见用途"></a>5.2 LoRA 的常见用途</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">人物脸型</span><br><span class="line">画风</span><br><span class="line">服装</span><br><span class="line">构图风格</span><br></pre></td></tr></table></figure><h3 id="5-3-LoRA-怎么用？"><a href="#5-3-LoRA-怎么用？" class="headerlink" title="5.3 LoRA 怎么用？"></a>5.3 LoRA 怎么用？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、方式一（Prompt）：</span><br><span class="line">&lt;lora:xxx:1.0&gt;</span><br><span class="line"></span><br><span class="line">2、方式二（节点）：</span><br><span class="line">-Load LoRA</span><br><span class="line">-接入 Model + CLIP</span><br></pre></td></tr></table></figure><h3 id="5-4-LoRA-放哪里？"><a href="#5-4-LoRA-放哪里？" class="headerlink" title="5.4 LoRA 放哪里？"></a>5.4 LoRA 放哪里？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComfyUI/models/loras/</span><br></pre></td></tr></table></figure><h2 id="六-ControlNet-结构控制核心"><a href="#六-ControlNet-结构控制核心" class="headerlink" title="六 ControlNet(结构控制核心)"></a>六 ControlNet(结构控制核心)</h2><h3 id="6-1-ControlNet-能做什么？"><a href="#6-1-ControlNet-能做什么？" class="headerlink" title="6.1 ControlNet 能做什么？"></a>6.1 ControlNet 能做什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.ControlNet 用来控制：</span><br><span class="line">-姿态（OpenPose）</span><br><span class="line">-边缘（Canny）</span><br><span class="line">-深度（Depth）</span><br><span class="line">-轮廓（Lineart）</span><br><span class="line"></span><br><span class="line">2.说明：想要“可控画面”，ControlNet 是必学项。</span><br></pre></td></tr></table></figure><h3 id="6-2-ControlNet-的基本结构"><a href="#6-2-ControlNet-的基本结构" class="headerlink" title="6.2 ControlNet 的基本结构"></a>6.2 ControlNet 的基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原图 / 辅助图</span><br><span class="line">ControlNet 模型</span><br><span class="line">与 KSampler 连接</span><br></pre></td></tr></table></figure><h3 id="6-3-ControlNet-模型目录"><a href="#6-3-ControlNet-模型目录" class="headerlink" title="6.3 ControlNet 模型目录"></a>6.3 ControlNet 模型目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComfyUI/models/controlnet/</span><br></pre></td></tr></table></figure><h2 id="七-Embedding-文本增强"><a href="#七-Embedding-文本增强" class="headerlink" title="七 Embedding(文本增强)"></a>七 Embedding(文本增强)</h2><h3 id="7-1-Embedding-是什么？"><a href="#7-1-Embedding-是什么？" class="headerlink" title="7.1 Embedding 是什么？"></a>7.1 Embedding 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Embedding 是：</span><br><span class="line">扩展 Prompt 理解能力的小型向量</span><br><span class="line"></span><br><span class="line">2.通常用于：</span><br><span class="line">-风格词</span><br><span class="line">-质量增强词</span><br></pre></td></tr></table></figure><h3 id="7-2-使用方式"><a href="#7-2-使用方式" class="headerlink" title="7.2 使用方式"></a>7.2 使用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接在 Prompt 中写 embedding 名称即可。</span><br></pre></td></tr></table></figure><h3 id="7-3-目录位置"><a href="#7-3-目录位置" class="headerlink" title="7.3 目录位置"></a>7.3 目录位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComfyUI/models/embeddings/</span><br></pre></td></tr></table></figure><h2 id="八-Upscaler-放大模型"><a href="#八-Upscaler-放大模型" class="headerlink" title="八 Upscaler(放大模型)"></a>八 Upscaler(放大模型)</h2><h3 id="8-1-Upscaler-的作用"><a href="#8-1-Upscaler-的作用" class="headerlink" title="8.1 Upscaler 的作用"></a>8.1 Upscaler 的作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.用于：</span><br><span class="line">-图像放大</span><br><span class="line">-细节增强</span><br><span class="line"></span><br><span class="line">2.常见类型：</span><br><span class="line">-ESRGAN</span><br><span class="line">-Real-ESRGAN</span><br></pre></td></tr></table></figure><h3 id="8-2-Upscaler-目录"><a href="#8-2-Upscaler-目录" class="headerlink" title="8.2 Upscaler 目录"></a>8.2 Upscaler 目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComfyUI/models/upscale_models/</span><br></pre></td></tr></table></figure><h2 id="九-模型来源与选择建议"><a href="#九-模型来源与选择建议" class="headerlink" title="九 模型来源与选择建议"></a>九 模型来源与选择建议</h2><h3 id="9-1-常见来源"><a href="#9-1-常见来源" class="headerlink" title="9.1 常见来源"></a>9.1 常见来源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CivitAI（最常用）</span><br><span class="line">HuggingFace</span><br><span class="line">官方 Templates 自动下载</span><br></pre></td></tr></table></figure><h3 id="9-2-新手模型选择建议"><a href="#9-2-新手模型选择建议" class="headerlink" title="9.2 新手模型选择建议"></a>9.2 新手模型选择建议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不要一次下太多</span><br><span class="line">先 1–2 个主模型</span><br><span class="line">再补 LoRA</span><br></pre></td></tr></table></figure><h2 id="十-模型管理经验总结"><a href="#十-模型管理经验总结" class="headerlink" title="十 模型管理经验总结"></a>十 模型管理经验总结</h2><h3 id="10-1-命名规范"><a href="#10-1-命名规范" class="headerlink" title="10.1 命名规范"></a>10.1 命名规范</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelName_type_version.safetensors</span><br></pre></td></tr></table></figure><h3 id="10-2-分类清晰"><a href="#10-2-分类清晰" class="headerlink" title="10.2 分类清晰"></a>10.2 分类清晰</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不混放</span><br><span class="line">不随意改目录</span><br></pre></td></tr></table></figure><h3 id="10-3-定期清理"><a href="#10-3-定期清理" class="headerlink" title="10.3 定期清理"></a>10.3 定期清理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不用的模型直接删</span><br><span class="line">避免占满 SSD</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.模型体系总览&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.Checkpoint(主模型)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.VAE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4.LoRA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 5.ControlNet(结构控制核心)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 6.Embedding(文本增强)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 7.Upscaler(放大模型)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 8.模型来源与选择建议&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 9.模型管理经验总结&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
    <category term="模型" scheme="https://pgzxc.github.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>ComfyUI开发之——Templates模板体系(2)</title>
    <link href="https://pgzxc.github.io/posts/6e9bbc5f.html"/>
    <id>https://pgzxc.github.io/posts/6e9bbc5f.html</id>
    <published>2026-02-03T00:49:23.000Z</published>
    <updated>2026-02-22T02:43:05.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一下内容：</span><br><span class="line"> 1.Templates 是什么</span><br><span class="line"> 2.Templates 的入口与使用方式</span><br><span class="line"> 3.Image Templates 全解析</span><br><span class="line"> 4.Video Templates</span><br><span class="line"> 5.Audio Templates</span><br><span class="line"> 6.3D Model Templates</span><br><span class="line"> 7.LLM Templates</span><br><span class="line"> 8.Utility Templates</span><br><span class="line"> 9.Partner Nodes Templates</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="二-Templates-是什么？为什么一定要先学模板"><a href="#二-Templates-是什么？为什么一定要先学模板" class="headerlink" title="二 Templates 是什么？为什么一定要先学模板"></a>二 Templates 是什么？为什么一定要先学模板</h2><h3 id="2-1-Templates-的本质"><a href="#2-1-Templates-的本质" class="headerlink" title="2.1 Templates 的本质"></a>2.1 Templates 的本质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.在 ComfyUI 中：</span><br><span class="line">Template = 官方预设的 Workflow（工作流）</span><br><span class="line"></span><br><span class="line">2.它并不是“示例截图”，而是：</span><br><span class="line">-真正可运行的流程</span><br><span class="line">-已连接好的节点</span><br><span class="line">-已验证可用的结构</span><br><span class="line"></span><br><span class="line">你打开模板，本质是在加载一个 .json 工作流。</span><br></pre></td></tr></table></figure><h3 id="2-2-为什么不建议新手一开始自己搭？"><a href="#2-2-为什么不建议新手一开始自己搭？" class="headerlink" title="2.2 为什么不建议新手一开始自己搭？"></a>2.2 为什么不建议新手一开始自己搭？</h3><p>1、原因很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-节点多</span><br><span class="line">-依赖复杂</span><br><span class="line">-参数组合容易错</span><br><span class="line">-新手不知道「正确结构是什么样」</span><br></pre></td></tr></table></figure><p>2、Templates解决</p><table><thead><tr><th align="center">问题</th><th align="center">Templates 的作用</th></tr></thead><tbody><tr><td align="center">不知道要哪些节点</td><td align="center">已搭好</td></tr><tr><td align="center">不知道连接顺序</td><td align="center">已连接</td></tr><tr><td align="center">不知道参数范围</td><td align="center">给了合理默认</td></tr><tr><td align="center">模型缺失</td><td align="center">自动提示下载</td></tr></tbody></table><p>说明：模板 &#x3D; 最佳学习样本</p><h3 id="2-3-Templates-与普通-Workflow-的区别"><a href="#2-3-Templates-与普通-Workflow-的区别" class="headerlink" title="2.3 Templates 与普通 Workflow 的区别"></a>2.3 Templates 与普通 Workflow 的区别</h3><table><thead><tr><th align="center">项目</th><th align="center">Templates</th><th align="center">普通 Workflow</th></tr></thead><tbody><tr><td align="center">来源</td><td align="center">官方维护</td><td align="center">用户自建</td></tr><tr><td align="center">完整性</td><td align="center">高</td><td align="center">不一定</td></tr><tr><td align="center">依赖检测</td><td align="center">有</td><td align="center">没有</td></tr><tr><td align="center">学习价值</td><td align="center">5星</td><td align="center">3星</td></tr></tbody></table><h2 id="三-Templates-的入口与使用方式"><a href="#三-Templates-的入口与使用方式" class="headerlink" title="三 Templates 的入口与使用方式"></a>三 Templates 的入口与使用方式</h2><h3 id="3-1-如何打开-Templates"><a href="#3-1-如何打开-Templates" class="headerlink" title="3.1 如何打开 Templates"></a>3.1 如何打开 Templates</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.两种方式(以新版 UI 为准)：</span><br><span class="line">-左侧栏 → Templates</span><br><span class="line">-顶部菜单：Workflow → Browse Workflow Templates</span><br><span class="line"></span><br><span class="line">2.打开后你会看到一个模板浏览器面板。</span><br></pre></td></tr></table></figure><h3 id="3-2-Templates-面板结构说明"><a href="#3-2-Templates-面板结构说明" class="headerlink" title="3.2 Templates 面板结构说明"></a>3.2 Templates 面板结构说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般包含：</span><br><span class="line">-分类（Category）</span><br><span class="line">-模板卡片（Card）</span><br><span class="line">-简要说明</span><br><span class="line">-依赖提示</span><br></pre></td></tr></table></figure><h3 id="3-3-All-Templates-分类一览"><a href="#3-3-All-Templates-分类一览" class="headerlink" title="3.3 All Templates 分类一览"></a>3.3 All Templates 分类一览</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见分类包括：</span><br><span class="line">-Image</span><br><span class="line">-Video</span><br><span class="line">-Audio</span><br><span class="line">-3D Model</span><br><span class="line">-LLM</span><br><span class="line">-Utility</span><br><span class="line">-Partner Nodes</span><br><span class="line"></span><br><span class="line">这些分类不是随便分的，而是按「生成对象类型」来分</span><br></pre></td></tr></table></figure><h2 id="四-Image-Templates-全解析-入门首选"><a href="#四-Image-Templates-全解析-入门首选" class="headerlink" title="四 Image Templates 全解析(入门首选)"></a>四 Image Templates 全解析(入门首选)</h2><h3 id="4-1-Image-Templates-是什么"><a href="#4-1-Image-Templates-是什么" class="headerlink" title="4.1 Image Templates 是什么"></a>4.1 Image Templates 是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Image Templates 是使用频率最高、最成熟的一类模板，覆盖：</span><br><span class="line">-文生图（Text to Image）</span><br><span class="line">-图生图（Image to Image）</span><br><span class="line">-高清修复</span><br><span class="line">-Inpainting / Outpainting</span><br><span class="line"></span><br><span class="line">建议所有新手从这里开始。</span><br></pre></td></tr></table></figure><h3 id="4-2-Image-模板的典型结构"><a href="#4-2-Image-模板的典型结构" class="headerlink" title="4.2 Image 模板的典型结构"></a>4.2 Image 模板的典型结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">几乎所有 Image 模板都会包含：</span><br><span class="line">-Load Checkpoint（加载模型）</span><br><span class="line">-CLIP Text Encode（正/反提示词）</span><br><span class="line">-Latent Image</span><br><span class="line">-KSampler</span><br><span class="line">-VAE Decode</span><br><span class="line">-Save Image</span><br><span class="line"></span><br><span class="line">这是 Stable Diffusion 的标准流程。</span><br></pre></td></tr></table></figure><h3 id="4-3-使用-Image-模板的标准步骤"><a href="#4-3-使用-Image-模板的标准步骤" class="headerlink" title="4.3 使用 Image 模板的标准步骤"></a>4.3 使用 Image 模板的标准步骤</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.打开 Image 分类</span><br><span class="line">2.选择一个模板（如 Text to Image）</span><br><span class="line">3.等待依赖检查</span><br><span class="line">4.填写 Prompt</span><br><span class="line">5.点击 Queue / Run</span><br><span class="line">6.查看生成结果</span><br></pre></td></tr></table></figure><h3 id="4-4-新手建议的第一个模板"><a href="#4-4-新手建议的第一个模板" class="headerlink" title="4.4 新手建议的第一个模板"></a>4.4 新手建议的第一个模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">推荐顺序：</span><br><span class="line">1.Text to Image（基础）</span><br><span class="line">2.Image to Image</span><br><span class="line">3.Inpainting</span><br></pre></td></tr></table></figure><h2 id="五-Video-Templates-谨慎但值得"><a href="#五-Video-Templates-谨慎但值得" class="headerlink" title="五 Video Templates(谨慎但值得)"></a>五 Video Templates(谨慎但值得)</h2><h3 id="5-1-Video-Templates-是什么"><a href="#5-1-Video-Templates-是什么" class="headerlink" title="5.1 Video Templates 是什么"></a>5.1 Video Templates 是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Video Templates 用于：</span><br><span class="line">-文生视频</span><br><span class="line">-图生视频</span><br><span class="line">-视频风格迁移</span><br><span class="line"></span><br><span class="line">2.它们的特点是：</span><br><span class="line">-节点多</span><br><span class="line">-模型大</span><br><span class="line">-显存占用高</span><br></pre></td></tr></table></figure><h3 id="5-2-使用前必须知道的事"><a href="#5-2-使用前必须知道的事" class="headerlink" title="5.2 使用前必须知道的事"></a>5.2 使用前必须知道的事</h3><table><thead><tr><th align="center">项目</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">显存</td><td align="center">建议 12GB+</td></tr><tr><td align="center">速度</td><td align="center">非常慢</td></tr><tr><td align="center">模型</td><td align="center">动辄几个 GB</td></tr><tr><td align="center">稳定性</td><td align="center">依赖模型</td></tr></tbody></table><p>说明：不建议新手一开始就碰</p><h3 id="5-3-正确学习方式"><a href="#5-3-正确学习方式" class="headerlink" title="5.3 正确学习方式"></a>5.3 正确学习方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先跑通 Image</span><br><span class="line">再用 Video 模板</span><br><span class="line">不要一上来就改结构</span><br></pre></td></tr></table></figure><h2 id="六-Audio-Templates-了解即可"><a href="#六-Audio-Templates-了解即可" class="headerlink" title="六 Audio Templates(了解即可)"></a>六 Audio Templates(了解即可)</h2><h3 id="6-1-Audio-模板定位"><a href="#6-1-Audio-模板定位" class="headerlink" title="6.1 Audio 模板定位"></a>6.1 Audio 模板定位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.用于：</span><br><span class="line">-音频生成</span><br><span class="line">-语音处理</span><br><span class="line">-音乐相关实验</span><br><span class="line"></span><br><span class="line">2.说明：目前生态仍在发展中。</span><br></pre></td></tr></table></figure><h3 id="6-2-使用注意"><a href="#6-2-使用注意" class="headerlink" title="6.2 使用注意"></a>6.2 使用注意</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多数依赖自定义节点</span><br><span class="line">模型来源复杂</span><br><span class="line">更偏实验性质</span><br></pre></td></tr></table></figure><h2 id="七-3D-Model-Templates-前沿方向"><a href="#七-3D-Model-Templates-前沿方向" class="headerlink" title="七 3D Model Templates(前沿方向)"></a>七 3D Model Templates(前沿方向)</h2><h3 id="7-1-能做什么"><a href="#7-1-能做什么" class="headerlink" title="7.1 能做什么"></a>7.1 能做什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文生 3D 模型</span><br><span class="line">输出 Mesh / 点云</span><br></pre></td></tr></table></figure><h3 id="7-2-当前阶段认知"><a href="#7-2-当前阶段认知" class="headerlink" title="7.2 当前阶段认知"></a>7.2 当前阶段认知</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">能用</span><br><span class="line">但不稳定</span><br><span class="line">更多是“技术展示”</span><br></pre></td></tr></table></figure><h2 id="八-LLM-Templates-非常重要"><a href="#八-LLM-Templates-非常重要" class="headerlink" title="八 LLM Templates(非常重要)"></a>八 LLM Templates(非常重要)</h2><h3 id="8-1-LLM-Templates-是什么"><a href="#8-1-LLM-Templates-是什么" class="headerlink" title="8.1 LLM Templates 是什么"></a>8.1 LLM Templates 是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这类模板用于：</span><br><span class="line">-文本生成</span><br><span class="line">-Prompt 自动生成</span><br><span class="line">-AI 作为“流程大脑”</span><br></pre></td></tr></table></figure><h3 id="8-2-一个常见用法"><a href="#8-2-一个常见用法" class="headerlink" title="8.2 一个常见用法"></a>8.2 一个常见用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LLM 生成 Prompt → Image 模板生图</span><br><span class="line">这是未来 ComfyUI 的核心方向之一。</span><br></pre></td></tr></table></figure><h2 id="九-Utility-Templates-工具流"><a href="#九-Utility-Templates-工具流" class="headerlink" title="九 Utility Templates(工具流)"></a>九 Utility Templates(工具流)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.用于：</span><br><span class="line">-Prompt 清洗</span><br><span class="line">-参数转换</span><br><span class="line">-图像分析</span><br><span class="line"></span><br><span class="line">2.说明：不是主角，但很重要。</span><br></pre></td></tr></table></figure><h2 id="十-Partner-Nodes-Templates-云端能力"><a href="#十-Partner-Nodes-Templates-云端能力" class="headerlink" title="十 Partner Nodes Templates(云端能力)"></a>十 Partner Nodes Templates(云端能力)</h2><h3 id="10-1-什么是-Partner-Nodes"><a href="#10-1-什么是-Partner-Nodes" class="headerlink" title="10.1 什么是 Partner Nodes"></a>10.1 什么是 Partner Nodes</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">官方合作的云端模型</span><br><span class="line">不完全依赖本地显卡</span><br></pre></td></tr></table></figure><h3 id="10-2-使用注意"><a href="#10-2-使用注意" class="headerlink" title="10.2 使用注意"></a>10.2 使用注意</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常需要 API Key</span><br><span class="line">有调用成本</span><br><span class="line">注意隐私和安全</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文介绍一下内容：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1.Templates 是什么&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2.Templates 的入口与使用方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3.Image Templates 全解析&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4.Video Templates&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 5.Audio Templates&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 6.3D Model Templates&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 7.LLM Templates&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 8.Utility Templates&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 9.Partner Nodes Templates&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="开发" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Q-AI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/"/>
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/categories/%E5%BC%80%E5%8F%91/Q-AI/ComfyUI/"/>
    
    
    <category term="ComfyUI" scheme="https://pgzxc.github.io/tags/ComfyUI/"/>
    
    <category term="Templates" scheme="https://pgzxc.github.io/tags/Templates/"/>
    
  </entry>
  
</feed>
