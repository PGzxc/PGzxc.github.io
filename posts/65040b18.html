<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-64x64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-32x32.png">
  <link rel="mask-icon" href="/images/favicon/favicon-64x64.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inconsolata:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pgzxc.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.2","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"an-old-hope","dark":"an-old-hope"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一 面试题汇总 props和state相同点和不同点 shouldComponentUpdate 应该做什么 redux状态管理的流程 加载bundle的机制 Flex布局">
<meta property="og:type" content="article">
<meta property="og:title" content="React Native面试题——面试题整理7">
<meta property="og:url" content="https://pgzxc.github.io/posts/65040b18.html">
<meta property="og:site_name" content="PGzxc">
<meta property="og:description" content="一 面试题汇总 props和state相同点和不同点 shouldComponentUpdate 应该做什么 redux状态管理的流程 加载bundle的机制 Flex布局">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-rn/rn-interview-md1-redux.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-rn/rn-interview-md1-flex.png">
<meta property="article:published_time" content="2024-03-19T08:54:41.000Z">
<meta property="article:modified_time" content="2025-11-01T01:39:34.185Z">
<meta property="article:author" content="PGzxc">
<meta property="article:tag" content="React Native面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-rn/rn-interview-md1-redux.png">


<link rel="canonical" href="https://pgzxc.github.io/posts/65040b18.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pgzxc.github.io/posts/65040b18.html","path":"posts/65040b18.html","title":"React Native面试题——面试题整理7"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>React Native面试题——面试题整理7 | PGzxc</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.7.0/mermaid.min.js","integrity":"sha256-4+IKDqhZ/sXjc8Wtl2/MsxI4e0s1KpEVdbEP7V/Lz8U="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js" defer></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="PGzxc" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PGzxc</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">纸上得来终觉浅 绝知此事要躬行</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a></li><li class="menu-item menu-item-nav"><a href="/navs/" rel="section"><i class="fa fa-bars fa-fw"></i>导航</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">238</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">4353</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB"><span class="nav-number">1.</span> <span class="nav-text">一 面试题汇总</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94-%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83"><span class="nav-number">2.</span> <span class="nav-text">二 面试题解答(仅供参考)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-props%E5%92%8Cstate%E7%9B%B8%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 props和state相同点和不同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-shouldComponentUpdate-%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 shouldComponentUpdate 应该做什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 redux状态管理的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%8A%A0%E8%BD%BDbundle%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 加载bundle的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Flex%E5%B8%83%E5%B1%80"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 Flex布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%AF%B7%E7%AE%80%E8%BF%B0-code-push-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 请简述 code push 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-Redux%E4%B8%AD%E5%90%8C%E6%AD%A5-action-%E4%B8%8E%E5%BC%82%E6%AD%A5-action-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 Redux中同步 action 与异步 action 最大的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-React-PureComponent%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 React PureComponent的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-JS%E8%B0%83%E7%94%A8%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 JS调用原生方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-%E5%8E%9F%E7%94%9F%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E7%BB%99JS"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 原生发送事件给JS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-immutable-js-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.11.</span> <span class="nav-text">2.11 immutable.js 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-react-native-redux%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-number">2.12.</span> <span class="nav-text">2.12 react native redux中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-InteractionManager"><span class="nav-number">2.13.</span> <span class="nav-text">2.13 InteractionManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-14-Rect-Native-%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88"><span class="nav-number">2.14.</span> <span class="nav-text">2.14 Rect Native 增量更新方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-15-codePush-%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B"><span class="nav-number">2.15.</span> <span class="nav-text">2.15 codePush 接入教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-16-React-Native-%E6%89%93%E5%8C%85%E5%8F%82%E6%95%B0"><span class="nav-number">2.16.</span> <span class="nav-text">2.16 React Native 打包参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">三 参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PGzxc"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">PGzxc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4353</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">238</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">579</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FsdmluX3pob3U=" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;calvin_zhou"><i class="fa fa-book fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cDovL3dlaWJvLmNvbS81NTgyMDM5OTIw" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;5582039920"><i class="fab fa-weibo fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS91L2M1Y2RjYjRkYzUyYg==" title="简书 → http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;c5cdcb4dc52b"><i class="fa fa-heartbeat fa-fw"></i></span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pgzxc.github.io/posts/65040b18.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="PGzxc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PGzxc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="React Native面试题——面试题整理7 | PGzxc">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React Native面试题——面试题整理7<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BHenhjL1BHenhjLmdpdGh1Yi5pby9lZGl0L21hc3Rlci9zb3VyY2UvX3Bvc3RzL1JlYWN0IE5hdGl2ZemdouivlemimOKAlOKAlOmdouivlemimOaVtOeQhjcubWQ=" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-19 16:54:41" itemprop="dateCreated datePublished" datetime="2024-03-19T16:54:41+08:00">2024-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">面试相关</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/React-Native%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">React Native面试题</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一-面试题汇总"><a href="#一-面试题汇总" class="headerlink" title="一 面试题汇总"></a>一 面试题汇总</h2><ol>
<li>props和state相同点和不同点</li>
<li>shouldComponentUpdate 应该做什么</li>
<li>redux状态管理的流程</li>
<li>加载bundle的机制</li>
<li>Flex布局 <span id="more"></span></li>
<li>请简述 code push 的原理</li>
<li>Redux中同步 action 与异步 action 最大的区别是什么</li>
<li>React PureComponent的原理</li>
<li>JS调用原生方法</li>
<li>原生发送事件给JS</li>
<li>immutable.js 的原理</li>
<li>react native redux中间件</li>
<li>InteractionManager</li>
<li>Rect Native 增量更新方案</li>
<li>codePush 接入教程</li>
<li>React Native 打包参数</li>
</ol>
<h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-props和state相同点和不同点"><a href="#2-1-props和state相同点和不同点" class="headerlink" title="2.1 props和state相同点和不同点"></a>2.1 props和state相同点和不同点</h3><p>React Native 中，props 和 state 都是用于存储数据的对象，但它们在来源、可变性和用途上有所不同。</p>
<p>1.相同点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-都是普通的 JavaScript 对象: props 和 state 本质上都是 JavaScript 对象，用于存储数据。</span><br><span class="line">-用于渲染 UI: props 和 state 中的数据都可以用于渲染组件的 UI。</span><br><span class="line">-触发重新渲染: props 或 state 的改变都会触发组件的重新渲染</span><br></pre></td></tr></table></figure>

<p>2.不同点</p>
<table>
<thead>
<tr>
<th align="center">对比项</th>
<th align="center"><code>props</code>（属性）</th>
<th align="center"><code>state</code>（状态）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否可修改</td>
<td align="center"><strong>不可修改</strong>，只能由 <strong>父组件</strong> 传递，组件本身不能更改 <code>props</code></td>
<td align="center"><strong>可修改</strong>，组件内部可以使用 <code>setState</code> 或 <code>useState</code> 更新</td>
</tr>
<tr>
<td align="center">谁来管理</td>
<td align="center"><strong>父组件</strong> 传递给子组件</td>
<td align="center"><strong>组件自身</strong> 维护</td>
</tr>
<tr>
<td align="center">是否可变</td>
<td align="center">不可变（Immutable）</td>
<td align="center">可变（Mutable）</td>
</tr>
<tr>
<td align="center">作用</td>
<td align="center">传递外部数据，组件间通信</td>
<td align="center">管理组件内部的动态数据</td>
</tr>
<tr>
<td align="center">何时使用</td>
<td align="center">组件需要从父组件接收数据</td>
<td align="center">组件内部有需要改变的数据</td>
</tr>
<tr>
<td align="center">是否触发重新渲染</td>
<td align="center"><code>props</code> 变化时，组件会重新渲染</td>
<td align="center"><code>state</code> 变化时，组件会重新渲染</td>
</tr>
</tbody></table>
<p>3-总结</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props 是组件的配置，由父组件传递给子组件，子组件不能修改自己的 props。</span><br><span class="line">state 是组件内部的状态，组件可以自行修改 state，从而更新 UI</span><br><span class="line"></span><br><span class="line">举例:一个显示计数器的组件：</span><br><span class="line">-props 可以用来设置计数器的初始值。</span><br><span class="line">-state 用来存储当前的计数器值，并在点击按钮时更新。</span><br><span class="line"></span><br><span class="line">理解 props 和 state 的区别对于构建可维护和高效的 React Native 应用至关重要。</span><br><span class="line">它们共同作用，使得组件可以根据不同的数据渲染不同的 UI。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-shouldComponentUpdate-应该做什么"><a href="#2-2-shouldComponentUpdate-应该做什么" class="headerlink" title="2.2 shouldComponentUpdate 应该做什么"></a>2.2 shouldComponentUpdate 应该做什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">在React Native中，shouldComponentUpdate()是类组件的生命周期方法，用于控制组件是否需要重新渲染</span><br><span class="line"></span><br><span class="line">1.shouldComponentUpdate() 的作用</span><br><span class="line">-优化性能：通过比较 props 和 state 的变化，决定是否触发重新渲染</span><br><span class="line">-返回值</span><br><span class="line">--返回 true（默认值）：允许组件重新渲染。</span><br><span class="line">--返回 false：阻止组件更新，避免不必要的渲染</span><br><span class="line"></span><br><span class="line">2.语法</span><br><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  // 比较当前的 props/state 和即将变化的 nextProps/nextState</span><br><span class="line">  return this.state.count !== nextState.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.示例</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; Text, Button, View &#125; from &#x27;react-native&#x27;;</span><br><span class="line"></span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; count: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    // 只有 count 改变时才重新渲染</span><br><span class="line">    return this.state.count !== nextState.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = () =&gt; this.setState(&#123; count: this.state.count + 1 &#125;);</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;Rendered!&quot;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;Count: &#123;this.state.count&#125;&lt;/Text&gt;</span><br><span class="line">        &lt;Button title=&quot;Increment&quot; onPress=&#123;this.increment&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.总结</span><br><span class="line">-shouldComponentUpdate() 主要用于性能优化，防止不必要的渲染。</span><br><span class="line">-如果使用函数组件，可以用 React.memo() 和 useMemo() 来替代</span><br></pre></td></tr></table></figure>

<h3 id="2-3-redux状态管理的流程"><a href="#2-3-redux状态管理的流程" class="headerlink" title="2.3 redux状态管理的流程"></a>2.3 redux状态管理的流程</h3><p><img src="https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-rn/rn-interview-md1-redux.png" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">在 React Native 中，Redux 是一种常见的状态管理工具，它的流程可以用以下四个核心步骤来概括：</span><br><span class="line"></span><br><span class="line">1.创建 Store（仓库）：Store 是应用的状态仓库，保存所有的状态数据</span><br><span class="line">import &#123; createStore &#125; from &#x27;redux&#x27;;</span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">2.定义 Reducer（状态管理器）：Reducer 是一个纯函数，根据 Action 的类型来更新状态</span><br><span class="line"></span><br><span class="line">const initialState = &#123; count: 0 &#125;;</span><br><span class="line">const reducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#x27;INCREMENT&#x27;:</span><br><span class="line">      return &#123; count: state.count + 1 &#125;;</span><br><span class="line">    case &#x27;DECREMENT&#x27;:</span><br><span class="line">      return &#123; count: state.count - 1 &#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">3.触发 Action（动作）：Action 是一个普通的 JavaScript 对象，描述“要做什么”。</span><br><span class="line">const incrementAction = &#123; type: &#x27;INCREMENT&#x27; &#125;;</span><br><span class="line">store.dispatch(incrementAction); // 触发 action</span><br><span class="line"></span><br><span class="line">4.订阅更新（UI 绑定）：使用 useSelector() 获取状态，useDispatch() 触发 action</span><br><span class="line"></span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; Text, Button, View &#125; from &#x27;react-native&#x27;;</span><br><span class="line">import &#123; useSelector, useDispatch &#125; from &#x27;react-redux&#x27;;</span><br><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const count = useSelector(state =&gt; state.count);</span><br><span class="line">  const dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Text&gt;Count: &#123;count&#125;&lt;/Text&gt;</span><br><span class="line">      &lt;Button title=&quot;Increment&quot; onPress=&#123;() =&gt; dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125; /&gt;</span><br><span class="line">    &lt;/View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：Redux 的流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Store：保存全局状态。</span><br><span class="line">2.Reducer：定义状态的更新逻辑。</span><br><span class="line">3.Action：描述状态的变化动作。</span><br><span class="line">4.Dispatch：触发 action，通知 reducer 更新状态。</span><br><span class="line">5.Subscribe：组件订阅状态变化，自动更新 UI。</span><br></pre></td></tr></table></figure>

<h3 id="2-4-加载bundle的机制"><a href="#2-4-加载bundle的机制" class="headerlink" title="2.4 加载bundle的机制"></a>2.4 加载bundle的机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">在 React Native 中，bundle 是一个 JavaScript 文件，包含了应用的所有代码和资源。</span><br><span class="line">加载 bundle 的机制决定了如何将应用代码从服务器或本地加载到设备上，并执行应用逻辑。</span><br><span class="line">React Native 的 bundle 加载机制 主要依赖于 打包工具（如 Metro Bundler）以及 本地与远程加载策略</span><br><span class="line"></span><br><span class="line">React Native 加载 Bundle 的机制：</span><br><span class="line"></span><br><span class="line">1.开发模式下的加载（使用 Metro Bundler）</span><br><span class="line">1.1 Metro Bundler：</span><br><span class="line">React Native 使用 Metro Bundler 来打包应用的 JavaScript 代码。</span><br><span class="line">Metro 是一个 JavaScript 打包器，</span><br><span class="line">它将你的 React Native 代码（包括 JS、图片等资源）打包成一个单一的 bundle 文件。</span><br><span class="line"></span><br><span class="line">1.2 加载过程：</span><br><span class="line">-在开发模式下，当你启动一个React Native项目时，应用会向本地开发服务器（Metro Bundler）请求bundle。</span><br><span class="line">-这个请求会加载 JavaScript 代码，并通过 WebSocket 协议与开发服务器进行实时通信，</span><br><span class="line">以实现热更新（Hot Reload）或即时刷新（Live Reload）。</span><br><span class="line">-代码会被逐步加载到设备上并运行。</span><br><span class="line"></span><br><span class="line">1.3 示例：</span><br><span class="line"># 启动 Metro Bundler</span><br><span class="line">npx react-native start</span><br><span class="line"></span><br><span class="line">在开发模式下，React Native 会从 Metro 服务器加载 JS bundle：</span><br><span class="line">// 默认在开发模式下，app 会请求 Metro Bundler 提供的 URL</span><br><span class="line">http://localhost:8081/index.bundle?platform=ios</span><br><span class="line"></span><br><span class="line">2.生产模式下的加载（打包并嵌入到 APK 或 IPA 中）</span><br><span class="line">2.1 过程</span><br><span class="line">-在发布应用时，bundle 会被打包到应用的安装包中（如 APK 或 IPA 文件）。</span><br><span class="line">这个过程是由 React Native CLI 或 Xcode / Android Studio 完成的。</span><br><span class="line">-当应用被安装到设备上并启动时，JS 代码会从本地存储（安装包中）加载，而不再通过开发服务器加载。</span><br><span class="line">-生产模式下，bundle 文件 被压缩、优化，并嵌入到应用内，以提高性能。</span><br><span class="line"></span><br><span class="line">打包命令：</span><br><span class="line">-对于 Android：</span><br><span class="line">npx react-native bundle --platform android --dev false --entry-file index.js </span><br><span class="line">--bundle-output ./android/app/src/main/assets/index.android.bundle</span><br><span class="line"></span><br><span class="line">-对于 iOS：</span><br><span class="line">npx react-native bundle --platform ios --dev false </span><br><span class="line">--entry-file index.js --bundle-output ./ios/main.jsbundle</span><br><span class="line"></span><br><span class="line">在应用启动时，JS bundle 会从本地文件系统加载：</span><br><span class="line">// 生产模式加载本地 bundle 文件</span><br><span class="line">const source = Platform.OS === &#x27;ios&#x27;</span><br><span class="line">  ? require(&#x27;./main.jsbundle&#x27;)</span><br><span class="line">  : &#123; uri: &#x27;file:///android_asset/index.android.bundle&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">3.远程加载（Over-the-Air）</span><br><span class="line"></span><br><span class="line">3.1 远程加载</span><br><span class="line">-为了支持 远程更新（例如，修复 bug 或发布新功能），</span><br><span class="line">React Native 支持通过 Over-the-Air (OTA) 更新 来动态加载 JS bundle。</span><br><span class="line">-远程更新可以通过 CodePush 或 Microsoft App Center 等工具来实现，</span><br><span class="line">允许开发者在应用已发布后直接推送更新，而无需重新提交到 App Store 或 Google Play。</span><br><span class="line"></span><br><span class="line">3.2 远程加载流程：</span><br><span class="line">-当应用启动时，React Native 会检查是否有新的 JS bundle 版本。</span><br><span class="line">如果有，应用会从服务器下载新的 bundle 并替换本地的旧版本。</span><br><span class="line">-这种方式使得应用可以快速获得更新，而无需通过商店发布。</span><br><span class="line"></span><br><span class="line">4.总结</span><br><span class="line">-开发模式：应用从 Metro Bundler 动态加载 bundle，通过 WebSocket 实现热更新。</span><br><span class="line">-生产模式：bundle 被打包到 APK 或 IPA 文件中，应用启动时从本地加载。</span><br><span class="line">-远程更新：使用 OTA 技术（如 CodePush）允许远程加载新的 JS bundle。</span><br><span class="line"></span><br><span class="line">5.关键点</span><br><span class="line">Metro Bundler 负责开发时的打包和加载。</span><br><span class="line">生产环境中，bundle 文件会嵌入到安装包中。</span><br><span class="line">通过 OTA 更新 可以在无需重新发布应用的情况下，直接更新 JS bundle。</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Flex布局"><a href="#2-5-Flex布局" class="headerlink" title="2.5 Flex布局"></a>2.5 Flex布局</h3><p><img src="https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-rn/rn-interview-md1-flex.png" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在 React Native中，布局采用了Flexbox，它与Web的Flexbox布局类似，但有些默认值不同。</span><br><span class="line">Flexbox是一种一维布局模型，可以轻松地控制组件在主轴（Main Axis）和交叉轴（Cross Axis）上的排列方式。</span><br><span class="line"></span><br><span class="line">Flex布局总结：</span><br><span class="line">1.主轴：用flexDirection 控制（row 或 column）。</span><br><span class="line">2.主轴对齐：用justifyContent控制（flex-start、center、flex-end、space-between、space-around）。</span><br><span class="line">3.交叉轴对齐：用alignItems 控制（flex-start、center、flex-end、stretch）。</span><br><span class="line">4.单独子元素对齐：用alignSelf 覆盖父容器的对齐规则。</span><br><span class="line">5.自动填充空间：用 flex 来分配剩余空间。</span><br></pre></td></tr></table></figure>

<h3 id="2-6-请简述-code-push-的原理"><a href="#2-6-请简述-code-push-的原理" class="headerlink" title="2.6 请简述 code push 的原理"></a>2.6 请简述 code push 的原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">Code Push 是微软提供的一种热更新服务，</span><br><span class="line">允许在不经过应用商店审核的情况下，直接推送 JavaScript 代码和资源更新到用户的 React Native 应用。</span><br><span class="line"></span><br><span class="line">2.工作原理</span><br><span class="line">2.1 上传更新：</span><br><span class="line">开发者通过命令行工具（code-push-cli），</span><br><span class="line">将打包好的JS Bundle和资源文件（图片、样式等）上传到Code Push服务器。</span><br><span class="line"></span><br><span class="line">2.2 检测更新：</span><br><span class="line">应用启动时，Code Push SDK 会向服务器请求最新的更新信息，并与本地版本对比。</span><br><span class="line"></span><br><span class="line">2.3 下载更新：</span><br><span class="line">如果有新版本，应用会下载更新的 JS Bundle 和资源文件，并存储在本地设备的沙盒目录。</span><br><span class="line"></span><br><span class="line">2.4 加载更新：</span><br><span class="line">下载完成后，Code Push 会用新的 JS Bundle 替换原来的文件。</span><br><span class="line">通常情况下，更新在下次应用启动时生效，但也可以配置为立即生效。</span><br><span class="line"></span><br><span class="line">2.5 回滚机制</span><br><span class="line">如果新版本存在崩溃等问题，Code Push 支持通过服务器 回滚到旧版本，确保用户体验稳定</span><br><span class="line"></span><br><span class="line">3. 优势</span><br><span class="line">1.无需重新上架：避免应用商店审核流程，快速修复 bug 或发布新功能。</span><br><span class="line">2.动态更新：只更新 JS 和资源，不影响原生代码。</span><br><span class="line">3.支持回滚：更新失败时，可以随时回滚到稳定版本。</span><br><span class="line"></span><br><span class="line">4. 适用场景(注意：若涉及原生代码修改（如新增原生模块），仍需重新打包并上架应用商店)</span><br><span class="line">1.修复紧急 bug。</span><br><span class="line">2.优化页面逻辑或 UI。</span><br><span class="line">3.推送小功能更新。</span><br><span class="line"></span><br><span class="line">5. 总结：</span><br><span class="line">Code Push 通过检测、下载、存储和加载新 Bundle 文件，</span><br><span class="line">实现 React Native 应用的热更新，极大提升了迭代速度！</span><br></pre></td></tr></table></figure>

<h3 id="2-7-Redux中同步-action-与异步-action-最大的区别是什么"><a href="#2-7-Redux中同步-action-与异步-action-最大的区别是什么" class="headerlink" title="2.7 Redux中同步 action 与异步 action 最大的区别是什么"></a>2.7 Redux中同步 action 与异步 action 最大的区别是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.区别</span><br><span class="line">在 Redux 中，同步 action 和 异步 action 的最大区别在于：</span><br><span class="line"></span><br><span class="line">1.1 同步action：</span><br><span class="line">返回一个普通的 对象，描述要执行的操作，交给 reducer 立即更新状态。</span><br><span class="line">const increment = () =&gt; (&#123;</span><br><span class="line">  type: &#x27;INCREMENT&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">1.2 异步 action：</span><br><span class="line">返回一个 函数（需要中间件如 redux-thunk 支持），可以在函数内执行异步操作（如网络请求），</span><br><span class="line">然后在异步操作完成后，手动派发同步 action 来更新状态。</span><br><span class="line">const fetchData = () =&gt; &#123;</span><br><span class="line">  return async (dispatch) =&gt; &#123;</span><br><span class="line">    const data = await fetch(&#x27;https://api.example.com/data&#x27;);</span><br><span class="line">    dispatch(&#123; type: &#x27;FETCH_SUCCESS&#x27;, payload: data &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">2.总结</span><br><span class="line">-同步 action：直接触发 reducer 更新状态，操作立即生效。</span><br><span class="line">-异步 action：先执行异步逻辑，完成后再派发同步 action 来更新状态。</span><br></pre></td></tr></table></figure>

<h3 id="2-8-React-PureComponent的原理"><a href="#2-8-React-PureComponent的原理" class="headerlink" title="2.8 React PureComponent的原理"></a>2.8 React PureComponent的原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.原理</span><br><span class="line">在 React Native 中，React.PureComponent 是一种优化性能的方式。它的原理在于</span><br><span class="line"></span><br><span class="line">1.1 自动浅比较（Shallow Comparison）</span><br><span class="line">-PureComponent 内部会在 shouldComponentUpdate() 方法中，</span><br><span class="line">自动对 props 和 state 进行 浅比较（Shallow Compare）。</span><br><span class="line">-只有当 props 或 state 发生变化时，组件才会重新渲染，避免不必要的渲染，提升性能。</span><br><span class="line"></span><br><span class="line">import React, &#123; PureComponent &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Text &#125; from &#x27;react-native&#x27;;</span><br><span class="line">class MyComponent extends PureComponent &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#x27;Component Rendered&#x27;);</span><br><span class="line">    return &lt;Text&gt;&#123;this.props.message&#125;&lt;/Text&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.对比说明</span><br><span class="line">-普通 Component：每次父组件更新，子组件都会重新渲染。</span><br><span class="line">-PureComponent：只有当 props 或 state 发生变化时才会重新渲染。</span><br><span class="line"></span><br><span class="line">3.注意：</span><br><span class="line">PureComponent 只做浅比较，如果 props 是对象或数组，内容变化但引用不变，不会触发重新渲染！</span><br><span class="line"></span><br><span class="line">4.总结：PureComponent 通过浅比较优化渲染逻辑，减少不必要的渲染次数，提升性能。</span><br></pre></td></tr></table></figure>

<h3 id="2-9-JS调用原生方法"><a href="#2-9-JS调用原生方法" class="headerlink" title="2.9 JS调用原生方法"></a>2.9 JS调用原生方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">在 React Native 中，JS 调用原生方法的方式主要依赖于 原生模块（Native Modules）。</span><br><span class="line">原生模块允许在 JS 代码中调用 Android（Java/Kotlin）或 iOS（Objective-C/Swift）编写的原生功能。</span><br><span class="line"></span><br><span class="line">2.步骤：</span><br><span class="line">2.1 创建原生模块</span><br><span class="line">-在 Android 端，创建一个 Java/Kotlin 类继承 ReactContextBaseJavaModule</span><br><span class="line">-在 iOS 端，创建一个 Objective-C/Swift 类继承 RCTBridgeModule。</span><br><span class="line"></span><br><span class="line">2.2 导出原生方法：</span><br><span class="line">-使用 @ReactMethod（Android）或 RCT_EXPORT_METHOD（iOS）来暴露原生方法给 JS。</span><br><span class="line"></span><br><span class="line">2.3 在 JS 侧调用：使用 NativeModules 导入原生模块，并直接调用方法</span><br><span class="line"></span><br><span class="line">3.示例（Android）</span><br><span class="line">3.1 原生代码（Java）</span><br><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">import com.facebook.react.bridge.ReactApplicationContext;</span><br><span class="line">import com.facebook.react.bridge.ReactContextBaseJavaModule;</span><br><span class="line">import com.facebook.react.bridge.ReactMethod;</span><br><span class="line">import com.facebook.react.bridge.Promise;</span><br><span class="line"></span><br><span class="line">public class MyNativeModule extends ReactContextBaseJavaModule &#123;</span><br><span class="line">    public MyNativeModule(ReactApplicationContext reactContext) &#123;</span><br><span class="line">        super(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;MyNativeModule&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ReactMethod</span><br><span class="line">    public void addNumbers(int a, int b, Promise promise) &#123;</span><br><span class="line">        promise.resolve(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3.2 JS 代码</span><br><span class="line">import &#123; NativeModules &#125; from &#x27;react-native&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; MyNativeModule &#125; = NativeModules;</span><br><span class="line"></span><br><span class="line">MyNativeModule.addNumbers(5, 3)</span><br><span class="line">  .then(result =&gt; console.log(&#x27;Result:&#x27;, result))</span><br><span class="line">  .catch(error =&gt; console.error(error));</span><br><span class="line">  </span><br><span class="line">4. 总结：</span><br><span class="line">-创建原生模块，导出方法给 JS 使用。</span><br><span class="line">-JS 通过 NativeModules 访问原生方法，实现跨平台通信。</span><br><span class="line">-常用于调用设备硬件、系统功能等原生能力。</span><br><span class="line"></span><br><span class="line">一句话总结：React Native 利用原生模块机制，让 JS 代码能调用 Android/iOS 的原生功能！</span><br></pre></td></tr></table></figure>

<h3 id="2-10-原生发送事件给JS"><a href="#2-10-原生发送事件给JS" class="headerlink" title="2.10 原生发送事件给JS"></a>2.10 原生发送事件给JS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">在 React Native 中，原生代码可以通过 事件机制 将数据或通知发送给 JS 层，</span><br><span class="line">常用于监听原生事件（如传感器、网络状态等）。</span><br><span class="line"></span><br><span class="line">2. 步骤</span><br><span class="line">下面简单介绍一下原理和步骤：</span><br><span class="line">2.1 创建事件发送：在 Android 端使用 RCTDeviceEventEmitter，在 iOS 端使用 RCTEventEmitter</span><br><span class="line">2.2 发送事件：在原生代码中定义方法，使用事件发送器将事件抛给 JS。</span><br><span class="line">2.3 JS 层监听事件:使用 DeviceEventEmitter（Android/iOS 通用）来接收事件，并处理数据</span><br><span class="line"></span><br><span class="line">3. 示例（Android）</span><br><span class="line">3.1 原生代码（Java）</span><br><span class="line">import com.facebook.react.bridge.ReactApplicationContext;</span><br><span class="line">import com.facebook.react.modules.core.DeviceEventManagerModule;</span><br><span class="line"></span><br><span class="line">public class MyNativeModule extends ReactContextBaseJavaModule &#123;</span><br><span class="line">    public MyNativeModule(ReactApplicationContext reactContext) &#123;</span><br><span class="line">        super(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;MyNativeModule&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发送事件方法</span><br><span class="line">    private void sendEvent(String eventName, String message) &#123;</span><br><span class="line">        getReactApplicationContext()</span><br><span class="line">            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)</span><br><span class="line">            .emit(eventName, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 示例：触发事件</span><br><span class="line">    @ReactMethod</span><br><span class="line">    public void triggerEvent() &#123;</span><br><span class="line">        sendEvent(&quot;MyCustomEvent&quot;, &quot;Hello from Native!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3.2 JS 代码：</span><br><span class="line">import &#123; DeviceEventEmitter, NativeModules &#125; from &#x27;react-native&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; MyNativeModule &#125; = NativeModules;</span><br><span class="line"></span><br><span class="line">// 监听原生事件</span><br><span class="line">DeviceEventEmitter.addListener(&#x27;MyCustomEvent&#x27;, (message) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Received:&#x27;, message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 触发事件（模拟原生调用）</span><br><span class="line">MyNativeModule.triggerEvent();</span><br><span class="line"></span><br><span class="line">4. 总结</span><br><span class="line">-原生代码通过事件发送器（DeviceEventEmitter）发送事件。</span><br><span class="line">-JS 通过 DeviceEventEmitter.addListener 监听事件，实时接收原生层的信息。</span><br><span class="line">-适用于状态变化监听、传感器数据推送、后台任务等场景。</span><br><span class="line"></span><br><span class="line">一句话总结：原生通过事件机制向 JS 通信，实现双向交互！</span><br></pre></td></tr></table></figure>

<h3 id="2-11-immutable-js-的原理"><a href="#2-11-immutable-js-的原理" class="headerlink" title="2.11 immutable.js 的原理"></a>2.11 immutable.js 的原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">在React Native中，immutable.js 是Facebook推出的一个库，用来创建不可变数据结构，提升性能和代码稳定性。</span><br><span class="line">它的原理主要体现在以下几点</span><br><span class="line"></span><br><span class="line">1.数据不可变性</span><br><span class="line">-immutable.js 创建的数据结构一旦生成，就无法直接修改。</span><br><span class="line">-每次更新都会返回一个新对象，原对象保持不变，从而避免意外修改</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">import &#123; Map &#125; from &#x27;immutable&#x27;;</span><br><span class="line">const data = Map(&#123; count: 0 &#125;);</span><br><span class="line">const newData = data.set(&#x27;count&#x27;, 1);</span><br><span class="line">console.log(data.get(&#x27;count&#x27;)); // 0（原数据没变）</span><br><span class="line">console.log(newData.get(&#x27;count&#x27;)); // 1（返回新数据）</span><br><span class="line"></span><br><span class="line">2.结构共享（Persistent Data Structure）</span><br><span class="line">结构共享：新对象和旧对象会共享未更改的部分，只复制发生变化的部分，减少内存消耗，提升性能。</span><br><span class="line"></span><br><span class="line">3.优化渲染</span><br><span class="line">在React中，immutable.js 可以配合PureComponent使用，</span><br><span class="line">利用浅比较机制（===），快速判断数据是否发生变化，从而避免不必要的渲染。</span><br><span class="line"></span><br><span class="line">if (oldData !== newData) &#123;</span><br><span class="line">  console.log(&#x27;数据变化，触发渲染&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.总结</span><br><span class="line">-不可变性：数据一旦创建不可修改，避免意外更改。</span><br><span class="line">-结构共享：只更新变动部分，提升性能。</span><br><span class="line">-优化渲染：借助浅比较机制，减少不必要的渲染。</span><br><span class="line"></span><br><span class="line">一句话总结：immutable.js 通过不可变性和结构共享机制，让数据管理更安全、高效，特别适合 Redux 的状态管理！</span><br></pre></td></tr></table></figure>


<h3 id="2-12-react-native-redux中间件"><a href="#2-12-react-native-redux中间件" class="headerlink" title="2.12 react native redux中间件"></a>2.12 react native redux中间件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">在 React Native 中，Redux 中间件 是一个在 dispatch 和 reducers 之间的扩展点，</span><br><span class="line">用于处理异步逻辑、日志记录、错误报告等。</span><br><span class="line">常见的 Redux 中间件有 redux-thunk、redux-saga 等。</span><br><span class="line"></span><br><span class="line">2.Redux 中间件的原理</span><br><span class="line">-拦截 action：中间件会拦截 dispatch 的 action，在传递给 reducer 之前执行额外逻辑。</span><br><span class="line">-增强 dispatch：允许 dispatch 不仅接收对象，还能处理函数或 Promise（如异步请求）。</span><br><span class="line">-链式调用：多个中间件可以通过 applyMiddleware 组合，形成中间件链。</span><br><span class="line"></span><br><span class="line">3.常见中间件</span><br><span class="line">3.1 redux-thunk：让 dispatch 支持函数，处理异步操作。</span><br><span class="line">const fetchData = () =&gt; async (dispatch) =&gt; &#123;</span><br><span class="line">  const data = await fetch(&#x27;https://api.example.com/data&#x27;);</span><br><span class="line">  dispatch(&#123; type: &#x27;FETCH_SUCCESS&#x27;, payload: data &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">3.2 redux-saga：使用生成器函数来管理异步逻辑，更清晰地处理副作用</span><br><span class="line">function* fetchDataSaga() &#123;</span><br><span class="line">  const data = yield call(api.fetchData);</span><br><span class="line">  yield put(&#123; type: &#x27;FETCH_SUCCESS&#x27;, payload: data &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 总结</span><br><span class="line">-作用：解耦逻辑、管理异步操作、增强 dispatch 功能。</span><br><span class="line">-原理：拦截 action，执行额外逻辑后再传给 reducer。</span><br><span class="line">-常用：redux-thunk（简单易用），redux-saga（强大但复杂）。</span><br><span class="line"></span><br><span class="line">一句话总结：Redux 中间件通过拦截 action，提供额外的处理能力，解决异步逻辑和代码解耦问题！</span><br></pre></td></tr></table></figure>

<h3 id="2-13-InteractionManager"><a href="#2-13-InteractionManager" class="headerlink" title="2.13 InteractionManager"></a>2.13 InteractionManager</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">在 React Native 中，InteractionManager 是一个用于处理与 UI 渲染相关的交互任务的 API。</span><br><span class="line">它的主要作用是确保某些任务（比如动画、网络请求等）在屏幕渲染完成之后再执行，</span><br><span class="line">从而避免阻塞主线程，提升应用的流畅性。</span><br><span class="line"></span><br><span class="line">2.原理与使用场景</span><br><span class="line">2.1 任务调度：</span><br><span class="line">InteractionManager 允许我们将某些任务延迟到下一个 UI 渲染周期之后执行，</span><br><span class="line">确保这些任务不会阻塞 UI 渲染，避免界面卡顿。</span><br><span class="line"></span><br><span class="line">2.2 常见用途</span><br><span class="line">通常用于在 UI 渲染后执行复杂的计算、动画或 API 请求，确保这些操作不会影响到界面的流畅度。</span><br><span class="line"></span><br><span class="line">3.基本用法</span><br><span class="line">3.1：runAfterInteractions()：</span><br><span class="line">该方法用于将回调函数调度到所有交互操作完成后再执行。</span><br><span class="line">通常用于延迟执行需要在 UI 渲染后完成的任务。</span><br><span class="line"></span><br><span class="line">import &#123; InteractionManager &#125; from &#x27;react-native&#x27;;</span><br><span class="line">// 延迟执行某些操作，直到所有交互动画完成</span><br><span class="line">InteractionManager.runAfterInteractions(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;所有交互完成，可以执行此任务&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">3.2 InteractionManager.runBeforeInteractions()：</span><br><span class="line">这个方法会把回调函数排队到交互和动画之前执行，不过较少使用。</span><br><span class="line"></span><br><span class="line">4.总结</span><br><span class="line">InteractionManager 是 React Native 提供的一种机制，</span><br><span class="line">确保非渲染紧急的任务（如动画、请求等）在 UI 渲染完成后再执行，提升应用的流畅性和响应速度。</span><br><span class="line"></span><br><span class="line">5.一句话总结：InteractionManager 延迟执行非紧急任务，避免阻塞 UI 渲染，提升用户体验！</span><br></pre></td></tr></table></figure>

<h3 id="2-14-Rect-Native-增量更新方案"><a href="#2-14-Rect-Native-增量更新方案" class="headerlink" title="2.14 Rect Native 增量更新方案"></a>2.14 Rect Native 增量更新方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">在 React Native 中，增量更新（Incremental Update）</span><br><span class="line">是指通过将更新内容（如 JS Bundle 或资源文件）分发给用户，而无需重新发布整个应用。</span><br><span class="line">这样可以减少更新包的大小，提高更新速度和用户体验。</span><br><span class="line"></span><br><span class="line">2.常见的增量更新方案</span><br><span class="line">2.1 Code Push</span><br><span class="line">-Code Push：</span><br><span class="line">是微软提供的一个热更新服务，允许开发者无需通过应用商店审核，即可直接推送 JavaScript 代码和资源文件的更新。</span><br><span class="line">它可以实现应用的增量更新，更新内容可以是修复 bug 或添加小功能，而不需要重新发布整个应用。</span><br><span class="line">-通过Code Push，开发者可以将JS Bundle、图片等资源更新推送到用户设备，用户在启动应用时自动下载并应用更新。</span><br><span class="line">-原理：在 JS 代码更新时，只更新代码和资源部分，不影响原生代码，节省流量并加快更新速度。</span><br><span class="line"></span><br><span class="line">import codePush from &quot;react-native-code-push&quot;;</span><br><span class="line">class MyApp extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    codePush.sync(&#123;</span><br><span class="line">      updateDialog: true,</span><br><span class="line">      installMode: codePush.InstallMode.IMMEDIATE</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.2 Hot Module Replacement (HMR)</span><br><span class="line">-HMR 是一种开发模式下的增量更新，允许在不刷新整个应用的情况下，仅重新加载修改过的模块。</span><br><span class="line">它通常用于开发阶段，在开发过程中提供即时反馈。</span><br><span class="line">-在生产环境中不常用，因为它需要较复杂的配置，并且在应用商店审核时无法使用。</span><br><span class="line"></span><br><span class="line">2.3 Dynamic Delivery (通过 Google Play 和 App Store)</span><br><span class="line">-对于 Android 和 iOS，可以通过 Google Play 和 App Store 提供的增量更新机制来实现。</span><br><span class="line">-Google Play提供了App Bundles，可根据用户设备的特性（如架构、语言等）进行增量更新，只下载必要的资源。</span><br><span class="line">-iOS 提供了 App Thinning，可以针对不同的设备和需求只下载需要的部分资源，从而减少应用包的大小。</span><br><span class="line"></span><br><span class="line">3.总结</span><br><span class="line">增量更新方案可以通过 Code Push（热更新）、</span><br><span class="line">HMR（开发模式）以及 平台原生增量更新功能（如 Google Play 和 App Store）来实现。</span><br><span class="line">这些方案能够提高应用更新的速度和效率，尤其在修复 bug 或推出小功能时，减少了用户的等待时间和流量消耗。</span><br><span class="line"></span><br><span class="line">一句话总结：React Native 增量更新通过热更新和平台增量更新机制，帮助开发者快速发布小更新，提高用户体验</span><br></pre></td></tr></table></figure>

<h3 id="2-15-codePush-接入教程"><a href="#2-15-codePush-接入教程" class="headerlink" title="2.15 codePush 接入教程"></a>2.15 codePush 接入教程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">CodePush 是微软提供的一项服务，允许你无需通过应用商店审核就能推送 JavaScript 代码和资源的增量更新。</span><br><span class="line">接入 CodePush 可以帮助 React Native 应用快速发布小的修复或更新，提高用户体验。</span><br><span class="line"></span><br><span class="line">2.React Native CodePush 接入教程</span><br><span class="line">2.1  安装依赖：</span><br><span class="line">-首先，安装 react-native-code-push 包和相应的 CLI 工具</span><br><span class="line">npm install react-native-code-push --save</span><br><span class="line">-如果使用的是 React Native 0.59 或更早的版本，你需要手动链接</span><br><span class="line">react-native link react-native-code-push</span><br><span class="line">-对于 React Native 0.60+，因为使用了自动链接，所以不需要手动链接</span><br><span class="line"></span><br><span class="line">2.2 在应用中配置 CodePush</span><br><span class="line">在你的 React Native 项目的 App.js 文件中，导入 codePush 并将它应用到主组件上。</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Text, View &#125; from &#x27;react-native&#x27;;</span><br><span class="line">import codePush from &#x27;react-native-code-push&#x27;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;Welcome to React Native CodePush!&lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置 CodePush 更新策略</span><br><span class="line">let codePushOptions = &#123;</span><br><span class="line">  checkFrequency: codePush.CheckFrequency.MANUAL, // 手动检查更新</span><br><span class="line">  installMode: codePush.InstallMode.IMMEDIATE // 立即安装更新</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 codePush 包裹 App 组件</span><br><span class="line">export default codePush(codePushOptions)(App);</span><br><span class="line"></span><br><span class="line">2.3 创建 CodePush 账户并获取秘钥</span><br><span class="line">2.3.1 访问 CodePush 网站并创建账户</span><br><span class="line">2.3.2 在创建好账户后，你需要获取 App Key（用于标识应用）：</span><br><span class="line">-登录到 CodePush 后台。</span><br><span class="line">-创建一个新的应用，选择平台（iOS 或 Android）。</span><br><span class="line">-获取该应用的 Deployment Key，用于推送更新</span><br><span class="line"></span><br><span class="line">2.4 配置 Android 和 iOS</span><br><span class="line"></span><br><span class="line">2.4.1 Android：</span><br><span class="line">-在 android/app/build.gradle 文件中配置 CodePush</span><br><span class="line">apply plugin: &#x27;com.microsoft.codepush&#x27;</span><br><span class="line">-并在 defaultConfig 下添加：</span><br><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        // 其他配置</span><br><span class="line">        resValue &quot;string&quot;, &quot;CodePush_deploymentKey&quot;, &quot;&lt;Your Android Deployment Key&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">2.4.2 iOS</span><br><span class="line">打开 ios/&#123;your_project&#125;.xcodeproj，在 Info.plist 文件中添加 CodePush 配置：</span><br><span class="line">&lt;key&gt;CodePushDeploymentKey&lt;/key&gt;</span><br><span class="line">&lt;string&gt;YOUR_IOS_DEPLOYMENT_KEY&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">2.5 发布更新：发布更新是通过 CodePush CLI 实现的。</span><br><span class="line"></span><br><span class="line">2.5.1 安装 CodePush CLI（如果尚未安装）</span><br><span class="line">npm install -g code-push-cli</span><br><span class="line"></span><br><span class="line">2.5.2 登录到 CodePush</span><br><span class="line">code-push login</span><br><span class="line"></span><br><span class="line">2.5.3 发布更新</span><br><span class="line">-在 React Native 项目根目录下生成新的 JavaScript Bundle：</span><br><span class="line">react-native bundle --entry-file index.js --bundle-output </span><br><span class="line">./index.android.bundle --platform android --dev false --minify true</span><br><span class="line"></span><br><span class="line">-然后发布更新：</span><br><span class="line">code-push release-react &lt;Your App Name&gt; android -d Production</span><br><span class="line">其中 -d Production 是指定发布的目标环境，可以是 Staging 或 Production。</span><br><span class="line"></span><br><span class="line">2.6 检查和更新</span><br><span class="line">在应用启动时，你可以选择手动检查更新，或者自动检查更新</span><br><span class="line">// 手动检查更新</span><br><span class="line">codePush.sync(&#123;</span><br><span class="line">  updateDialog: true, // 弹出更新提示框</span><br><span class="line">  installMode: codePush.InstallMode.IMMEDIATE, // 立即安装更新</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">3.总结</span><br><span class="line">通过以上步骤，你可以成功将 CodePush 集成到你的 React Native 项目中，并实现应用的热更新。</span><br><span class="line">这样，你就可以在不经过应用商店审核的情况下，快速发布 JavaScript 代码的更新。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一句话总结：通过 CodePush，你可以为 React Native 应用提供增量更新，实现无缝、快速的更新发布体验</span><br></pre></td></tr></table></figure>

<h3 id="2-16-React-Native-打包参数"><a href="#2-16-React-Native-打包参数" class="headerlink" title="2.16 React Native 打包参数"></a>2.16 React Native 打包参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">1.概念</span><br><span class="line">在 React Native 中，打包是将开发环境中的 JavaScript 代码和资源打包成一个可供设备运行的应用包的过程。</span><br><span class="line">打包过程中，常用的参数用于优化和定制构建结果。以下是 React Native 打包过程中常见的参数及其作用：</span><br><span class="line"></span><br><span class="line">2. Android 打包参数：</span><br><span class="line">在 React Native 项目的根目录，使用 react-native CLI 进行打包时，常用的参数包括：</span><br><span class="line"></span><br><span class="line">2.1 --variant</span><br><span class="line">-用于指定打包的构建类型。</span><br><span class="line">-常见的值有：release（发布版本）、debug（调试版本）。</span><br><span class="line">react-native run-android --variant=release</span><br><span class="line"></span><br><span class="line">2.2 --appId</span><br><span class="line">用于指定 Android 应用的包名</span><br><span class="line">react-native run-android --appId=com.example.myapp</span><br><span class="line"></span><br><span class="line">2.3 --no-packager</span><br><span class="line">跳过启动开发服务器（Metro bundler），适用于已经构建好 JS Bundle 的场景。</span><br><span class="line">react-native run-android --no-packager</span><br><span class="line"></span><br><span class="line">2.4 --debug 和 --release</span><br><span class="line">1.--debug：用于在调试模式下启动应用（包含开发工具和调试功能）</span><br><span class="line">2.--release：用于在发布模式下启动应用，去除调试信息，并进行优化。</span><br><span class="line">react-native run-android --release</span><br><span class="line"></span><br><span class="line">3.iOS 打包参数</span><br><span class="line">使用 react-native CLI 来打包 iOS 应用时，常见的参数有</span><br><span class="line">3.1 --configuration</span><br><span class="line">用于指定打包的构建配置。</span><br><span class="line">常见的值有：Debug（调试模式）、Release（发布模式）。</span><br><span class="line">react-native run-ios --configuration Release</span><br><span class="line"></span><br><span class="line">3.2 --device</span><br><span class="line">用于指定将应用安装到真机设备上，而不是模拟器。</span><br><span class="line">react-native run-ios --device &quot;iPhone 12&quot;</span><br><span class="line"></span><br><span class="line">3.3 --no-packager</span><br><span class="line">跳过启动开发服务器，适用于已经有打包好的 JS 文件的场景。</span><br><span class="line">react-native run-ios --no-packager</span><br><span class="line"></span><br><span class="line">3.4 --scheme</span><br><span class="line">用于指定 Xcode 中的 scheme，常见的值为 Release 或 Debug。</span><br><span class="line">react-native run-ios --scheme Release</span><br><span class="line"></span><br><span class="line">4. 生成 JS Bundle</span><br><span class="line">有时你需要单独打包 JS 文件（JS Bundle），通常使用以下命令</span><br><span class="line"></span><br><span class="line">4.1 Android</span><br><span class="line">react-native bundle --platform android --dev false --entry-file index.js </span><br><span class="line">--bundle-output android/app/src/main/assets/index.android.bundle </span><br><span class="line">--assets-dest android/app/src/main/res</span><br><span class="line"></span><br><span class="line">4.2 iOS</span><br><span class="line">react-native bundle --platform ios --dev false --entry-file index.js </span><br><span class="line">--bundle-output ios/main.jsbundle --assets-dest ios</span><br><span class="line"></span><br><span class="line">--platform：指定平台（android 或 ios）</span><br><span class="line">--dev：是否启用开发模式，false 为生产模式（压缩、去调试信息）。</span><br><span class="line">--entry-file：入口文件，通常为 index.js。</span><br><span class="line">--bundle-output：指定 JS Bundle 输出路径</span><br><span class="line">--assets-dest：指定资源文件（如图片）的输出目录</span><br><span class="line"></span><br><span class="line">5.总结</span><br><span class="line">React Native 打包过程中，有多个参数帮助开发者控制构建类型、目标平台、资源路径等。常见的打包参数包括：</span><br><span class="line">--variant：指定构建类型（如 release）。</span><br><span class="line">--configuration：指定构建配置（如 Debug 或 Release）。</span><br><span class="line">--no-packager：跳过 Metro Bundler。</span><br><span class="line">--dev：指定是否为开发模式或生产模式。</span><br><span class="line">--entry-file：指定入口文件。</span><br><span class="line"></span><br><span class="line">一句话总结：React Native 打包通过多种参数配置，帮助开发者灵活生成适用于不同平台和模式的应用</span><br></pre></td></tr></table></figure>

<h2 id="三-参考"><a href="#三-参考" class="headerlink" title="三 参考"></a>三 参考</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hZjQ1NTA3MWE2Yjg=">简书—React Native面试题总结<i class="fa fa-external-link-alt"></i></span></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/React-Native%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># React Native面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/12033b8e.html" rel="prev" title="React Native面试题——面试题整理6">
                  <i class="fa fa-angle-left"></i> React Native面试题——面试题整理6
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/1ad1b658.html" rel="next" title="标准韩国语第三册——第9课-招待与访问-单词">
                  标准韩国语第三册——第9课-招待与访问-单词 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">PGzxc</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"PGzxc","repo":"PGzxc.github.io","client_id":"4d2d97c55a316dfcea73","client_secret":"f55fe43764e8560484a13850e4a6d84792924fb0","admin_user":"PGzxc","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"341cc76665cfe74f8b3144f0ae576095"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
