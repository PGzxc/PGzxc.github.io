<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-64x64.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-32x32.png">
  <link rel="mask-icon" href="/images/favicon/favicon-64x64.png" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inconsolata:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"pgzxc.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"an-old-hope","dark":"an-old-hope"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一 概述 JVM相关知识 JUC相关知识:并发模型和内存 , 锁，CAS，原子变量, 线程池 ，AQS 注解反射泛型,注解处理器，APT ,KAPT,KSP,KCP,SPI机制 动态代理，Aspect, Javassist, ASM字节码插桩等面向切面编程 基础数据结构和算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Android面试题——掘金-底层基础知识(1)">
<meta property="og:url" content="https://pgzxc.github.io/posts/670fea1a.html">
<meta property="og:site_name" content="PGzxc">
<meta property="og:description" content="一 概述 JVM相关知识 JUC相关知识:并发模型和内存 , 锁，CAS，原子变量, 线程池 ，AQS 注解反射泛型,注解处理器，APT ,KAPT,KSP,KCP,SPI机制 动态代理，Aspect, Javassist, ASM字节码插桩等面向切面编程 基础数据结构和算法">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-02T05:55:43.000Z">
<meta property="article:modified_time" content="2026-02-22T02:43:05.249Z">
<meta property="article:author" content="PGzxc">
<meta property="article:tag" content="Android面试题">
<meta property="article:tag" content="掘金">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://pgzxc.github.io/posts/670fea1a.html">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pgzxc.github.io/posts/670fea1a.html","path":"posts/670fea1a.html","title":"Android面试题——掘金-底层基础知识(1)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android面试题——掘金-底层基础知识(1) | PGzxc</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js" defer></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="PGzxc" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PGzxc</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">纸上得来终觉浅 绝知此事要躬行</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-bell fa-fw"></i>首页</a></li><li class="menu-item menu-item-nav"><a href="/navs/" rel="section"><i class="fa fa-bars fa-fw"></i>导航</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">275</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">4492</span></a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">一 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94-%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83"><span class="nav-number">2.</span> <span class="nav-text">二 面试题解答(仅供参考)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 JVM相关知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88Runtime-Data-Areas%EF%BC%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 运行时数据区（Runtime Data Areas）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 对象的分配策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E5%8F%8A%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 GC（垃圾回收）及调优方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-ART-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E8%B0%83%E4%BC%98"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 ART 虚拟机及调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-ClassLoader%EF%BC%88%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%89"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.5 ClassLoader（类加载器）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6-%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88Bytecode%EF%BC%89"><span class="nav-number">2.1.6.</span> <span class="nav-text">2.1.6 字节码（Bytecode）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-7-JVM-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9"><span class="nav-number">2.1.7.</span> <span class="nav-text">2.1.7 JVM 面试高频考点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-JUC%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%86%85%E5%AD%98-%E9%94%81%EF%BC%8CCAS%EF%BC%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%EF%BC%8CAQS"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 JUC相关知识:并发模型和内存 , 锁，CAS，原子变量, 线程池 ，AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Java-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 Java 并发模型和内存模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 锁（Lock）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-CAS%EF%BC%88Compare-And-Swap%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 CAS（Compare-And-Swap）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%EF%BC%88Atomic%EF%BC%89"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4 原子变量（Atomic）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88ThreadPool%EF%BC%89"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.2.5  线程池（ThreadPool）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-AQS%EF%BC%88AbstractQueuedSynchronizer%EF%BC%89"><span class="nav-number">2.2.6.</span> <span class="nav-text">2.2.6 AQS（AbstractQueuedSynchronizer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-7-JUC-%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9"><span class="nav-number">2.2.7.</span> <span class="nav-text">2.2.7 JUC 面试考点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84%E6%B3%9B%E5%9E%8B-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%8CAPT-KAPT-KSP-KCP-SPI%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 注解反射泛型,注解处理器，APT ,KAPT,KSP,KCP,SPI机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%B3%A8%E8%A7%A3%EF%BC%88Annotations%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 注解（Annotations）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%8F%8D%E5%B0%84%EF%BC%88Reflection%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 反射（Reflection）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E6%B3%9B%E5%9E%8B%EF%BC%88Generics%EF%BC%89"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 泛型（Generics）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-APT%EF%BC%88Annotation-Processing-Tool%EF%BC%89"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 APT（Annotation Processing Tool）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-Kotlin-%E7%9A%84-KAPT%E3%80%81KSP%E3%80%81KCP"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5 Kotlin 的 KAPT、KSP、KCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-SPI%EF%BC%88Service-Provider-Interface%EF%BC%89"><span class="nav-number">2.3.6.</span> <span class="nav-text">2.3.6 SPI（Service Provider Interface）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-7-%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.7.</span> <span class="nav-text">2.3.7 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8CAspect-Javassist-ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9%E7%AD%89%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 动态代理，Aspect, Javassist, ASM字节码插桩等面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Dynamic-Proxy%EF%BC%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 动态代理（Dynamic Proxy）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-Aspect%EF%BC%88AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 Aspect（AOP 面向切面编程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-Javassist%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%EF%BC%89"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3 Javassist（字节码增强）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-ASM%EF%BC%88Java-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BA%A7%E5%88%AB%E6%8F%92%E6%A1%A9%EF%BC%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">2.4.4 ASM（Java 字节码级别插桩）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5-%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.5.</span> <span class="nav-text">2.4.5 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 基础数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 基础数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 常见算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E6%80%BB%E7%BB%93"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3  总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-IO%E6%A8%A1%E5%9E%8B-BaseIO-BIO-NIO-OKIO"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 IO模型,BaseIO,BIO,NIO,OKIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-%E5%9F%BA%E7%A1%80-IO-%E6%A8%A1%E5%9E%8B%EF%BC%88Base-IO%EF%BC%89"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1 基础 IO 模型（Base IO）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-BIO%EF%BC%88%E9%98%BB%E5%A1%9E-I-O%EF%BC%89"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.6.2 BIO（阻塞 I&#x2F;O）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-NIO%EF%BC%88%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O%EF%BC%89"><span class="nav-number">2.6.3.</span> <span class="nav-text">2.6.3 NIO（非阻塞 I&#x2F;O）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-4-AIO%EF%BC%88%E5%BC%82%E6%AD%A5-I-O%EF%BC%89"><span class="nav-number">2.6.4.</span> <span class="nav-text">2.6.4 AIO（异步 I&#x2F;O）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-5-OKIO%EF%BC%88%E9%AB%98%E6%80%A7%E8%83%BD-I-O-%E6%A1%86%E6%9E%B6%EF%BC%89"><span class="nav-number">2.6.5.</span> <span class="nav-text">2.6.5 OKIO（高性能 I&#x2F;O 框架）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-6-%E9%80%89%E6%8B%A9-I-O-%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.6.6.</span> <span class="nav-text">2.6.6 选择 I&#x2F;O 模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-7-%E6%80%BB%E7%BB%93"><span class="nav-number">2.6.7.</span> <span class="nav-text">2.6.7 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%EF%BC%88Http-Https-Http1-0-2-0-3-0-https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%EF%BC%8CTCP-UDP-Socket%E5%8F%8A%E4%B8%8EFD%E5%85%B3%E7%B3%BB"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 理解网络（Http,Https,Http1.0,2.0,3.0,https加密原理，TCP,UDP,Socket及与FD关系)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-HTTP-%E5%9F%BA%E7%A1%80"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.7.1 HTTP 基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-HTTPS-%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.7.2 HTTPS 加密原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-TCP-%E5%92%8C-UDP"><span class="nav-number">2.7.3.</span> <span class="nav-text">2.7.3 TCP 和 UDP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-4-UDP-%E4%BC%A0%E8%BE%93"><span class="nav-number">2.7.4.</span> <span class="nav-text">2.7.4 UDP 传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-5-Socket-%E4%B8%8E-FD%EF%BC%88%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%89"><span class="nav-number">2.7.5.</span> <span class="nav-text">2.7.5 Socket 与 FD（文件描述符）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-6-%E6%80%BB%E7%BB%93"><span class="nav-number">2.7.6.</span> <span class="nav-text">2.7.6 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">三 参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PGzxc"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">PGzxc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4492</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">275</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="http://blog.csdn.net/calvin_zhou" title="CSDN → http:&#x2F;&#x2F;blog.csdn.net&#x2F;calvin_zhou" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/5582039920" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;5582039920" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://www.jianshu.com/u/c5cdcb4dc52b" title="简书 → http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;c5cdcb4dc52b" rel="noopener me" target="_blank"><i class="fa fa-heartbeat fa-fw"></i></a>
      </span>
  </div>


<nav class="sidebar-nav" id="sidebar-nav">
  <ul class="sidebar-nav-menu">
        <li class="menu-item menu-item-home">
          <a href="/zh-CNundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-nav">
          <a href="/zh-CNundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/zh-CNundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/zh-CNundefined" rel="section">
            <span></span>
          </a>
        </li>
        <li class="menu-item menu-item-links">
          <a href="/zh-CNundefined" rel="section">
            <span></span>
          </a>
        </li>
  </ul>
</nav>
        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pgzxc.github.io/posts/670fea1a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="PGzxc">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PGzxc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android面试题——掘金-底层基础知识(1) | PGzxc">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android面试题——掘金-底层基础知识(1)<a href="https://github.com/PGzxc/PGzxc.github.io/edit/master/source/_posts/Android%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E6%8E%98%E9%87%91-%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(1).md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-02 13:55:43" itemprop="dateCreated datePublished" datetime="2025-04-02T13:55:43+08:00">2025-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">面试相关</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/Android%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Android面试题</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><ol>
<li>JVM相关知识</li>
<li>JUC相关知识:并发模型和内存 , 锁，CAS，原子变量, 线程池 ，AQS</li>
<li>注解反射泛型,注解处理器，APT ,KAPT,KSP,KCP,SPI机制</li>
<li>动态代理，Aspect, Javassist, ASM字节码插桩等面向切面编程</li>
<li>基础数据结构和算法<span id="more"></span></li>
<li>IO模型,BaseIO,BIO,NIO,OKIO</li>
<li>理解网络（Http,Https,Http1.0,2.0,3.0,https加密原理，TCP,UDP,Socket及与FD关系)</li>
</ol>
<h2 id="二-面试题解答-仅供参考"><a href="#二-面试题解答-仅供参考" class="headerlink" title="二 面试题解答(仅供参考)"></a>二 面试题解答(仅供参考)</h2><h3 id="2-1-JVM相关知识"><a href="#2-1-JVM相关知识" class="headerlink" title="2.1 JVM相关知识"></a>2.1 JVM相关知识</h3><p>运行时数据区、对象怎么分配、GC及调优方法，ART虚拟机和调优和ClassLoader加载器和字节码</p>
<h4 id="2-1-1-运行时数据区（Runtime-Data-Areas）"><a href="#2-1-1-运行时数据区（Runtime-Data-Areas）" class="headerlink" title="2.1.1 运行时数据区（Runtime Data Areas）"></a>2.1.1 运行时数据区（Runtime Data Areas）</h4><p>JVM 在运行 Java 程序时，会将内存划分为以下几个区域：</p>
<table>
<thead>
<tr>
<th align="center">区域</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">程序计数器(PC 寄存器)</td>
<td align="center">记录当前线程正在执行的字节码指令地址，线程私有</td>
</tr>
<tr>
<td align="center">Java 虚拟机栈(Stack)</td>
<td align="center">线程私有, 存储方法调用时的栈帧(局部变量、操作数栈、方法返回信息等), 方法调用时入栈, 执行完出栈</td>
</tr>
<tr>
<td align="center">本地方法栈(Native Method Stack)</td>
<td align="center">为 Native 方法(JNI)服务，类似于 JVM 栈</td>
</tr>
<tr>
<td align="center">堆(Heap)</td>
<td align="center">线程共享, 存储所有对象实例和数组, 是 GC 主要管理的区域</td>
</tr>
<tr>
<td align="center">方法区(Method Area)</td>
<td align="center">线程共享, 存储类元信息(字段、方法、常量池、静态变量)</td>
</tr>
<tr>
<td align="center">运行时常量池(Runtime Constant Pool)</td>
<td align="center">方法区的一部分，存放类的常量(字面量、符号引用等)</td>
</tr>
</tbody></table>
<h4 id="2-1-2-对象的分配策略"><a href="#2-1-2-对象的分配策略" class="headerlink" title="2.1.2 对象的分配策略"></a>2.1.2 对象的分配策略</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象分配的策略通常依赖于堆的分代模型，常见分配方式有：</span><br><span class="line"></span><br><span class="line">1-优先分配到新生代 Eden 区</span><br><span class="line">对象一般先分配在 Eden 区，Eden 满了触发 Minor GC，将存活对象转移到 Survivor 区。</span><br><span class="line"></span><br><span class="line">2-大对象直接进入老年代</span><br><span class="line">大对象（如大数组）直接进入老年代，避免在 Survivor 区频繁复制。</span><br><span class="line"></span><br><span class="line">3-长期存活的对象进入老年代</span><br><span class="line">当对象在Survivor区经历 一定次数GC（默认15次，MaxTenuringThreshold可调） 后晋升到老年代。</span><br><span class="line"></span><br><span class="line">4-TLAB（Thread Local Allocation Buffer）</span><br><span class="line">为减少多线程分配对象的竞争，每个线程会在 Eden 区预先分配一小块 TLAB 空间，提高对象分配效率</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-GC（垃圾回收）及调优方法"><a href="#2-1-3-GC（垃圾回收）及调优方法" class="headerlink" title="2.1.3 GC（垃圾回收）及调优方法"></a>2.1.3 GC（垃圾回收）及调优方法</h4><p>1-常见 GC 算法</p>
<table>
<thead>
<tr>
<th align="center">GC 算法</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标记-清除（Mark-Sweep）</td>
<td align="center">标记存活对象，清除未标记对象，容易产生碎片</td>
</tr>
<tr>
<td align="center">标记-整理（Mark-Compact）</td>
<td align="center">标记存活对象并整理，消除碎片，适合老年代</td>
</tr>
<tr>
<td align="center">复制（Copying）</td>
<td align="center">新生代常用，将存活对象复制到 Survivor 或老年代，适用于对象存活率低的场景</td>
</tr>
<tr>
<td align="center">分代收集（Generational GC）</td>
<td align="center">结合以上算法，新生代用 Copying，老年代用 Mark-Compact</td>
</tr>
</tbody></table>
<p>2-常见垃圾回收器</p>
<table>
<thead>
<tr>
<th align="center">GC 收集器</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial GC</td>
<td align="center">单线程 GC，适用于小内存</td>
</tr>
<tr>
<td align="center">Parallel GC</td>
<td align="center">多线程 GC，提高吞吐量（默认 GC）</td>
</tr>
<tr>
<td align="center">CMS（Concurrent Mark-Sweep）</td>
<td align="center">低停顿 GC，适用于响应时间要求高的场景</td>
</tr>
<tr>
<td align="center">G1（Garbage First）</td>
<td align="center">低停顿、分区式 GC，适合大内存（推荐）</td>
</tr>
<tr>
<td align="center">ZGC &#x2F; Shenandoah</td>
<td align="center">低停顿时间，适用于超大内存应用</td>
</tr>
</tbody></table>
<p>3-GC 调优参数</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-Xms<code> </code>-Xmx</td>
<td align="center">设置堆的初始大小和最大大小</td>
</tr>
<tr>
<td align="center">-Xmn</td>
<td align="center">设置新生代大小</td>
</tr>
<tr>
<td align="center">-XX:SurvivorRatio</td>
<td align="center">设置 Eden 和 Survivor 比例</td>
</tr>
<tr>
<td align="center">-XX:+UseG1GC</td>
<td align="center">使用 G1 垃圾回收器</td>
</tr>
<tr>
<td align="center">-XX:+UseZGC</td>
<td align="center">使用 ZGC</td>
</tr>
</tbody></table>
<h4 id="2-1-4-ART-虚拟机及调优"><a href="#2-1-4-ART-虚拟机及调优" class="headerlink" title="2.1.4 ART 虚拟机及调优"></a>2.1.4 ART 虚拟机及调优</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1-ART（Android Runtime）是 Android 5.0 之后替代 Dalvik 的虚拟机，主要优化点：</span><br><span class="line"></span><br><span class="line">1.1 AOT（Ahead of Time 编译）：</span><br><span class="line">-ART 采用 AOT 预编译，直接生成机器码，减少运行时开销，提高应用启动速度。</span><br><span class="line"></span><br><span class="line">1.2 优化 GC：</span><br><span class="line">-ART 采用 并发 GC（Concurrent Copying GC），减少 STW（Stop The World）。</span><br><span class="line">-具有 低延迟 GC、增量 GC，适合移动设备。</span><br><span class="line"></span><br><span class="line">1.3 JIT + AOT 结合：</span><br><span class="line">-Android 7.0 引入 JIT（Just-In-Time 编译），动态优化代码，提高运行效率。</span><br><span class="line">-Android 9.0 之后，JIT 编译的热点代码会缓存，提升下次启动速度。</span><br><span class="line"></span><br><span class="line">2 ART 调优方法：</span><br><span class="line">-适当减少 JNI 调用（跨 VM 边界损耗大）。</span><br><span class="line">-避免过多对象创建，减少 GC 触发频率。</span><br><span class="line">-监控 GC 日志 adb logcat -s art，优化 GC 参数</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-ClassLoader（类加载器）"><a href="#2-1-5-ClassLoader（类加载器）" class="headerlink" title="2.1.5 ClassLoader（类加载器）"></a>2.1.5 ClassLoader（类加载器）</h4><p>ClassLoader 负责将 <code>.class</code> 文件加载到 JVM 内存。主要有 3 种 ClassLoader：</p>
<table>
<thead>
<tr>
<th align="center">ClassLoader</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Bootstrap ClassLoader</td>
<td align="center">加载 <code>rt.jar</code>（Java 核心类，如 <code>java.lang.*</code>）</td>
</tr>
<tr>
<td align="center">Extension ClassLoader</td>
<td align="center">加载 <code>ext</code> 目录下的扩展类</td>
</tr>
<tr>
<td align="center">Application ClassLoader</td>
<td align="center">加载 <code>classpath</code> 下的类（应用程序代码）</td>
</tr>
<tr>
<td align="center">自定义 ClassLoader</td>
<td align="center">通过继承 <code>ClassLoader</code> 自定义类加载逻辑</td>
</tr>
</tbody></table>
<p>双亲委派机制（Parent Delegation Model）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载类时，先让 父加载器 处理，只有父加载器找不到时，才由子加载器 加载。</span><br><span class="line">避免了类重复加载，保证了核心类的安全性。</span><br></pre></td></tr></table></figure>

<h4 id="2-1-6-字节码（Bytecode）"><a href="#2-1-6-字节码（Bytecode）" class="headerlink" title="2.1.6 字节码（Bytecode）"></a>2.1.6 字节码（Bytecode）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java 源代码（.java）编译后生成 字节码文件（.class），JVM 通过字节码执行程序。</span><br><span class="line"></span><br><span class="line">1-字节码指令：Java 字节码是一种 基于栈 的指令集，例如：</span><br><span class="line">-iconst_1 → 常量 1 入栈</span><br><span class="line">-iload_0 → 加载局部变量 0</span><br><span class="line">-iadd → 栈顶两个整数相加</span><br><span class="line">-ireturn → 返回整数</span><br><span class="line"></span><br><span class="line">2-查看字节码：可以用 javap -v 反编译字节码</span><br><span class="line">javac Test.java</span><br><span class="line">javap -v Test.class</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-JVM-面试高频考点"><a href="#2-1-7-JVM-面试高频考点" class="headerlink" title="2.1.7 JVM 面试高频考点"></a>2.1.7 JVM 面试高频考点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-运行时数据区：堆、栈、方法区、程序计数器等。</span><br><span class="line">-对象分配：Eden 优先、大对象进老年代、TLAB 分配等。</span><br><span class="line">-GC 及调优：GC 算法（Mark-Sweep、G1、ZGC）、GC 日志分析、参数调优。</span><br><span class="line">-ART 虚拟机：AOT、JIT、GC 机制优化，Android 相关调优。</span><br><span class="line">-ClassLoader：类加载器、双亲委派模型、自定义类加载。</span><br><span class="line">-字节码：Java 字节码指令、javap 反编译工具</span><br></pre></td></tr></table></figure>

<h3 id="2-2-JUC相关知识-并发模型和内存-锁，CAS，原子变量-线程池-，AQS"><a href="#2-2-JUC相关知识-并发模型和内存-锁，CAS，原子变量-线程池-，AQS" class="headerlink" title="2.2 JUC相关知识:并发模型和内存 , 锁，CAS，原子变量, 线程池 ，AQS"></a>2.2 JUC相关知识:并发模型和内存 , 锁，CAS，原子变量, 线程池 ，AQS</h3><h4 id="2-2-1-Java-并发模型和内存模型"><a href="#2-2-1-Java-并发模型和内存模型" class="headerlink" title="2.2.1 Java 并发模型和内存模型"></a>2.2.1 Java 并发模型和内存模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1-Java 并发模型：Java 并发模型基于线程（Thread），通过共享内存进行通信，核心组件</span><br><span class="line">-volatile 关键字：保证可见性和有序性，不能保证原子性。</span><br><span class="line">-synchronized 关键字：保证原子性和可见性，依赖 Monitor Lock。</span><br><span class="line">-Lock API（ReentrantLock、ReadWriteLock）：更灵活的锁机制，支持公平锁、可重入等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2-Java 内存模型（JMM）：JMM规定了多线程如何访问共享变量，核心特性：</span><br><span class="line">-可见性：一个线程修改变量后，其他线程能立即看到（volatile、synchronized 保证）。</span><br><span class="line">-原子性：一个操作不可被中断（synchronized、Atomic 变量保证）。</span><br><span class="line">-有序性：禁止指令重排序（happens-before 规则）。</span><br><span class="line"></span><br><span class="line">3-Happens-Before 规则：</span><br><span class="line">-volatile 变量写入 先于 读取。</span><br><span class="line">-synchronized 代码块执行 先于 退出。</span><br><span class="line">-Thread.start() 先于 线程 run() 方法执行。</span><br><span class="line">-Thread.join() 先于 线程结束。</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-锁（Lock）"><a href="#2-2-2-锁（Lock）" class="headerlink" title="2.2.2 锁（Lock）"></a>2.2.2 锁（Lock）</h4><p>Java 提供了多种锁机制来控制并发访问：</p>
<table>
<thead>
<tr>
<th align="center">锁类型</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁（Biased Locking）</td>
<td align="center">线程偏向某个锁，减少同步开销（无竞争时高效）。</td>
</tr>
<tr>
<td align="center">轻量级锁（Lightweight Locking）</td>
<td align="center">线程 CAS 方式尝试获取锁，适用于 <strong>低竞争</strong> 场景</td>
</tr>
<tr>
<td align="center">重量级锁（Heavyweight Locking）</td>
<td align="center">线程阻塞等待锁，适用于 <strong>高竞争</strong> 场景</td>
</tr>
<tr>
<td align="center">公平锁 &#x2F; 非公平锁</td>
<td align="center">公平锁按 FIFO 顺序获取，非公平锁可插队（默认非公平）。</td>
</tr>
<tr>
<td align="center">可重入锁（ReentrantLock）</td>
<td align="center">允许同一线程多次获取同一把锁（递归调用时不会死锁）</td>
</tr>
<tr>
<td align="center">读写锁（ReadWriteLock）</td>
<td align="center">读线程共享、写线程独占，提高读性能</td>
</tr>
<tr>
<td align="center">自旋锁（SpinLock）</td>
<td align="center">线程不断尝试获取锁，适用于 <strong>短时间竞争</strong> 场景</td>
</tr>
</tbody></table>
<p>2-代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1-ReentrantLock</span><br><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 临界区代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-ReadWriteLock</span><br><span class="line">ReadWriteLock rwLock = new ReentrantReadWriteLock();</span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line">try &#123;</span><br><span class="line">    // 读操作</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    rwLock.readLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-CAS（Compare-And-Swap）"><a href="#2-2-3-CAS（Compare-And-Swap）" class="headerlink" title="2.2.3 CAS（Compare-And-Swap）"></a>2.2.3 CAS（Compare-And-Swap）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1-CAS 是一种 无锁并发 机制，保证变量的 原子性更新，核心步骤：</span><br><span class="line">-读取变量的 当前值（V）。</span><br><span class="line">-比较期望值 E 是否与当前值 V 相等。</span><br><span class="line">-如果相等，则将值更新为新值 N，否则重试。</span><br><span class="line"></span><br><span class="line">2-CAS 存在的问题</span><br><span class="line">-ABA 问题：变量从 A → B → A，CAS 仍然认为未修改（可用 AtomicStampedReference 解决）。</span><br><span class="line">-循环开销大：CAS 自旋消耗 CPU。</span><br><span class="line">-只能保证单个变量原子操作：多变量可用 AtomicReference 解决</span><br><span class="line"></span><br><span class="line">AtomicInteger atomicInteger = new AtomicInteger(0);</span><br><span class="line">atomicInteger.compareAndSet(0, 1);  // 如果当前值是0，则更新为1</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-原子变量（Atomic）"><a href="#2-2-4-原子变量（Atomic）" class="headerlink" title="2.2.4 原子变量（Atomic）"></a>2.2.4 原子变量（Atomic）</h4><p>JUC 提供 <code>java.util.concurrent.atomic</code> 包，支持 <strong>无锁原子操作</strong>。</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本类型</td>
<td align="center">AtomicInteger<code>/</code>AtomicLong<code>/</code>AtomicBoolean</td>
</tr>
<tr>
<td align="center">数组类型</td>
<td align="center">AtomicIntegerArray<code>/</code>AtomicLongArray</td>
</tr>
<tr>
<td align="center">引用类型</td>
<td align="center"><code>AtomicReference</code> &#x2F; <code>AtomicStampedReference</code>（解决 ABA）</td>
</tr>
</tbody></table>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger count = new AtomicInteger(0);</span><br><span class="line">count.incrementAndGet();  // 原子 +1</span><br><span class="line">count.decrementAndGet();  // 原子 -1</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-线程池（ThreadPool）"><a href="#2-2-5-线程池（ThreadPool）" class="headerlink" title="2.2.5  线程池（ThreadPool）"></a>2.2.5  线程池（ThreadPool）</h4><p>1-线程池核心参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br><span class="line">    corePoolSize,     // 核心线程数</span><br><span class="line">    maximumPoolSize,  // 最大线程数</span><br><span class="line">    keepAliveTime,    // 线程空闲回收时间</span><br><span class="line">    TimeUnit.SECONDS, // 时间单位</span><br><span class="line">    workQueue,        // 任务队列</span><br><span class="line">    threadFactory,    // 线程工厂</span><br><span class="line">    handler           // 拒绝策略</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2-线程池的拒绝策略</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AbortPolicy</td>
<td align="center">直接抛异常（默认）</td>
</tr>
<tr>
<td align="center">DiscardPolicy</td>
<td align="center">丢弃新任务，不抛异常</td>
</tr>
<tr>
<td align="center">DiscardOldestPolicy</td>
<td align="center">丢弃最老任务，尝试执行新任务</td>
</tr>
<tr>
<td align="center">CallerRunsPolicy</td>
<td align="center">由提交任务的线程执行任务。</td>
</tr>
</tbody></table>
<p>3-常见线程池</p>
<table>
<thead>
<tr>
<th align="center">线程池</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FixedThreadPool(n)</td>
<td align="center">固定大小线程池，适用于稳定任务量。</td>
</tr>
<tr>
<td align="center">CachedThreadPool()</td>
<td align="center">动态线程池，适用于大量短任务。</td>
</tr>
<tr>
<td align="center">ScheduledThreadPool(n)</td>
<td align="center">定时任务线程池。</td>
</tr>
<tr>
<td align="center">SingleThreadExecutor()</td>
<td align="center">单线程池，适用于串行任务。</td>
</tr>
</tbody></table>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(4);</span><br><span class="line">pool.execute(() -&gt; System.out.println(&quot;任务执行&quot;));</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<h4 id="2-2-6-AQS（AbstractQueuedSynchronizer）"><a href="#2-2-6-AQS（AbstractQueuedSynchronizer）" class="headerlink" title="2.2.6 AQS（AbstractQueuedSynchronizer）"></a>2.2.6 AQS（AbstractQueuedSynchronizer）</h4><p>AQS 是 <strong>锁和同步器的底层框架</strong>，基于 <strong>FIFO 队列 + CAS + 自旋锁</strong> 实现线程同步</p>
<p>1-AQS 两种模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-独占模式（Exclusive）：</span><br><span class="line">-只有一个线程能获取资源（如 ReentrantLock）。</span><br><span class="line"></span><br><span class="line">2-共享模式（Shared）：</span><br><span class="line">-多个线程可共享资源（如 CountDownLatch、Semaphore）</span><br></pre></td></tr></table></figure>

<p>2-AQS 相关类</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ReentrantLock</td>
<td align="center">可重入锁，支持公平 &#x2F; 非公平锁</td>
</tr>
<tr>
<td align="center">CountDownLatch</td>
<td align="center">线程等待多个任务完成。</td>
</tr>
<tr>
<td align="center">Semaphore</td>
<td align="center">控制并发线程数（信号量）</td>
</tr>
<tr>
<td align="center">CyclicBarrier</td>
<td align="center">线程相互等待，类似 <code>CountDownLatch</code></td>
</tr>
</tbody></table>
<p>3-CountDownLatch 示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch = new CountDownLatch(3);</span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;任务完成&quot;);</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;).start();</span><br><span class="line">latch.await();  // 等待所有任务完成</span><br></pre></td></tr></table></figure>

<h4 id="2-2-7-JUC-面试考点"><a href="#2-2-7-JUC-面试考点" class="headerlink" title="2.2.7 JUC 面试考点"></a>2.2.7 JUC 面试考点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-并发模型 &amp; 内存模型（JMM、Happens-Before）</span><br><span class="line">-锁（synchronized、ReentrantLock、ReadWriteLock）</span><br><span class="line">-CAS（无锁并发、ABA 问题）</span><br><span class="line">-原子变量（AtomicInteger、AtomicReference）</span><br><span class="line">-线程池（ThreadPoolExecutor、拒绝策略）</span><br><span class="line">-AQS（ReentrantLock、CountDownLatch、Semaphore）</span><br></pre></td></tr></table></figure>

<h3 id="2-3-注解反射泛型-注解处理器，APT-KAPT-KSP-KCP-SPI机制"><a href="#2-3-注解反射泛型-注解处理器，APT-KAPT-KSP-KCP-SPI机制" class="headerlink" title="2.3 注解反射泛型,注解处理器，APT ,KAPT,KSP,KCP,SPI机制"></a>2.3 注解反射泛型,注解处理器，APT ,KAPT,KSP,KCP,SPI机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 Java 和 Kotlin 开发中，注解（Annotations）、反射（Reflection）、泛型（Generics）、</span><br><span class="line">APT（Annotation Processing Tool）、KAPT（Kotlin APT）、KSP（Kotlin Symbol Processing）、</span><br><span class="line">KCP（Kotlin Compiler Plugin）、SPI（Service Provider Interface） 都是高级技术点，</span><br><span class="line">广泛应用于 框架开发、代码生成、依赖注入（如 Dagger）、JSON 解析（如 Gson/Moshi）、插件开发等。</span><br><span class="line">以下是详细解析</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-注解（Annotations）"><a href="#2-3-1-注解（Annotations）" class="headerlink" title="2.3.1 注解（Annotations）"></a>2.3.1 注解（Annotations）</h4><p>1-注解是一种 <strong>元编程</strong> 机制，主要用于 <strong>标记、配置和代码生成</strong>。Java 的注解分类如下：</p>
<table>
<thead>
<tr>
<th align="center">注解类型</th>
<th align="center">作用</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编译时注解</td>
<td align="center">APT 解析，代码生成</td>
<td align="center">@Override、@Entity</td>
</tr>
<tr>
<td align="center">运行时注解</td>
<td align="center">反射获取注解</td>
<td align="center">@Retention(RUNTIME)</td>
</tr>
<tr>
<td align="center">元注解</td>
<td align="center">定义注解的行为</td>
<td align="center">@Retention、@Target</td>
</tr>
<tr>
<td align="center">文档注解</td>
<td align="center">生成文档</td>
<td align="center">@Deprecated、@Documented</td>
</tr>
</tbody></table>
<p>2-常见元注解</p>
<table>
<thead>
<tr>
<th align="center">元注解</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Retention(RetentionPolicy.RUNTIME)</td>
<td align="center">运行时可用</td>
</tr>
<tr>
<td align="center">@Target(ElementType.FIELD)</td>
<td align="center">作用于字段</td>
</tr>
<tr>
<td align="center">@Inherited</td>
<td align="center">允许子类继承</td>
</tr>
<tr>
<td align="center">@Repeatable</td>
<td align="center">允许重复注解</td>
</tr>
</tbody></table>
<p>3-代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">    String value();</span><br><span class="line">    int count() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-反射（Reflection）"><a href="#2-3-2-反射（Reflection）" class="headerlink" title="2.3.2 反射（Reflection）"></a>2.3.2 反射（Reflection）</h4><p>1-概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">反射用于 运行时动态获取类信息、创建对象、调用方法。适用于：</span><br><span class="line"></span><br><span class="line">-框架开发（Spring、Gson、Retrofit）</span><br><span class="line">-插件系统</span><br><span class="line">-动态代理（JDK Proxy、CGLIB）</span><br></pre></td></tr></table></figure>

<p>2-反射示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;com.example.User&quot;);</span><br><span class="line"></span><br><span class="line">// 创建对象</span><br><span class="line">Object obj = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">// 获取字段</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">field.set(obj, &quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">// 调用方法</span><br><span class="line">Method method = clazz.getMethod(&quot;sayHello&quot;);</span><br><span class="line">method.invoke(obj);</span><br></pre></td></tr></table></figure>

<p>3-反射的缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-性能损耗（通过 MethodHandle 优化）</span><br><span class="line">-安全性问题（破坏封装）</span><br><span class="line">-代码可读性差</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-泛型（Generics）"><a href="#2-3-3-泛型（Generics）" class="headerlink" title="2.3.3 泛型（Generics）"></a>2.3.3 泛型（Generics）</h4><p>1-概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">泛型用于 代码复用和类型安全，主要有：</span><br><span class="line"></span><br><span class="line">-类泛型：class Box&lt;T&gt; &#123; &#125;</span><br><span class="line">-方法泛型：public &lt;T&gt; void print(T value) &#123; &#125;</span><br><span class="line">-泛型通配符：&lt;?&gt;、&lt;? extends T&gt;、&lt;? super T&gt;</span><br></pre></td></tr></table></figure>

<p>2-泛型示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Box&lt;T&gt; &#123;</span><br><span class="line">    private T value;</span><br><span class="line">    public void set(T value) &#123; this.value = value; &#125;</span><br><span class="line">    public T get() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Box&lt;String&gt; box = new Box&lt;&gt;();</span><br><span class="line">box.set(&quot;Hello&quot;);</span><br><span class="line">System.out.println(box.get()); // Hello</span><br></pre></td></tr></table></figure>

<p>3-泛型擦除：Java 泛型采用 <strong>类型擦除（Type Erasure）</strong>，泛型信息在 <strong>编译期检查，运行时擦除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(list1.getClass() == list2.getClass()); // true</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-APT（Annotation-Processing-Tool）"><a href="#2-3-4-APT（Annotation-Processing-Tool）" class="headerlink" title="2.3.4 APT（Annotation Processing Tool）"></a>2.3.4 APT（Annotation Processing Tool）</h4><p>1-概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APT 是 Java 注解处理器，在编译期处理注解，常用于 自动代码生成（如 Dagger、ButterKnife、Room）。</span><br></pre></td></tr></table></figure>

<p>2-APT关键类</p>
<table>
<thead>
<tr>
<th align="center">类&#x2F;接口</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AbstractProcessor</td>
<td align="center">自定义注解处理器</td>
</tr>
<tr>
<td align="center">Messager</td>
<td align="center">日志输出</td>
</tr>
<tr>
<td align="center">Filer</td>
<td align="center">Filer</td>
</tr>
<tr>
<td align="center">Element</td>
<td align="center">解析注解</td>
</tr>
</tbody></table>
<p>3-APT 代码示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class MyProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) &#123;</span><br><span class="line">            System.out.println(&quot;Processing: &quot; + element.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-Kotlin-的-KAPT、KSP、KCP"><a href="#2-3-5-Kotlin-的-KAPT、KSP、KCP" class="headerlink" title="2.3.5 Kotlin 的 KAPT、KSP、KCP"></a>2.3.5 Kotlin 的 KAPT、KSP、KCP</h4><p>1-KAPT（Kotlin Annotation Processing Tool）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KAPT 是 Kotlin 版 APT，让 Kotlin 能使用 Java APT（如 Dagger、Room）。</span><br><span class="line">kapt &#x27;com.google.dagger:dagger-compiler:2.40&#x27;</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">-需要额外生成 Java stubs</span><br><span class="line">-运行较慢</span><br></pre></td></tr></table></figure>

<p>2-KSP（Kotlin Symbol Processing）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">KSP 直接解析 Kotlin 代码，无需生成 Java stubs，比 KAPT 快 2~3 倍。</span><br><span class="line"></span><br><span class="line">id &#x27;com.google.devtools.ksp&#x27;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ksp &#x27;com.squareup.moshi:moshi-kotlin-codegen:1.13.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2-KSP 关键 API</span><br><span class="line">API	                  作用</span><br><span class="line">Resolver	        获取 Kotlin AST 结构</span><br><span class="line">KSClassDeclaration	解析类</span><br><span class="line">KSPLogger	        日志</span><br><span class="line"></span><br><span class="line">3-代码</span><br><span class="line">class MyKspProcessor : SymbolProcessor &#123;</span><br><span class="line">    override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; &#123;</span><br><span class="line">        val symbols = resolver.getSymbolsWithAnnotation(&quot;com.example.MyAnnotation&quot;)</span><br><span class="line">        symbols.forEach &#123; println(it) &#125;</span><br><span class="line">        return emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3-KCP（Kotlin Compiler Plugin）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KCP 允许修改 Kotlin 编译过程，可用于：</span><br><span class="line">-插桩（Transform 代码）</span><br><span class="line">-优化编译</span><br><span class="line">-定制 DSL</span><br><span class="line"></span><br><span class="line">示例：Compose、Kotlin Serialization 就是基于 KCP 的</span><br></pre></td></tr></table></figure>

<h4 id="2-3-6-SPI（Service-Provider-Interface）"><a href="#2-3-6-SPI（Service-Provider-Interface）" class="headerlink" title="2.3.6 SPI（Service Provider Interface）"></a>2.3.6 SPI（Service Provider Interface）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1-概念</span><br><span class="line">SPI 是 Java 的插件机制，用于 动态加载扩展服务，如：</span><br><span class="line">-JDBC Driver</span><br><span class="line">-Dubbo</span><br><span class="line">-SLF4J</span><br><span class="line"></span><br><span class="line">2-SPI 机制</span><br><span class="line"></span><br><span class="line">2.1 定义接口</span><br><span class="line">public interface ILog &#123;</span><br><span class="line">    void log(String msg);</span><br><span class="line">&#125;</span><br><span class="line">2.2 实现接口</span><br><span class="line">public class FileLogger implements ILog &#123;</span><br><span class="line">    public void log(String msg) &#123; System.out.println(&quot;File log: &quot; + msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.3 配置 META-INF/services/com.example.ILog</span><br><span class="line">com.example.FileLogger</span><br><span class="line"></span><br><span class="line">2.4 动态加载</span><br><span class="line">ServiceLoader&lt;ILog&gt; loader = ServiceLoader.load(ILog.class);</span><br><span class="line">for (ILog log : loader) &#123;</span><br><span class="line">    log.log(&quot;Hello SPI&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.5 优点：</span><br><span class="line">-解耦（符合 OCP 原则）</span><br><span class="line">-动态加载（插件化）</span><br><span class="line">-性能优化（延迟加载）</span><br></pre></td></tr></table></figure>

<h4 id="2-3-7-总结"><a href="#2-3-7-总结" class="headerlink" title="2.3.7 总结"></a>2.3.7 总结</h4><table>
<thead>
<tr>
<th align="center">概念</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">注解（Annotations）</td>
<td align="center">标记、配置、代码生成</td>
</tr>
<tr>
<td align="center">反射（Reflection）</td>
<td align="center">运行时获取类信息</td>
</tr>
<tr>
<td align="center">泛型（Generics）</td>
<td align="center">类型安全、代码复用</td>
</tr>
<tr>
<td align="center">APT</td>
<td align="center">Java 注解处理器（编译时代码生成）</td>
</tr>
<tr>
<td align="center">KAPT</td>
<td align="center">Kotlin 版 APT（较慢）</td>
</tr>
<tr>
<td align="center">KSP</td>
<td align="center">Kotlin 版 Symbol Processing（更快）</td>
</tr>
<tr>
<td align="center">KCP</td>
<td align="center">Kotlin 编译插件（可修改编译过程）</td>
</tr>
<tr>
<td align="center">SPI</td>
<td align="center">Java 插件机制（动态扩展）</td>
</tr>
</tbody></table>
<h3 id="2-4-动态代理，Aspect-Javassist-ASM字节码插桩等面向切面编程"><a href="#2-4-动态代理，Aspect-Javassist-ASM字节码插桩等面向切面编程" class="headerlink" title="2.4 动态代理，Aspect, Javassist, ASM字节码插桩等面向切面编程"></a>2.4 动态代理，Aspect, Javassist, ASM字节码插桩等面向切面编程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面试中，动态代理（Dynamic Proxy）、AOP（Aspect-Oriented Programming）、</span><br><span class="line">Javassist、ASM 字节码插桩 是高级 Java 技术，主要用于 日志、权限校验、事务管理、性能监控、框架扩展等。</span><br><span class="line">以下是详细解析：</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-动态代理（Dynamic-Proxy）"><a href="#2-4-1-动态代理（Dynamic-Proxy）" class="headerlink" title="2.4.1 动态代理（Dynamic Proxy）"></a>2.4.1 动态代理（Dynamic Proxy）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">动态代理是一种 运行时创建代理对象 的技术，不需要手动编写代理类，主要分为：</span><br><span class="line">-JDK 动态代理（基于接口）</span><br><span class="line">-CGLIB 动态代理（基于子类）</span><br><span class="line">-Javassist、ByteBuddy（基于字节码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.1 JDK 动态代理</span><br><span class="line">-只能代理 实现了接口的类（基于 java.lang.reflect.Proxy）。</span><br><span class="line">-通过 InvocationHandler 处理方法调用。</span><br><span class="line"></span><br><span class="line">JDK 动态代理的优缺点</span><br><span class="line">优点：</span><br><span class="line">-无需手动编写代理类</span><br><span class="line">-适用于面向接口编程</span><br><span class="line"> </span><br><span class="line">缺点：</span><br><span class="line">只能代理 实现接口的类（不能代理普通类）</span><br><span class="line"></span><br><span class="line">1.2 CGLIB 动态代理</span><br><span class="line">-基于 继承 生成子类代理（适用于没有接口的类）。</span><br><span class="line">-依赖 Enhancer 和 MethodInterceptor。</span><br><span class="line"></span><br><span class="line">优点：不需要接口，也能代理普通类 </span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">-需要额外的 CGLIB 依赖</span><br><span class="line">-不能代理 final 方法</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-Aspect（AOP-面向切面编程）"><a href="#2-4-2-Aspect（AOP-面向切面编程）" class="headerlink" title="2.4.2 Aspect（AOP 面向切面编程）"></a>2.4.2 Aspect（AOP 面向切面编程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AOP 主要用于 日志、事务、权限控制，基于 动态代理 实现，核心概念：</span><br><span class="line"></span><br><span class="line">-切面（Aspect）：增强代码（如日志、权限）。</span><br><span class="line">-切点（Pointcut）：在哪些方法上生效（表达式匹配）。</span><br><span class="line">-通知（Advice）：</span><br><span class="line"> -@Before 方法执行前增强</span><br><span class="line"> -@After 方法执行后增强</span><br><span class="line"> -@Around 环绕增强</span><br><span class="line"> -@AfterReturning 成功返回后增强</span><br><span class="line"> -@AfterThrowing 抛异常后增强</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-Javassist（字节码增强）"><a href="#2-4-3-Javassist（字节码增强）" class="headerlink" title="2.4.3 Javassist（字节码增强）"></a>2.4.3 Javassist（字节码增强）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Javassist 直接 修改字节码，适用于：</span><br><span class="line">-动态代理</span><br><span class="line">-插桩（Instrumentation）</span><br><span class="line">-字节码生成</span><br></pre></td></tr></table></figure>

<h4 id="2-4-4-ASM（Java-字节码级别插桩）"><a href="#2-4-4-ASM（Java-字节码级别插桩）" class="headerlink" title="2.4.4 ASM（Java 字节码级别插桩）"></a>2.4.4 ASM（Java 字节码级别插桩）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASM 是 比 Javassist 更底层 的字节码操作库，直接 解析、修改、生成 class 文件。</span><br></pre></td></tr></table></figure>

<h4 id="2-4-5-总结"><a href="#2-4-5-总结" class="headerlink" title="2.4.5 总结"></a>2.4.5 总结</h4><table>
<thead>
<tr>
<th align="center">技术</th>
<th align="center">作用</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK 动态代理</td>
<td align="center">基于接口代理</td>
<td align="center">Spring AOP、RPC</td>
</tr>
<tr>
<td align="center">CGLIB 代理</td>
<td align="center">继承方式代理</td>
<td align="center">代理普通类</td>
</tr>
<tr>
<td align="center">Aspect（AOP）</td>
<td align="center">面向切面编程</td>
<td align="center">事务、日志、权限</td>
</tr>
<tr>
<td align="center">Javassist</td>
<td align="center">高级字节码操作</td>
<td align="center">框架开发、热更新</td>
</tr>
<tr>
<td align="center">ASM</td>
<td align="center">低级字节码操作</td>
<td align="center">插桩、类修改</td>
</tr>
</tbody></table>
<h3 id="2-5-基础数据结构和算法"><a href="#2-5-基础数据结构和算法" class="headerlink" title="2.5 基础数据结构和算法"></a>2.5 基础数据结构和算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据结构和算法是编程的基石，在面试中经常涉及 数组、链表、栈、队列、哈希表、树、图 等数据结构，</span><br><span class="line">以及 排序、查找、动态规划、回溯、贪心、分治、位运算 等算法。</span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-基础数据结构"><a href="#2-5-1-基础数据结构" class="headerlink" title="2.5.1 基础数据结构"></a>2.5.1 基础数据结构</h4><p>1-数组（Array）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">特点：连续内存，随机访问 O(1)，插入删除 O(n)</span><br><span class="line">应用：</span><br><span class="line">-缓存（CPU Cache）</span><br><span class="line">-二维表（如棋盘、地图）</span><br><span class="line">-双指针、滑动窗口算法</span><br><span class="line"></span><br><span class="line">常见考题：</span><br><span class="line">-双指针：两数之和、三数之和、盛水最多的容器</span><br><span class="line">-滑动窗口：最长无重复子串</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">// 滑动窗口：最长无重复子串（LeetCode 3）</span><br><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    int[] chars = new int[128]; </span><br><span class="line">    int left = 0, right = 0, max = 0;</span><br><span class="line">    while (right &lt; s.length()) &#123;</span><br><span class="line">        chars[s.charAt(right)]++;</span><br><span class="line">        while (chars[s.charAt(right)] &gt; 1) chars[s.charAt(left++)]--;</span><br><span class="line">        max = Math.max(max, right - left + 1);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2-链表（Linked List）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">特点：动态分配，插入删除 O(1)，访问 O(n)</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">-单链表（单向指针）</span><br><span class="line">-双向链表（前后指针）</span><br><span class="line">-环形链表（可用于循环任务调度）</span><br><span class="line"></span><br><span class="line">常见考题：</span><br><span class="line">-反转链表（LeetCode 206）</span><br><span class="line">-检测环（快慢指针）</span><br><span class="line">-合并两个有序链表</span><br><span class="line">-LRU 缓存</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">// 反转链表（LeetCode 206）</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode prev = null, cur = head;</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3-栈（Stack）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">特点：LIFO（Last In First Out）</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">-括号匹配</span><br><span class="line">-表达式求值</span><br><span class="line">-深度优先搜索（DFS）</span><br><span class="line"></span><br><span class="line">常见考题：</span><br><span class="line">-有效括号（LeetCode 20）</span><br><span class="line">-逆波兰表达式计算</span><br><span class="line">-单调栈（最大矩形、柱状图中最大矩形）</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">// 有效括号（LeetCode 20）</span><br><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    for (char c : s.toCharArray()) &#123;</span><br><span class="line">        if (c == &#x27;(&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;[&#x27;) stack.push(c);</span><br><span class="line">        else if (stack.isEmpty() || Math.abs(c - stack.pop()) &gt; 2) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4-队列 &amp; 双端队列（Queue &amp; Deque）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">-队列（FIFO）：先进先出</span><br><span class="line">-双端队列（Deque）：两端操作 O(1)</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line">-BFS（广度优先搜索）</span><br><span class="line">-滑动窗口最大值</span><br><span class="line">-任务调度</span><br><span class="line"></span><br><span class="line">常见考题：</span><br><span class="line">-滑动窗口最大值（单调队列）</span><br><span class="line">-最短路径（BFS）</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">// 滑动窗口最大值（LeetCode 239）</span><br><span class="line">public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">    int[] res = new int[nums.length - k + 1];</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (!deque.isEmpty() &amp;&amp; deque.peekFirst() == i - k) deque.pollFirst();</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) deque.pollLast();</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">        if (i &gt;= k - 1) res[i - k + 1] = nums[deque.peekFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-常见算法"><a href="#2-5-2-常见算法" class="headerlink" title="2.5.2 常见算法"></a>2.5.2 常见算法</h4><p>1-常见算法</p>
<table>
<thead>
<tr>
<th align="center">排序</th>
<th align="center">时间复杂度</th>
<th align="center">额外空间</th>
<th align="center">是否稳定</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
<td align="center">✅</td>
<td align="center">小数据量</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
<td align="center">❌</td>
<td align="center">小数据量</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
<td align="center">✅</td>
<td align="center">基本有序</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(n log n)</td>
<td align="center">O(n)</td>
<td align="center">✅</td>
<td align="center">大规模排序</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(n log n)</td>
<td align="center">O(n log n)</td>
<td align="center">❌</td>
<td align="center">高效排序</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(n log n)</td>
<td align="center">O(1)</td>
<td align="center">❌</td>
<td align="center">优先级队列</td>
</tr>
</tbody></table>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">public void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right) return;</span><br><span class="line">    int pivot = partition(nums, left, right);</span><br><span class="line">    quickSort(nums, left, pivot - 1);</span><br><span class="line">    quickSort(nums, pivot + 1, right);</span><br><span class="line">&#125;</span><br><span class="line">private int partition(int[] nums, int left, int right) &#123;</span><br><span class="line">    int pivot = nums[right], i = left;</span><br><span class="line">    for (int j = left; j &lt; right; j++) &#123;</span><br><span class="line">        if (nums[j] &lt; pivot) swap(nums, i++, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, right);</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">private void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2-搜索算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1-算法</span><br><span class="line">DFS（深度优先搜索）</span><br><span class="line">BFS（广度优先搜索）</span><br><span class="line">二分查找</span><br><span class="line"></span><br><span class="line">2-示例</span><br><span class="line">// 二分查找</span><br><span class="line">public int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = nums.length - 1;</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target) return mid;</span><br><span class="line">        else if (nums[mid] &lt; target) left = mid + 1;</span><br><span class="line">        else right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3-动态规划（DP）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-Fibonacci（记忆化搜索）</span><br><span class="line">-背包问题</span><br><span class="line">-最长递增子序列</span><br><span class="line">-最长公共子序列</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">// 动态规划：爬楼梯（LeetCode 70）</span><br><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    if (n &lt;= 2) return n;</span><br><span class="line">    int a = 1, b = 2;</span><br><span class="line">    for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">        int temp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-总结"><a href="#2-5-3-总结" class="headerlink" title="2.5.3  总结"></a>2.5.3  总结</h4><table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">重点考点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数组</td>
<td align="center">双指针、滑动窗口</td>
</tr>
<tr>
<td align="center">链表</td>
<td align="center">反转、快慢指针</td>
</tr>
<tr>
<td align="center">栈</td>
<td align="center">括号匹配、单调栈</td>
</tr>
<tr>
<td align="center">队列</td>
<td align="center">BFS、滑动窗口</td>
</tr>
<tr>
<td align="center">排序</td>
<td align="center">快排、归并</td>
</tr>
<tr>
<td align="center">搜索</td>
<td align="center">二分查找、DFS、BFS</td>
</tr>
<tr>
<td align="center">DP</td>
<td align="center">背包问题、子序列</td>
</tr>
</tbody></table>
<h3 id="2-6-IO模型-BaseIO-BIO-NIO-OKIO"><a href="#2-6-IO模型-BaseIO-BIO-NIO-OKIO" class="headerlink" title="2.6 IO模型,BaseIO,BIO,NIO,OKIO"></a>2.6 IO模型,BaseIO,BIO,NIO,OKIO</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 Java 和计算机网络编程中，I/O（Input/Output）模型是至关重要的，</span><br><span class="line">特别是在高并发服务器开发中，了解不同的 I/O 模型能够帮助优化性能。</span><br><span class="line">主要涉及 Base IO（基础 IO）、BIO（阻塞 IO）、NIO（非阻塞 IO）、OKIO（现代 IO 框架）。</span><br></pre></td></tr></table></figure>

<h4 id="2-6-1-基础-IO-模型（Base-IO）"><a href="#2-6-1-基础-IO-模型（Base-IO）" class="headerlink" title="2.6.1 基础 IO 模型（Base IO）"></a>2.6.1 基础 IO 模型（Base IO）</h4><p><strong>I&#x2F;O 的本质</strong> 是 <strong>CPU 处理数据和设备交互的方式</strong>，主要有以下模型：</p>
<table>
<thead>
<tr>
<th align="center">I&#x2F;O 模型</th>
<th align="center">描述</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">阻塞 I&#x2F;O（BIO）</td>
<td align="center">线程阻塞等待数据</td>
<td align="center">传统同步服务器</td>
</tr>
<tr>
<td align="center">非阻塞 I&#x2F;O（NIO）</td>
<td align="center">轮询检查数据是否可读</td>
<td align="center">高并发服务器</td>
</tr>
<tr>
<td align="center">多路复用 I&#x2F;O（NIO Selector）</td>
<td align="center">使用 <code>select/poll/epoll</code> 监听多个通道</td>
<td align="center">高性能服务器</td>
</tr>
<tr>
<td align="center">信号驱动 I&#x2F;O</td>
<td align="center">设备准备好数据后通知进程</td>
<td align="center">低延迟场景</td>
</tr>
<tr>
<td align="center">异步 I&#x2F;O（AIO）</td>
<td align="center">设备处理完成数据后通知应用</td>
<td align="center">高吞吐并发</td>
</tr>
</tbody></table>
<h4 id="2-6-2-BIO（阻塞-I-O）"><a href="#2-6-2-BIO（阻塞-I-O）" class="headerlink" title="2.6.2 BIO（阻塞 I&#x2F;O）"></a>2.6.2 BIO（阻塞 I&#x2F;O）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-每个连接占用一个线程，大量连接会导致线程资源耗尽。</span><br><span class="line">-数据读取/写入都是阻塞的，性能较低。</span><br><span class="line">-适用于小规模连接，如早期 Java Web 服务器（Tomcat 传统模式）</span><br><span class="line"></span><br><span class="line">适用于：小型应用（低并发）。</span><br><span class="line">问题：每个连接都占用一个线程，线程资源浪费严重。</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3-NIO（非阻塞-I-O）"><a href="#2-6-3-NIO（非阻塞-I-O）" class="headerlink" title="2.6.3 NIO（非阻塞 I&#x2F;O）"></a>2.6.3 NIO（非阻塞 I&#x2F;O）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-基于 Channel + Buffer（替代 Stream）。</span><br><span class="line">-Selector 多路复用（一个线程管理多个连接）。</span><br><span class="line">-数据读取/写入是非阻塞的（不会阻塞线程）。</span><br><span class="line">-适用于高并发场景，如 Netty、Tomcat NIO</span><br><span class="line"></span><br><span class="line">适用于：高并发场景，如 聊天服务器、HTTP 服务器。</span><br><span class="line">问题：需要手动管理 Selector 和 Buffer，较复杂。</span><br></pre></td></tr></table></figure>

<h4 id="2-6-4-AIO（异步-I-O）"><a href="#2-6-4-AIO（异步-I-O）" class="headerlink" title="2.6.4 AIO（异步 I&#x2F;O）"></a>2.6.4 AIO（异步 I&#x2F;O）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-I/O 操作完全异步（回调处理）。</span><br><span class="line">-适用于超高并发场景，但 Linux 对 AIO 支持有限</span><br><span class="line"></span><br><span class="line">适用于：超高并发，如 消息推送。</span><br><span class="line">问题：回调地狱，维护困难</span><br></pre></td></tr></table></figure>

<h4 id="2-6-5-OKIO（高性能-I-O-框架）"><a href="#2-6-5-OKIO（高性能-I-O-框架）" class="headerlink" title="2.6.5 OKIO（高性能 I&#x2F;O 框架）"></a>2.6.5 OKIO（高性能 I&#x2F;O 框架）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OKIO 是 Square 开发的 I/O 库，更高效、简洁、适合 Android。</span><br><span class="line"></span><br><span class="line">-Buffer 替代 ByteBuffer，更灵活。</span><br><span class="line">-链式操作，更符合流式处理。</span><br><span class="line">-自动管理资源，不易出错</span><br><span class="line"></span><br><span class="line">适用于：高效 I/O 读写（文件、网络）。</span><br><span class="line">问题：Android 依赖性较强，不适合底层网络编程。</span><br></pre></td></tr></table></figure>

<h4 id="2-6-6-选择-I-O-模型"><a href="#2-6-6-选择-I-O-模型" class="headerlink" title="2.6.6 选择 I&#x2F;O 模型"></a>2.6.6 选择 I&#x2F;O 模型</h4><table>
<thead>
<tr>
<th align="center">模型</th>
<th align="center">适用场景</th>
<th align="center">线程占用</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BIO</td>
<td align="center">小型服务器（低并发）</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">NIO</td>
<td align="center">高并发（如 Netty）</td>
<td align="center">低</td>
<td align="center">中中</td>
</tr>
<tr>
<td align="center">AIO</td>
<td align="center">超高并发（推送、聊天）</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">OKIO</td>
<td align="center">文件 I&#x2F;O、Android</td>
<td align="center">低</td>
<td align="center">低</td>
</tr>
</tbody></table>
<h4 id="2-6-7-总结"><a href="#2-6-7-总结" class="headerlink" title="2.6.7 总结"></a>2.6.7 总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-BIO：传统阻塞模式，适用于小规模并发。</span><br><span class="line">-NIO：非阻塞 + Selector，适用于高并发服务器（如 Netty）。</span><br><span class="line">-AIO：异步回调模式，适用于超高并发。</span><br><span class="line">-OKIO：高效 I/O 读写（如 Android）</span><br></pre></td></tr></table></figure>

<h3 id="2-7-理解网络（Http-Https-Http1-0-2-0-3-0-https加密原理，TCP-UDP-Socket及与FD关系"><a href="#2-7-理解网络（Http-Https-Http1-0-2-0-3-0-https加密原理，TCP-UDP-Socket及与FD关系" class="headerlink" title="2.7 理解网络（Http,Https,Http1.0,2.0,3.0,https加密原理，TCP,UDP,Socket及与FD关系)"></a>2.7 理解网络（Http,Https,Http1.0,2.0,3.0,https加密原理，TCP,UDP,Socket及与FD关系)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网络通信是后端开发和分布式系统的基础，涉及 HTTP、HTTPS、TCP、UDP、Socket 等概念，</span><br><span class="line">下面详细解析它们的原理及关键点。</span><br></pre></td></tr></table></figure>

<h4 id="2-7-1-HTTP-基础"><a href="#2-7-1-HTTP-基础" class="headerlink" title="2.7.1 HTTP 基础"></a>2.7.1 HTTP 基础</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HTTP（HyperText Transfer Protocol）是 无状态、基于请求-响应模式 的协议，</span><br><span class="line">常见版本包括 HTTP/1.0、HTTP/1.1、HTTP/2、HTTP/3。</span><br><span class="line"></span><br><span class="line">1.1 HTTP 1.0</span><br><span class="line">-每个请求都建立一次 TCP 连接，响应后关闭连接（无连接复用）。</span><br><span class="line">-无长连接，多次请求性能低下。</span><br><span class="line">-不支持请求流水线（Pipelining）。</span><br><span class="line"></span><br><span class="line">1.2 HTTP 1.1</span><br><span class="line">-默认开启长连接（Keep-Alive），减少握手开销。</span><br><span class="line">-支持管道化请求（Pipelining），多个请求可以复用一个 TCP 连接。</span><br><span class="line">-增加 Host 头部，支持 虚拟主机。</span><br><span class="line"></span><br><span class="line">1.3 HTTP 2.0</span><br><span class="line">-多路复用（Multiplexing）：一个 TCP 连接 上可并行处理多个请求，无需排队等待（消除队头阻塞）。</span><br><span class="line">-二进制帧：数据以二进制帧传输，而非文本格式。</span><br><span class="line">-头部压缩（HPACK 算法）：减少冗余数据传输，提高性能。</span><br><span class="line"></span><br><span class="line">1.4 HTTP 3.0（基于 QUIC）</span><br><span class="line">-基于 UDP，减少 TCP 三次握手 + 慢启动 开销。</span><br><span class="line">-自带 TLS 1.3，提高安全性。</span><br><span class="line">-无队头阻塞（QUIC），连接恢复更快（TCP 断开需要重连，而 QUIC 只需恢复）。</span><br><span class="line">-更快的 HTTP 传输，特别适用于移动网络和高延迟环境。</span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-HTTPS-加密原理"><a href="#2-7-2-HTTPS-加密原理" class="headerlink" title="2.7.2 HTTPS 加密原理"></a>2.7.2 HTTPS 加密原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTPS = HTTP + TLS/SSL，用于加密 HTTP 通信，防止 窃听、中间人攻击。</span><br><span class="line"></span><br><span class="line">HTTPS 加密流程：</span><br><span class="line">-客户端 发送 HTTPS 请求，包含支持的 TLS 版本、加密算法等。</span><br><span class="line">-服务器 发送 SSL 证书（包含公钥）。</span><br><span class="line">-客户端 校验证书，生成 对称密钥（会话密钥）。</span><br><span class="line">-使用公钥加密对称密钥，并发送给服务器。</span><br><span class="line">-服务器使用私钥解密，获得对称密钥，之后通信 使用对称加密 进行数据传输。</span><br><span class="line"></span><br><span class="line">核心加密算法：</span><br><span class="line">-非对称加密（RSA、ECC）：用于 密钥交换。</span><br><span class="line">-对称加密（AES）：用于 数据加密。</span><br><span class="line">-摘要算法（SHA256）：用于 数据完整性校验。</span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-TCP-和-UDP"><a href="#2-7-3-TCP-和-UDP" class="headerlink" title="2.7.3 TCP 和 UDP"></a>2.7.3 TCP 和 UDP</h4><p>1-对比</p>
<table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">连接</th>
<th align="center">可靠性</th>
<th align="center">速度</th>
<th align="center">典型应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">面向连接（三次握手）</td>
<td align="center"><strong>可靠</strong>，有流量控制、丢包重传</td>
<td align="center">慢</td>
<td align="center">HTTP、HTTPS、FTP、SSH</td>
</tr>
<tr>
<td align="center">UDP</td>
<td align="center">无连接（不握手）</td>
<td align="center"><strong>不可靠</strong>，无重传机制</td>
<td align="center">快</td>
<td align="center">DNS、视频直播、VoIP、游戏</td>
</tr>
</tbody></table>
<p>2-TCP 三次握手</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCP 建立连接需要三次握手：</span><br><span class="line">-客户端 → 服务器（SYN）：请求连接。</span><br><span class="line">-服务器 → 客户端（SYN+ACK）：确认连接。</span><br><span class="line">-客户端 → 服务器（ACK）：连接成功。</span><br><span class="line"></span><br><span class="line">⚠ 为什么不是两次握手？ 防止 历史连接 导致服务器误接收数据。</span><br><span class="line">⚠ 为什么不是四次握手？ 三次已经足够保证双方都能确认对方在线。</span><br></pre></td></tr></table></figure>

<p>3-TCP 四次挥手</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCP 断开连接需要四次挥手：</span><br><span class="line">-客户端 → 服务器（FIN）：请求断开。</span><br><span class="line">-服务器 → 客户端（ACK）：确认关闭接收方向。</span><br><span class="line">-服务器 → 客户端（FIN）：请求关闭发送方向。</span><br><span class="line">-客户端 → 服务器（ACK）：确认关闭。</span><br><span class="line"></span><br><span class="line">⚠ 为什么不能三次挥手？ TCP 全双工通信，必须分别关闭 发送和接收 两个方向</span><br></pre></td></tr></table></figure>

<h4 id="2-7-4-UDP-传输"><a href="#2-7-4-UDP-传输" class="headerlink" title="2.7.4 UDP 传输"></a>2.7.4 UDP 传输</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UDP 没有握手和连接维护，直接发送数据，适用于：</span><br><span class="line">-视频直播</span><br><span class="line">-在线游戏</span><br><span class="line">-IoT 设备</span><br></pre></td></tr></table></figure>

<h4 id="2-7-5-Socket-与-FD（文件描述符）"><a href="#2-7-5-Socket-与-FD（文件描述符）" class="headerlink" title="2.7.5 Socket 与 FD（文件描述符）"></a>2.7.5 Socket 与 FD（文件描述符）</h4><p>1-什么是 Socket？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Socket 是进程间通信的桥梁，用于网络数据传输。</span><br><span class="line">每个 Socket 都有一个文件描述符（FD）。</span><br><span class="line">TCP Socket = IP + 端口。</span><br></pre></td></tr></table></figure>

<p>2-FD（文件描述符）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在 Unix/Linux 中，所有的 I/O（文件、网络、设备）都是 文件：</span><br><span class="line"></span><br><span class="line">0：标准输入（stdin）</span><br><span class="line">1：标准输出（stdout）</span><br><span class="line">2：标准错误（stderr）</span><br><span class="line">3+：新打开的文件或网络连接</span><br></pre></td></tr></table></figure>

<p>3-进程如何管理 Socket</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD 用于唯一标识 Socket，存储在 内核文件表 中。</span><br><span class="line">select()、poll()、epoll() 都依赖 FD 进行 I/O 复用</span><br></pre></td></tr></table></figure>

<h4 id="2-7-6-总结"><a href="#2-7-6-总结" class="headerlink" title="2.7.6 总结"></a>2.7.6 总结</h4><table>
<thead>
<tr>
<th align="center">技术</th>
<th align="center">特点</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HTTP 1.0</td>
<td align="center">短连接，性能低</td>
<td align="center">早期 Web</td>
</tr>
<tr>
<td align="center">HTTP 1.1</td>
<td align="center">长连接 + 管道化</td>
<td align="center">普通网站</td>
</tr>
<tr>
<td align="center">HTTP 2.0</td>
<td align="center">多路复用 + 头部压缩</td>
<td align="center">高并发 API</td>
</tr>
<tr>
<td align="center">HTTP 3.0</td>
<td align="center">QUIC（UDP）</td>
<td align="center">移动网络</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">可靠，流量控制</td>
<td align="center">Web、数据库</td>
</tr>
<tr>
<td align="center">UDP</td>
<td align="center">快速，不可靠</td>
<td align="center">游戏、直播</td>
</tr>
<tr>
<td align="center">Socket</td>
<td align="center">进程间通信</td>
<td align="center">网络编程</td>
</tr>
</tbody></table>
<h2 id="三-参考"><a href="#三-参考" class="headerlink" title="三 参考"></a>三 参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7480464724096057381">掘金—知识库的大纲</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># Android面试题</a>
              <a href="/tags/%E6%8E%98%E9%87%91/" rel="tag"># 掘金</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/6f8e1440.html" rel="prev" title="JavaWeb开发思维导图之——Spring之AOP注解开发(96)">
                  <i class="fa fa-angle-left"></i> JavaWeb开发思维导图之——Spring之AOP注解开发(96)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/9086f09d.html" rel="next" title="标日高级下册——第6单元国際交流-第21课歴史的交流-单词1">
                  标日高级下册——第6单元国際交流-第21课歴史的交流-单词1 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">PGzxc</span>
  </div><div class="footer-language">
  <a href="/" data-lang="zh-CN" class="lang-link">中文</a>
  <span class="lang-separator">|</span>
  <a href="/en/" data-lang="en" class="lang-link">English</a>
  <span class="lang-separator">|</span>
  <a href="/ja/" data-lang="ja" class="lang-link">日本語</a>
</div>

<style>
.footer-language {
  text-align: center;
  margin: 10px 0;
}

.lang-link {
  margin: 0 5px;
  padding: 2px 8px;
  text-decoration: none;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.lang-link:hover {
  background-color: #f0f0f0;
}

.lang-link.active {
  background-color: #333;
  color: white;
}

.lang-separator {
  color: #999;
}
</style>

<script>
// 检测当前语言并设置选中状态
function setActiveLanguage() {
  const pathname = window.location.pathname;
  const langLinks = document.querySelectorAll('.lang-link');
  
  langLinks.forEach(link => {
    link.classList.remove('active');
  });
  
  if (pathname.startsWith('/en/')) {
    document.querySelector('[data-lang="en"]').classList.add('active');
  } else if (pathname.startsWith('/ja/')) {
    document.querySelector('[data-lang="ja"]').classList.add('active');
  } else {
    document.querySelector('[data-lang="zh-CN"]').classList.add('active');
  }
}

// 页面加载时设置选中状态
window.addEventListener('load', setActiveLanguage);

// 为语言切换链接添加点击事件处理
const langLinks = document.querySelectorAll('.lang-link');
langLinks.forEach(link => {
  link.addEventListener('click', function(e) {
    const targetLang = this.getAttribute('data-lang');
    const currentPath = window.location.pathname;
    
    // 提取当前路径中除去语言前缀的部分
    let pathWithoutLang = currentPath;
    if (currentPath.startsWith('/en/')) {
      pathWithoutLang = currentPath.substring(3);
    } else if (currentPath.startsWith('/ja/')) {
      pathWithoutLang = currentPath.substring(3);
    }
    
    // 构建目标URL
    let targetUrl = this.getAttribute('href');
    if (pathWithoutLang && pathWithoutLang !== '/') {
      // 如果不是首页，保持路径
      targetUrl = targetUrl + pathWithoutLang.replace(/^\//, '');
    }
    
    // 阻止默认跳转并使用新URL
    e.preventDefault();
    window.location.href = targetUrl;
  });
});
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"PGzxc","repo":"PGzxc.github.io","client_id":"4d2d97c55a316dfcea73","client_secret":"f55fe43764e8560484a13850e4a6d84792924fb0","admin_user":"PGzxc","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"b6d5ca59ad06a374ab0caa11a91c82a3"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
