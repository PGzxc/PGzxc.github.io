---
title: CPP学习之——按址传递对象(9.11)
categories:
  - 开发
  - A-基础语言
  - C++
tags:
  - 引用
abbrlink: 111aa8cf
date: 2019-11-16 22:51:02
---
## 一 概述

上一课我们学习了按值传递对象开销大的问题，本节课我们来解决上节课按值传递开销大的问题 

<!--more-->

## 二 解决思路

我们将对象a的地址传递给func函数，就可避免调用复制构造函数

## 三 代码及输出

### 3.1 代码

```
#include<iostream>
using namespace std;
class A 
{
	public:
		A() {cout << "执行构造函数，创建一个对象\n";}
		A(A&) {cout << "执行复制构造函数，创建该对象的副本\n";}
		~A() {cout << "执行析构函数，删除该对象\n";}
};
A func(A *one) 
{
	return *one;
}
int main() {
	A a;
	func(&a);
	return 0;
}
```

### 3.2 输出结果

```
执行构造函数，创建一个对象
执行复制构造函数，创建该对象的副本
执行析构函数，删除该对象
执行析构函数，删除该对象
```

### 3.3 说明

* 我们看到，输出结果中少了一条析构函数执行的信息
* 由于复制构造函数没有执行，因此也不用调用析构函数来删除复制构造函数创建的对象

## 四 扩展

### 4.1 问题
* 那么接下来的问题就是，我们如何让这一个复制构造函数也不执行

###  4.2 思路
* 由于返回的是对象而不是地址，所以这种返回方式是按值返回
* 按值返回的话就会调用复制构造函数

### 4.3 修改过程(func函数)

```
A* func(A *one) 
{
	return one;
}
```

### 4.4 输出结果

```
执行构造函数，创建一个对象
执行析构函数，删除该对象
```

### 4.5 说明

* 由于复制构造函数没有执行，所以也不用调用析构函数删除复制构造函数创建的对象，一举避免了两个函数的调用