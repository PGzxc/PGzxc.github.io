---
title: CPP学习之——数组在内存中的分布(14.11)
categories:
  - 开发
  - A-基础语言
  - C++
tags:
  - 数组
abbrlink: 4fba3cb9
date: 2019-11-28 21:51:44
---
## 一 概述

数组元素就像排好队的士兵，他们在内存中也都是按照编号顺序排放的，比如说我们定义了一个由10个元素组成的整型数组a[10]，那么它们在内存中存放就会如下所示：  
![][1]

<!--more-->

## 二 内存地址

* 从上图中我们可以看出，每个整型元素都占用一个4字节的内存空间，并且是按顺序依次排放的，第一个元素的下标(编号)是从0开始，那么假如我们要给数组中的某个元素赋值，比如说a[8]，编译器会怎么做呢？
* a[8]是第9个元素，编译器自动把偏移量(又叫下标或编号)8与元素的大小(整型为4个字节)相乘，得出结果为32，那么它就从数组开头移动32个字节，并且把值写在移动后的位置内
* 同理，假如你要为a[10]赋值，那么编译器该怎么做呢，我们知道数组元素是从0开始编号的，因此a[10]实际上是不存在的，但是编译器却不管那么多，它照样算出从第一个元素起所要移动的字节数(40)，然后不管该位置放的什么数据它均要写入，这简直就是一场灾难，因为这样的错误常常不会被你所察觉，它很有可能只是修改了一个程序中不常使用数据，而该数据所引发的错误却会让你的程序彻底奔溃

## 三 示例演示及结果输出

### 3.1 代码

```
#include<iostream>
using namespace std;
int main()
{
	int a[2];
	int b[10];
	b[10]=3;
	cout<<"b[10]="<<b[10]<<endl;
	cout<<"a[0]="<<a[0]<<endl;
	return 0;
}
```

### 3.2 输出结果

```
b[10]=3
a[0]=3
```

### 3.3 代码说明

* b[10]与a[0]输出的结果相同，可能的原因是b[10]与a[0]是连续分配的空间，造成的





[1]:https://fastly.jsdelivr.net/gh/PGzxc/CDN@master/blog-image/cpp-chapter-14-memory-allocation.png
