---
title: CPP学习之——虚构造函数和析构函数(13.12)
categories:
  - 基础语言
  - C++
tags:
  - 虚函数
abbrlink: eed8d31f
date: 2019-11-27 21:47:37
---
## 一 概念

一个派生类对象在创建时首先调用基类的构造函数，然后调用该类的构造函数，一般情况下，在使用虚函数的时候，我们都会将派生类对象传递给指向基类的指针，那么假如指向派生类对象的指针删除时会发生什么情况呢？  

<!--more-->

## 二 理论

* 如果析构函数时虚函数，那么将会进行正确的操作，它会先调用派生类的析构函数，由于一般情况下任何类的析构函数会自动调用基类的析构函数，因此析构的整个对象都会被销毁。
* 一般情况下任何类的析构函数都可声明为虚析构函数，当指针被删除时，系统会获得对象运行时的类型并调用正确的析构函数。

## 三 注意事项

但是，我们要注意三点： 

* 一 由于析构函数不允许有参数，因此它不可能实现重载，那么一个类就只能有一个虚析构函数
* 只要基类的析构函数被说明为虚函数，那么派生类的析构函数无论说明与否，都自然成为虚函数
* 在C++中虚构造函数是不存在的，因此也无法声明

## 四 示例演示及结果输出

### 4.1 代码

```
#include<iostream>
using namespace std;
class A
{
	public:
		A(){cout<<"创建A"<<endl;}
		virtual void func(){cout<<"类A"<<endl;}
		virtual ~A(){cout<<"析构A"<<endl;}
};
class B:public A
{
	public:
		B(){cout<<"创建B"<<endl;}
		virtual void func(){cout<<"类B"<<endl;}
		virtual ~B(){cout<<"析构B"<<endl;}
};
int main()
{
	A *p=new B;
	p->func();
	delete p;
	return 0;
}
```

### 4.2 输出结果

```
创建A
创建B
类B
析构B
析构A
```

### 4.3 说明

* 建议做的事：如果基类中定义了虚函数，析构函数也应说明为虚函数。这样对内存的回收更加准确些