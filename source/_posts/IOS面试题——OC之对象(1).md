---
title: IOS面试题——OC之对象(1)
categories:
  - 面试相关
  - IOS面试题
tags:
  - OC面试题
abbrlink: e3138169
date: 2024-03-25 21:36:53
---
## 一 面试题汇总

1. 什么是内存对齐，内存对齐规则是什么样的？
2. 内存对齐计算`(x + (8-1)) & ~(8-1)` 和 `(x + (8-1)) >> 3 << 3`
3. 结构体实际占用内存计算，系统给该结构体开辟空间内存大小计算，他们的区别是什么？
4. class_getInstanceSize , malloc_size, sizeof 区别？
5. instance对象，class对象，mate-class对象的区别与关系? 在内存中各自存储哪些信息<!--more-->
6. `- (Class)class` ，`+ (Class)class`，`object_getClass(id _Nullable obj)` 的区别
7. 怎么判断一个Class对象是否为meta-class？
8. isa指针和superClass指针分别是如何指向的？

## 二 面试题解答(仅供参考)

### 2.1 什么是内存对齐，内存对齐规则是什么样的？

```
内存对齐是指在计算机系统中，数据在内存中存储时按照一定规则对其进行排列的过程。
内存对齐的目的是提高存取数据的效率，
因为许多计算机体系结构要求数据按照一定的边界对齐存储，否则可能导致性能下降甚至出错。

内存对齐规则通常取决于计算机体系结构的硬件特性，常见的规则包括：

1-字节对齐（Byte Alignment）：最基本的内存对齐规则，数据项存储的起始地址必须是其大小的整数倍。
例如，一个字节的数据可以从任意地址开始存储，而一个4字节的整型数据必须从地址为4的倍数开始存储。

2-基本数据类型的对齐规则：不同的基本数据类型可能有不同的对齐要求。
例如，大多数体系结构要求32位整数从4字节对齐开始存储，64位整数从8字节对齐开始存储。

3-结构体对齐（Struct Alignment）：结构体中的每个成员变量根据其大小和类型进行对齐，
通常按照结构体中最大成员的大小对齐。这样可以确保结构体在内存中的连续存储。

4-指针对齐（Pointer Alignment）：指针类型的数据通常需要按照机器字长对齐，以提高访问速度。

在编程中，程序员通常需要了解并遵循内存对齐规则，以确保数据的正确存储和访问，
同时最大程度地提高程序的性能
```

### 2.2 内存对齐计算`(x + (8-1)) & ~(8-1)` 和 `(x + (8-1)) >> 3 << 3`

```
这两个表达式都是用来将一个地址 x 向上舍入到 8 字节的倍数。这在内存对齐中是常见的操作。
```

### 2.3 结构体实际占用内存计算，系统给该结构体开辟空间内存大小计算，他们的区别是什么？

```
1-结构体实际占用内存计算：

1.1-结构体实际占用内存是指结构体中所有成员变量及其填充字节所占用的实际内存大小。
1.2-这通常是通过计算结构体中每个成员变量的大小，然后考虑对齐要求来确定的。
1.3-结构体的实际占用内存大小可能会大于所有成员变量大小之和，
因为编译器会根据对齐要求在成员变量之间插入填充字节，以满足对齐要求。

2-系统给该结构体开辟空间内存大小计算：

2.1-系统给结构体开辟空间内存大小是在程序运行时实际分配给结构体的内存空间大小。
2.2-这个大小通常与结构体的实际占用内存大小相同，但也可能因为系统内存管理的一些因素而略有不同。
2.3在某些情况下，系统可能会在实际分配的内存空间中包含一些额外的元数据或其他控制信息。

总的来说，结构体的实际占用内存大小是根据其成员变量的大小和对齐要求计算出来的，
而系统给结构体开辟空间内存大小是在程序运行时实际分配给结构体的内存大小。
通常情况下，它们是相同的，但也可能略有不同，具体取决于编译器和系统的实现细节
```

### 2.4 class_getInstanceSize , malloc_size, sizeof 区别？

```
1-class_getInstanceSize 用于动态获取 Objective-C 对象实例的大小。
2-malloc_size 用于获取由 malloc 分配的内存块的实际大小。
3-sizeof 在编译时获取类型或表达式的大小。
```

### 2.5 instance对象，class对象，mate-class对象的区别与关系? 在内存中各自存储哪些信息

```
在内存中，这些对象通常被存储在不同的位置：
1-实例对象通常在堆（Heap）中分配内存，每个实例对象都有自己的内存空间。
2-类对象通常在静态存储区（Static Storage Area）中，与程序的代码一起存储。
3-元类对象也通常在静态存储区中，与类对象一起存储，因为它们通常在类被定义时就创建好了。

关系：
1-类对象是实例对象的模板，通过类对象可以创建实例对象。
2-元类对象是类对象的类，它用于控制类对象的创建和行为
```

### 2.6 `- (Class)class` ，`+ (Class)class`，`object_getClass(id _Nullable obj)` 的区别

```
1-- (Class)class：
这是一个实例方法，用于获取对象的类。
在一个实例对象上调用 -class 方法会返回该对象所属的类的 Class 对象。

2-+ (Class)class：
这是一个类方法，通常是用于获取类对象本身的类。
在一个类对象上调用 +class 方法会返回该类对象的类的 Class 对象，通常是元类对象（metaclass）。

3-object_getClass(id _Nullable obj)：

这是一个 C 函数，用于获取给定对象的类。
它接受一个 Objective-C 对象作为参数，返回该对象的类的 Class 对象。
这个函数与前两个方法相似，但是它更通用，可以在任何时候使用，而不依赖于对象是否具有 -class 方法
```

### 2.7 怎么判断一个Class对象是否为meta-class？

```
在 Objective-C 中，你可以通过 class_isMetaClass() 函数来判断一个 Class 对象是否为元类（meta-class）。
这个函数接受一个 Class 对象作为参数，并返回一个布尔值来表示该类是否为元类。

#import <objc/runtime.h>

// 判断一个 Class 对象是否为 meta-class
BOOL isMetaClass = class_isMetaClass([YourClass class]);

if (isMetaClass) {
    NSLog(@"Class is a meta-class.");
} else {
    NSLog(@"Class is not a meta-class.");
}
```

### 2.8 isa指针和superClass指针分别是如何指向的？

```
在 Objective-C 中，每个对象都有一个叫做 isa 指针和一个叫做 superClass 指针。
它们分别指向不同的东西：

1-isa 指针：

isa 指针是一个指向对象所属类的指针。
它是一个隐藏的指针，位于对象的内部，用于标识对象的类型。
当你调用对象的方法时，实际上是通过 isa 指针来查找对应类中的方法实现。
在继承体系中，isa 指针会沿着类的继承链向上移动，直到找到包含请求的方法实现的类。

2-superClass 指针：

superClass 指针是一个指向当前类的父类的指针。它指向继承链中的上一级类。
这个指针使得对象能够访问其父类中的属性和方法。
在继承体系中，superClass 指针沿着类的继承链向上移动，
直到指向顶级的根类 NSObject（或者其它继承自 NSObject 的根类）。

3-这两个指针的关系如下：
isa 指针用于确定一个对象的类，从而找到对应类中的方法实现。
superClass 指针用于在继承链中向上查找方法或属性的实现，以及访问父类的成员。
```

## 三 参考

* [简书—OC之对象](https://www.jianshu.com/p/b4d237dcc252)