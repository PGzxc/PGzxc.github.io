---
title: IOS面试题——SwiftUI面试题(5)
categories:
  - 面试相关
  - IOS面试题
tags:
  - SwiftUI面试题
abbrlink: 3d7cd81d
date: 2024-03-29 11:20:37
---
## 一 面试题汇总

1. 描述 SwiftUI 中的视图
2. 描述 @State、@Binding、@ObservedObject、@Published和@EnvironmentObject 之间的区别
3. 描述 Spacer 组件的作用
4. SwiftUI 如何获知销毁视图？
5. 描述 iOS 14 及更高版本中的 SwiftUI 应用程序生命周期<!--more-->

## 二 面试题解答(仅供参考)

### 2.1 描述 SwiftUI 中的视图

```
SwiftUI 中的视图是构建用户界面的基础单元，具有以下特点：

1-声明式定义
以声明式的方式来定义，你只需描述界面最终的样子，而非具体的绘制步骤。
例如，要显示一段文本，只需创建 Text 视图并设置文本内容，SwiftUI 会自动处理渲染。

2-基于结构体
视图是遵循 View 协议的结构体，包含 body 属性，该属性返回视图的具体内容。
通过结构体的形式，视图具有值语义，更加轻量、易于管理和组合。

3-组合性强
支持将多个简单视图组合成复杂视图。
利用 VStack、HStack、ZStack 等容器视图，能轻松实现不同的布局方式，开发者可以根据需求灵活嵌套和排列视图。

4-响应式更新
视图与数据紧密绑定，当绑定的数据发生变化时，视图会自动更新以反映这些变化。
借助 @State、@Binding 等属性包装器，能方便地管理视图状态和数据流动。

5-丰富的修改器
提供了丰富的视图修改器，可通过链式调用对视图的外观和行为进行修改，如设置字体、颜色、边距等，代码简洁且易于理解。

6-跨平台兼容
可以在 iOS、iPadOS、macOS、watchOS 等多个苹果平台上使用，一套代码即可适配不同设备，保证了界面在各平台上的一致性。
```

### 2.2 描述 @State、@Binding、@ObservedObject、@Published和@EnvironmentObject 之间的区别

```
在 SwiftUI 里，@State、@Binding、@ObservedObject、@Published和@EnvironmentObject都是用于管理和传递数据的属性包装器，
它们各自有不同的使用场景和特点，以下为你详细介绍它们之间的区别。

1-@State
用途：主要用于管理视图的私有、可变状态。当该状态改变时，使用它的视图会重新计算其body属性并更新界面。
作用范围：状态是视图内部的，不能在视图间直接共享。
示例场景：一个按钮的点击次数统计，该数据仅在当前视图中使用。

2-@Binding
用途：提供对另一个数据源（通常是 @State）的引用，实现数据的双向绑定。当绑定的数据发生变化时，会同步更新原始数据源。
作用范围：常用于在父视图和子视图之间传递数据，使得子视图能够修改父视图的数据。
示例场景：在一个设置页面中，子视图可以通过@Binding修改父视图中存储的设置值。

3-@ObservedObject
用途：用于观察一个遵循ObservableObject协议的对象。当该对象的属性发生变化时，使用它的视图会更新。
作用范围：适用于在多个视图间共享复杂的数据模型，视图观察该对象的变化并做出响应。
示例场景：在一个新闻应用中，多个视图可能会观察同一个新闻列表对象，当列表更新时，相关视图会更新显示。

4-@Published
用途：这并非属性包装器，而是用于标记ObservableObject中的属性。
当被标记的属性值改变时，会自动发布一个通知，通知所有观察该对象的视图进行更新。
作用范围：是@ObservedObject机制的一部分，用于触发对象属性变化时的更新操作。
示例场景：在一个待办事项应用中，TodoList对象遵循ObservableObject协议，
其中的todos属性用@Published标记，当todos列表有新增或删除操作时，相关视图会更新。

5-@EnvironmentObject
用途：用于在整个视图层次结构中共享数据。将一个遵循ObservableObject协议的对象注入到环境中，所有子视图都可以直接访问该对象。
作用范围：适合在多个不直接关联的视图间共享全局数据，避免了逐层传递数据的繁琐。
示例场景：在一个应用中，用户的登录状态可以作为@EnvironmentObject在整个应用的视图层次中共享，
各个视图都能根据登录状态显示不同的内容。

综上所述，
@State 用于视图内部状态管理，
@Binding 用于数据双向绑定，
@ObservedObject 用于观察对象变化，
@Published 用于标记可观察对象的属性以触发更新，
@EnvironmentObject 用于在视图层次中全局共享数据。
```

### 2.3 描述 Spacer 组件的作用

```
在SwiftUI里，Spacer组件是一个极为实用的布局工具，它主要用于在视图布局中灵活分配空间，以下是其详细作用描述：

1-填充多余空间
Spacer 能够自动填充容器视图里的多余空间。
当你把Spacer放置于其他视图之间或者容器视图的边缘时，它会尽可能占据剩余空间，从而把其他视图推开。
例如，在一个HStack中，将Spacer放在两个文本视图之间，它会让这两个文本视图分别靠向左右边缘。

2-调整视图间距
借助 Spacer 可以轻松调整视图之间的间距。
你可以在多个视图之间添加Spacer，并且利用minLength参数来设置Spacer的最小长度，以此精确控制视图之间的距离。

3-对齐视图
Spacer 有助于实现视图的对齐。
比如，在VStack中，若要让某个视图靠底部显示，可在该视图上方添加一个Spacer，
这样Spacer会占据上方的多余空间，使目标视图被推到下方。

4-动态布局
由于Spacer会依据容器视图的大小动态调整自身占据的空间，
所以它能让布局在不同设备尺寸和屏幕方向下保持良好的适应性，实现动态且灵活的布局效果。
```

### 2.4 SwiftUI 如何获知销毁视图？

```
在 SwiftUI 中，视图的销毁通常与视图的生命周期相关，SwiftUI 通过以下方式获知销毁视图：

1-视图消失在屏幕外：
当视图从屏幕上移除，例如导航到其他界面，或者视图被覆盖、隐藏，
SwiftUI会感知到视图不再显示在用户界面中，可能会触发视图的销毁。

2-父视图重新计算：
如果父视图的 body 重新计算，并且不再包含对某个子视图的引用，那么 SwiftUI 会认为该子视图不再需要，进而销毁它。
例如，当条件判断导致某个子视图不再被包含在父视图的返回结果中。

3-相关数据绑定失效：
当视图所依赖的 @State、@Binding 或 @ObservedObject 等数据发生变化，
导致视图的显示条件不满足，SwiftUI可能会销毁该视图。
比如，一个基于布尔值显示的视图，当布尔值变为 false 时，视图可能会被销毁。

需要注意的是，SwiftUI 的视图销毁机制是自动管理的，
开发者通常不需要手动去处理视图的销毁操作，框架会根据各种条件和状态来决定何时销毁视图，以优化资源利用和界面性能。

```
### 2.5 描述 iOS 14 及更高版本中的 SwiftUI 应用程序生命周期

```
在iOS14及更高版本中，SwiftUI应用程序的生命周期有了一些变化，主要通过@main标注的App协议来管理，以下是其简单描述：

1-应用启动
当用户点击应用图标启动应用时，系统会调用 App 协议中定义的 @main 函数，创建应用实例。
应用会经历一系列的初始化过程，包括加载配置、初始化视图层级等。

2-应用状态变化
2.1-激活（Active）：
应用处于前台并可与用户交互。
当应用从后台切换到前台，或者首次启动后进入可交互状态时，会处于这个状态。
开发者可通过 onAppear 等修饰符在视图中响应此状态变化，进行一些如数据加载、界面更新等操作。

2.2-非激活（Inactive）：
应用处于前台，但暂时无法与用户交互，例如在出现系统弹窗时。
此时应用仍在运行，但某些操作可能会被暂停，视图可能会进入一种 “冻结” 状态。

2.3-后台（Background）：
当应用被用户切换到后台时，会进入此状态。
应用可以在后台执行一些有限的任务，如保存数据、处理网络请求等。
SwiftUI通过ScenePhase来跟踪应用场景的状态变化，
开发者可使用onChange(of:)来观察ScenePhase的变化，在进入后台时进行必要的清理或保存工作。

2.4-挂起（Suspended）：
应用在后台一段时间后，系统可能会将其挂起以节省资源。
此时应用的内存被冻结，不再执行代码。当应用再次回到前台时，会从挂起状态恢复，继续之前的操作。

3-应用终止
用户手动关闭应用，或者系统因资源不足等原因终止应用时，应用会经历终止过程。
在这个过程中，应用会执行一些清理操作，如保存用户数据、释放资源等。

通过这些生命周期状态的管理，开发者可以更好地控制应用在不同场景下的行为，提供更流畅的用户体验和高效的资源管理。
```
## 三 参考

* [整理 SwiftUI 2023 年热门面试问题](https://www.codeun.com/archives/1259.html)

