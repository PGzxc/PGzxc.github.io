---
title: IOS面试题——Swift扩展(10)
categories:
  - 面试相关
  - IOS面试题
tags:
  - Swift面试题
abbrlink: c949b59
date: 2024-03-27 16:06:30
---
## 一 面试题汇总

1. Swift中扩展与OC中分类有什么区别？能添加什么，不能添加什么？
2. Swift中扩展不能添加指定初始化器，不能添加反初始化器
3. 结构体自定义初始化器时不会生成默认初始化器。但是可以通过扩展实现两者同时存在
4. 扩展可以给协议提供默认实现，也间接实现可选协议的效果
5. 扩展可以给协议扩充协议中从未声明过的方法<!--more-->
6. 扩展中依然可以使用原类型中的泛型类型

## 二 面试题解答(仅供参考)

### 2.1 Swift中扩展与OC中分类有什么区别？能添加什么，不能添加什么？

```
Swift 中的扩展(Extensions)与Objective-C中的分类(Categories)在某些方面是相似的，
但也有一些重要区别。

1-相似之处：
1.1-功能扩展： 两者都允许向现有的类、结构体、枚举或协议添加额外的功能。
1.2-方法添加： 可以向类中添加新的实例方法、类型方法、以及修改现有方法的实现。
1.3-属性添加： 可以向类中添加新的计算属性，但不能添加存储属性。
1.4-协议实现： 可以实现协议并向类型添加协议兼容的方法。

2-区别：
2.1-可修改性： 在 Objective-C 中，分类允许修改类的原始实现，包括添加实例变量和属性。
而在 Swift 中，扩展只能添加新的方法、计算属性，不能添加存储属性或实例变量。
2.2-访问控制： 在 Swift 中，扩展可以包含在同一模块中的访问级别，
而 Objective-C 中的分类则没有这种概念，它们的方法和属性默认都是公开的。
2.3-构造器： 在 Swift 中，可以为类添加新的便利构造器，但不能添加指定构造器或析构器。
而在 Objective-C 中，分类不能添加任何类型的构造器。
2.4-协议扩展： 在 Swift 中，可以使用协议扩展向协议添加默认实现。
这在 Objective-C 中是不可能的。
2.5-命名空间： 在 Swift 中，扩展可以用来将相关功能的方法和属性组织在一起，从而起到命名空间的作用。
而在 Objective-C 中，分类没有这种命名空间的概念，所有方法和属性都在同一个全局命名空间中。

综上所述，虽然 Swift 中的扩展与 Objective-C 中的分类在某些方面是相似的，
但它们的设计目标和实现机制有所不同，需要根据具体情况选择使用哪种技术。
```

### 2.2 Swift中扩展不能添加指定初始化器，不能添加反初始化器

```
在 Swift 中，扩展可以为现有的类、结构体、枚举或协议添加额外的功能，但它们有一些限制：

1-不能添加指定初始化器： 
在扩展中不能添加指定初始化器（designated initializer），也就是类的主要初始化器。
只能添加便利初始化器（convenience initializer）。

2-不能添加析构器： 
同样地，扩展也不能添加类的析构器。析构器是在实例被销毁时执行的特殊方法，它不能在扩展中添加。

这些限制是为了确保类的初始化和清理过程在整个代码中都是清晰和一致的。
在扩展中，可以通过添加便利初始化器来为类型提供额外的初始化功能，但不能添加类的主要初始化器或析构器。
```

### 2.3 结构体自定义初始化器时不会生成默认初始化器。但是可以通过扩展实现两者同时存在

```
在 Swift 中，如果你为结构体定义了自定义的初始化器，
Swift 将不会再自动生成默认的成员逐一初始化器（memberwise initializer）。
这是因为结构体的自定义初始化器会覆盖默认的初始化器。

但是，你可以通过扩展来实现结构体同时拥有自定义初始化器和默认初始化器。
这样做可以为用户提供更多的初始化选项，同时保留默认初始化器的便利性
```

### 2.4 扩展可以给协议提供默认实现，也间接实现可选协议的效果

```
Swift 中的扩展可以给协议提供默认实现，这样做的好处是可以为遵循该协议的类型提供默认行为，
从而减少了代码的重复编写。这种机制也可以间接地实现类似于 Objective-C 中的可选协议的效果。
```
### 2.5 扩展可以给协议扩充协议中从未声明过的方法

```
在 Swift 中，扩展可以给协议添加新的方法，甚至是协议中从未声明过的方法。
这种行为允许在协议的扩展中提供额外的功能，以便于实现更为灵活和通用的协议
```

### 2.6 扩展中依然可以使用原类型中的泛型类型

```
Swift 中的扩展可以使用原类型中定义的泛型类型。
这意味着，如果一个类型是泛型的，那么在该类型的扩展中仍然可以使用这些泛型类型，
并且可以在扩展中添加与泛型相关的方法、属性等。
```

## 三 参考

* [简书—Swift扩展](https://www.jianshu.com/p/410f01d9e638)

