---
title: Rust开发之——循环VS迭代器(45)
categories:
  - 开发
  - B-高级语言
  - Rust
tags:
  - Rust
abbrlink: 54da84f3
date: 2025-09-08 08:59:13
---
## 一 概述

```
本文探讨了 Rust 中迭代器和闭包的性能特性，重点阐述了 “零成本抽象”(zero-cost abstractions)的理念，
即高级抽象（如迭代器）在保持代码简洁性的同时，不会引入额外的性能开销
```

<!--more-->

## 二 零成本抽象的核心理念

```
Rust 的设计目标之一是提供 “零成本抽象”：
 -高级语言特性（如迭代器、闭包）在编译后生成的机器码，
 -与手动编写的底层代码（如for循环）效率相当，
 -抽象本身不会带来性能损失。

这一特性使开发者既能使用简洁的抽象逻辑，又不牺牲执行效率。
```

## 三 迭代器与手动循环的性能对比

### 3.1 基准测试示例

```
1、概念
为验证迭代器与手动循环的性能，设计两个功能相同的函数：
 -迭代器版本：使用iter()、filter()、map()和sum()等迭代器适配器。
 -手动循环版本：使用for循环和可变变量累计结果。
 
2、示例
// 迭代器版本
pub fn iterator_sum(v: &[i32]) -> i32 {
    v.iter().filter(|&&x| x % 2 == 0).map(|&x| x * x).sum()
}

// 手动循环版本
pub fn loop_sum(v: &[i32]) -> i32 {
    let mut sum = 0;
    for &x in v {
        if x % 2 == 0 {
            sum += x * x;
        }
    }
    sum
}
```

### 3.2 性能结果

```
通过cargo bench进行基准测试，两者的执行时间几乎相同。
原因是 Rust 编译器（基于 LLVM）会对迭代器代码进行深度优化，包括：
 -内联（Inlining）：将迭代器方法直接嵌入调用处，消除函数调用开销。
 -循环展开（Loop unrolling）：将循环体展开为多次执行，减少循环控制语句的开销。
 -消除冗余代码：移除迭代器抽象中不必要的逻辑，生成与手动循环等效的机器码
```

## 四 闭包的性能特性

```
闭包作为匿名函数，同样遵循零成本抽象原则：
 -编译器会将闭包转换为具体类型（而非动态分发的 trait 对象），避免虚函数调用的开销。
 -闭包捕获环境的方式（不可变借用、可变借用、所有权）由编译器优化，仅保留必要的操作，无额外成本
```

## 五 最佳实践：优先使用抽象，基于基准测试优化

```
优先选择清晰的抽象：迭代器和闭包使代码更简洁、易读，且性能与手动实现相当，应优先使用。
避免过早优化：仅在基准测试证明某段代码是性能瓶颈时，才考虑用手动循环替代迭代器。
依赖编译器优化：信任 Rust 的优化能力，无需为 “可能的性能损失” 牺牲代码可读性
```

## 六 参考

* [Rust中文官网—性能对比：循环 VS 迭代器](https://rust.bootcss.com/ch13-04-performance.html)