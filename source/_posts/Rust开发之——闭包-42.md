---
title: Rust开发之——闭包(42)
categories:
  - 开发
  - B-高级语言
  - Rust
tags:
  - Rust
abbrlink: 49beddac
date: 2025-09-01 14:56:34
---
## 一 概述

```
本文主要介绍了 Rust 中闭包（Closures）的概念、语法、特性及应用，
闭包是一种可捕获环境的匿名函数，能灵活存储和传递
```

<!--more-->

## 二 闭包的基本概念与语法

### 2.1 定义

```
闭包是匿名函数，可存储在变量中或作为参数传递，能捕获定义环境中的值，适合延迟执行代码或封装特定逻辑。
```

### 2.2 语法格式

```
1、基本形式：
|参数| 函数体，参数用竖线|包裹，函数体可省略大括号（单行时）

2、示例
// 简单闭包：接受u32参数，返回其值（模拟耗时计算）
let expensive_closure = |num: u32| -> u32 {
    println!("calculating...");
    thread::sleep(Duration::from_secs(2));
    num
};

3、类型注解可选：
编译器会自动推断参数和返回值类型，但若需明确可添加（如|num: u32| -> u32）
```

## 三 闭包的类型推断

```
-闭包无需显式标注类型，编译器会根据首次调用推断类型，且一旦确定则不可更改。
-示例：若闭包首次以String为参数调用，后续不能再传入u32，否则会触发类型错误。
```

## 四 闭包与Fn系列 trait

```
闭包实现了Fn、FnMut或FnOnce trait，用于指定其捕获环境的方式：
 -Fn：不可变借用环境变量（最常用，适用于只读访问）。
 -FnMut：可变借用环境变量（可修改捕获的值）。
 -FnOnce：获取环境变量的所有权（只能调用一次，因所有权会被转移）。
 
这些 trait 可作为泛型约束，用于定义接受闭包的函数或结构体。
```

## 五 闭包的应用：缓存计算结果(Cacher结构体)

```
1、说明
为避免重复执行耗时操作，可使用Cacher结构体存储闭包及其结果，实现缓存（懒加载）

2、Cacher定义
struct Cacher<T>
where
    T: Fn(u32) -> u32,  // 约束闭包类型
{
    calculation: T,  // 存储闭包
    value: Option<u32>,  // 缓存结果（初始为None）
}

3、缓存逻辑：
-首次调用value方法时执行闭包，将结果存入value。
-后续调用直接返回缓存的value，避免重复计算
```

## 六 闭包捕获环境

```
1、闭包可捕获定义作用域中的变量，而普通函数不能：
 -捕获方式：根据使用场景自动选择（不可变借用、可变借用或所有权转移）。
-move关键字：强制闭包获取环境变量的所有权，适用于需要将变量转移到新线程等场景。

2、示例
let x = vec![1, 2, 3];
let closure = move |z| z == x;  // x的所有权被转移到闭包
```

## 七 Cacher的局限性

```
仅支持单一参数类型（如u32），无法通用化。
仅缓存单个结果，若闭包参数不同，仍会返回首次计算的值（需改进为哈希表存储多参数结果）
```

## 八 总结

```
闭包是 Rust 中灵活的匿名函数，通过捕获环境和延迟执行，简化了代码复用和逻辑封装。
结合Fn系列 trait，可实现如缓存、回调等功能，但其类型推断和捕获行为需注意一致性。
Cacher示例展示了闭包在优化性能（避免重复计算）中的应用，同时也体现了其使用限制及改进方向。
```

## 九 参考

* [Rust中文官网—闭包：可以捕获环境的匿名函数](https://rust.bootcss.com/ch13-01-closures.html)