---
title: 前端面试题之——网络部分
categories:
  - 面试相关 - 前端面试题
tags:
  - 前端面试题
abbrlink: d4e93e65
date: 2024-03-23 18:56:21
---
## 一 面试题汇总

1. 页面从输入URL到展现发生了什么
2. cookie和session的异同
3. HTTP和HTTPS的区别
4. ssl加密使用了那种算法，如何加密
5. TCP三次握手的过程，为什么是三次而不是两次或者四次？<!--more-->
6. TCP的四次挥手
7. HTTP报文的格式，传输中以何种方式传输
8. 常见的HTTP头部
9. HTTP状态的简要分类
10. HTTP状态码101、200、301、302、304的具体含义
11. 301和302的区别
12. 简要介绍一次302的过程
13. HTTP2.0的简要介绍
14. 用户登陆过程的简要说明，如何判断用户是否登录？
15. tcp和udp的区别
16. udp的阻塞机制，如何处理
17. 简要介绍一下socket协议
18. get和post有什么区别？什么时候用get，什么时候用post
19. 什么是正向代理？什么是反向代理？
20. 介绍一下HTTPS的连接过程
21. 和缓存有关的请求头有哪些？优先级是怎样的？
22. 介绍一下DNS的查找过程？
23. http连接性能优化，长连接，keep-alive
24. https的详细过程，使用的加密算法，是对称加密算法还是非对称加密算法。md5、SHA、AES分别是对称加密的还是非对称加密的
25. https没有大规模应用的原因
26. http2有哪些新特性？
27. 端口号的作用是什么？

## 二 面试题解答(仅供参考)

### 2.1 页面从输入URL到展现发生了什么

```
输入URL之后，需要寻找到这个url域名的服务器IP，为了找到这个IP，浏览器首先会寻找缓存， 
查看缓存中是否有记录，缓存中查找的顺序是浏览器缓存、系统缓存、路由器缓存，
缓存中没有则 查找系统的hosts文件中是否有记录，如果没有记录则会查询DNS服务器，
得到服务器的IP地址之 后，浏览器根据这个IP以及相应的端口号，
（如HTTP协议默认的端口号为80，HTTPS协议的默认 端口号为443，
当然可以在url中指定端口号）构造一个HTTP请求，并将这个HTTP包请求封装在 一个TCP包中，
（这个HTTP请求报文会包含这次请求的信息，主要是请求方法、请求的说明和请 求附带的数据），
这个tcp包依次会经过传输层、网络层、数据链路层、物理层到达服务器，
服务器解析这个请求来做出响应，（我们假定这个url是一个类似谷歌、淘宝这样的网站首页，而 不是简单的文件），
服务器返回相应的HTML给浏览器，因为HTML是一个树形结构，
浏览器根据 这个HTML来构建DOM树在DOM树的构建过程中如果遇到js脚本和外部js连接，
则会停止构建DOM 树来执行和下载相应的代码，这会造成阻塞，
这也就是为什么推荐js代码应该放在HTML代码的后 面，
之后根据外部样式、内部样式、内联样式构建一个CSS对象模型树（CSSOM树），
构建完成之 后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，
如script、meta标签和排除display 为none的节点，之后就是进行布局，
布局主要是确定各个元素的位置和尺寸，之后就是渲染页面。 

因为HTML文件中会含有图片、音频、视频等资源，在解析DOM的过程中，遇到这些都会进行并行下 载，
当然浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，
当然在这些所有请求中我们 还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。
Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，
因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，
会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，
如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，
如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304
```

### 2.2 cookie和session的异同

```
cookie和session都可以用来存储用户信息，
cookie存放于客户端，session存放于服务端，因为cookie存放于客户端 有可能被窃取，
因此cookie一般用来存放不敏感的信息，如用户设置的网站主题等，
敏感的信息采用session存储，如用户 的登陆信息，
session可以存放于文件、数据库、内存中都可以，cookie可以服务端响应的时候设置，
也可以客户端通过js设置 cookie会在请求时在http首部发送给客户端，
cookie一般在客户端有大小限制，一般为4k
```

### 2.3 HTTP和HTTPS的区别

```
首先HTTP和HTTPS的默认端口号就不一样，HTTP的默认端口号为80，HTTPS的默认端口号为443，
HTTP在传输过程中使用的是明文传输，内容可能被窃取，而且无法验证通信方的身份，
还有可能遭遇身份伪装，而HTTPS在应用层和传输层之间增加了ssl协议用来加密 内容，
因此通过证书验证来验证身份，即使数据被窃取也无法解密，数据的传输更加安全
```

### 2.4 ssl加密使用了那种算法，如何加密

```
SSL（Secure Sockets Layer）和其继任者TLS（Transport Layer Security）是用于在互联网上安全传输数据的协议。SSL/TLS 协议使用了多种加密算法来保护数据的机密性和完整性。以下是 SSL/TLS 协议中常用的加密算法：

1. **对称加密算法**：对称加密算法使用相同的密钥来加密和解密数据。常见的对称加密算法包括：
   - **AES（Advanced Encryption Standard）**：目前最常用的对称加密算法之一，支持不同的密钥长度（如 AES-128、AES-256），在保密性和性能之间取得了很好的平衡。
   - **DES（Data Encryption Standard）**：较老的对称加密算法，已不推荐使用，因为其密钥长度较短，易受到暴力破解攻击。
2. **非对称加密算法**：非对称加密算法使用一对密钥来加密和解密数据，公钥用于加密，私钥用于解密。常见的非对称加密算法包括：
   - **RSA（Rivest-Shamir-Adleman）**：目前最常用的非对称加密算法之一，可用于数字签名、密钥交换等场景。
   - **DSA（Digital Signature Algorithm）**：专门用于数字签名的非对称加密算法。
   - **ECC（Elliptic Curve Cryptography）**：基于椭圆曲线的非对称加密算法，具有较小的密钥尺寸和更高的安全性，适用于资源受限的环境。
3. **哈希算法**：哈希算法用于生成数据的摘要或签名，不可逆，无法解密。常见的哈希算法包括：
   - **SHA-1（Secure Hash Algorithm 1）**：较老的哈希算法，已不推荐使用，因为其安全性较差，易受到碰撞攻击。
   - **SHA-256、SHA-384、SHA-512**：SHA 家族中的更安全的哈希算法，提供了更长的摘要长度和更高的安全性。

SSL/TLS 协议通过组合对称加密算法、非对称加密算法和哈希算法来实现安全通信。一般情况下，SSL/TLS 握手阶段会使用非对称加密算法来协商会话密钥，然后使用对称加密算法来加密通信过程中的数据，同时使用哈希算法来验证数据的完整性。这样既保证了通信的安全性，又提高了传输效率。
```

### 2.5 TCP三次握手的过程，为什么是三次而不是两次或者四次？

```
第一次握手：客户端发送一个syn（同步）包（syn=x）给服务器，进入SYN_SEND状态，等待服务器确认

第二次握手：服务端收到客户端发送的同步包，确认客户端的同步请求（ack=x+1）,同时也发送一个同步包， 也就是一个ACK包+SYN包服务器进入SYN_RECV状态

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送一个确认包，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手

不是两次是为了防止已经失效的连接请求报文段突然又传送到了服务端，因而产生错误，比如有一个因网络延迟的请求 发送到了服务端，服务端收到这个同步报文之后进行确认，如果此时是两次握手，那么此时连接建立，但是客户端并没有发出 建立连接的请求，服务端却一直等待客户端发送数据，这样服务端的资源就白白浪费了。

不是四次的话是因为完全没有必要，三次已经足够了
```

### 2.6 TCP的四次挥手

```
第一次：主动关闭方发送一个FIN包，用来关闭主动关闭方到被动关闭方的数据传送，也就是告诉另一方我不再发送数据了，但此时仍可以接收数据

第二次：被动关闭方收到FIN包之后，发送一个确认（ACK）包给对方

第三次：被动关闭方发送一个FIN包，告诉对方不带发送数据

第四次：主动关闭方收到FIN包之后，发送一个ACK包给对方，至此完成四次挥手
```

### 2.7 HTTP报文的格式，传输中以何种方式传输

```
HTTP报文分为三个部分，起始行、首部和主体，其中起始行和首部以一个回车和换行符分隔，
首部和主体以一个空行分隔，其中起始行是对这次HTTP请求或者响应 的描述，
请求报文的起始行包括使用的HTTP方法、请求的url地址、HTTP版本，
响应报文的起始行包括HTTP的版本，HTTP状态码，http状态码的描述，
首部也 就是常说的HTTP头部，如Date、Cookie、Content-Type等，
主体是这次请求或响应的数据，传输中以明文传输。
```

### 2.8 常见的HTTP头部

```
可以将HTTP首部分为通用首部、请求首部、响应首部、实体首部，通用首部表示一些通用信息，
如Date表示报文创建时间，请求首部就是请求报文中 独有的，
如cookie、和缓存相关的If-Modified-Since，响应首部就是响应报文中独有的，
如set-cookie和重定向有关的location，实体首部用来 描述实体部分，
如Allow用来描述可执行的请求方法，Content-Type描述主体类型，Content-Encoding描述主体的编码方式
```

### 2.9 HTTP状态的简要分类

```
可以按照HTTP状态码的第一个数字分类，
1xx表示信息，
2xx表示成功，
3xx表示重定向，这里需要注意的是304，表示未修改， 
4xx表示客户端错误，最常见的是404，
5xx表示服务端错误
```

### 2.10 HTTP状态码101、200、301、302、304的具体含义

```
101：切换协议 
200：正常，OK，
301：永久重定向，
302：临时重定向，
304：未修改
```

### 2.11 301和302的区别

```
301 和 302 都是 HTTP 状态码，用于重定向请求。它们之间的主要区别在于重定向的类型和行为：

1. **301 Moved Permanently (永久重定向)**：
   - 301 状态码表示所请求的资源已被永久移动到新的位置，并且将来的请求应该直接使用新的 URL。
   - 浏览器在收到 301 响应后会自动缓存新的 URL，并在后续请求中直接使用新的 URL。
   - 301 重定向适用于永久性的 URL 更改，例如网站更改域名或路径，搜索引擎会将旧的 URL 中的权重转移到新的 URL。
2. **302 Found (临时重定向)**：
   - 302 状态码表示所请求的资源暂时性地移动到了一个新的位置，但将来的请求仍应使用原始 URL。
   - 浏览器在收到 302 响应后不会缓存新的 URL，并在后续请求中继续使用原始的 URL。
   - 302 重定向适用于临时性的 URL 更改，例如网站正在维护，暂时重定向到一个备用页面，或者进行 A/B 测试时的临时重定向等。

总的来说，301 重定向是永久性的重定向，浏览器会缓存新的 URL，并且将来的请求会直接使用新的 URL；而 302 重定向是临时性的重定向，浏览器不会缓存新的 URL，并且将来的请求会继续使用原始的 URL。选择使用哪种重定向取决于重定向的性质和目的
```

### 2.12 简要介绍一次302的过程

```
当客户端（通常是浏览器）发送一个 HTTP 请求到服务器，并且服务器响应的状态码是 302 Found 时，将触发一次重定向过程。下面是一次 302 重定向的简要过程：

1. **客户端发送请求**：
   - 客户端（通常是浏览器）发送一个 HTTP 请求到服务器，请求某个资源（例如网页）的 URL。
2. **服务器响应 302 状态码**：
   - 服务器收到客户端的请求后，判断请求的资源处于临时性移动状态，于是返回一个 HTTP 响应，状态码为 302 Found，并在响应头中包含一个 Location 字段，指向新的 URL。
3. **客户端收到重定向响应**：
   - 客户端收到服务器的响应后，解析响应头，发现状态码为 302 Found，同时在响应头中找到 Location 字段，里面包含了重定向的目标 URL。
4. **客户端发起新的请求**：
   - 客户端解析完响应头后，根据 Location 字段中指定的新的 URL，再次发送一个新的 HTTP 请求到服务器。
5. **服务器响应新的请求**：
   - 服务器收到客户端发送的新请求后，处理该请求，并返回相应的资源（例如网页内容）给客户端。
6. **客户端渲染响应内容**：
   - 客户端收到服务器返回的响应后，根据响应内容渲染页面或执行其他操作，以展示给用户。

总的来说，302 重定向过程中，客户端发送请求到服务器，服务器返回一个 302 响应，并在响应头中包含一个 Location 字段指向新的 URL，客户端根据新的 URL 再次发送请求到服务器获取资源。
```

### 2.13 HTTP2.0的简要介绍

```
用户请求一个url，服务器处理这个url，设置这个url需要重定向，返回用户一个302响应，
并在http头部设置location字段为新的地址， 浏览器得到这个响应，
根据location中新的地址重新发起一次请求。
```

### 2.14 用户登陆过程的简要说明，如何判断用户是否登录？

```
判断用户是否登录的方法通常是检查客户端中存储的登录凭证是否存在或者是否有效。
如果存在且有效，则表示用户已经登录；否则表示用户未登录，需要重新进行登录操作
```

### 2.15 tcp和udp的区别

```
TCP面向连接的、提供可靠传输的协议，而UDP则是面向非连接。
不可靠传输的协议，之所以说TCP是可靠的传输协议是因为TCP协议在传输数据之前有一个确认双方是否 连接的过程，
而UDP没有，也正是因此在传输速度方面，UDP更快。
因此需要可靠传输需要选用TCP，不需要可靠传输情况下选择UDP
```

### 2.16 udp的阻塞机制，如何处理

```
在使用 UDP 进行通信时，由于其不提供阻塞机制，因此需要应用程序自行处理以下几个方面：

1. **超时处理**：发送端在发送数据后，可能无法得知数据是否成功到达目标主机，
因此可以通过设置超时时间来处理未收到确认的情况，超时后进行重传或者其他操作。
2. **丢包处理**：在 UDP 传输过程中，由于网络原因可能会导致数据包丢失，
因此接收端需要处理丢失的数据包，例如通过重传机制或者丢弃该数据包。
3. **数据完整性检验**：UDP 不保证数据的完整性，
因此接收端需要通过一定的校验机制来检验接收到的数据是否完整和正确，例如使用校验和或者哈希函数等。
4. **顺序性处理**：UDP 不保证数据包的顺序性，因
此接收端需要根据自身的业务逻辑来处理接收到的数据包，保证数据包的顺序性和完整性。

综上所述，UDP 的阻塞机制并不像 TCP 那样，
需要应用程序自行处理超时、丢包、数据完整性检验和顺序性处理等问题。
在实际应用中，需要根据具体的需求和网络环境来选择合适的处理方式来保证通信的可靠性和稳定性
```

### 2.17 简要介绍一下socket协议

```
Socket 协议（套接字协议）是一种用于网络通信的编程接口或者通信协议，
它允许不同计算机之间通过网络进行通信。
Socket 协议在网络编程中起着重要的作用，它允许应用程序在网络上进行数据的发送、接收和交换
```

### 2.18 get和post有什么区别？什么时候用get，什么时候用post

```
get用来请求数据，
post用来提交数据，
form表单使用get时，数据会以querystring形式存在url中，因而不够安全也存在数据大小限制，
而post不会，post将数据 存放在HTTP报文体中，获取数据应该使用get，提交数据应该使用post。
```

### 2.19 什么是正向代理？什么是反向代理？

```
正向代理就是客户端向代理服务器发送请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。比如翻墙 
反向代理的话代理会判断请求走向何处，并将请求转交给客户端，客户端只会觉得这个代理是一个真正的服务器。如负载均衡
```

### 2.20 介绍一下HTTPS的连接过程

```
1-客户端发起连接请求：
客户端（例如浏览器）向服务器发起 HTTPS 连接请求，请求的 URL 使用 HTTPS 协议（以 https:// 开头）。

2-服务器端响应：
服务器收到客户端的连接请求后，会生成一个数字证书（SSL 证书），
包含了服务器的公钥、服务器的域名、证书的颁发机构等信息，并将该证书发送给客户端。

3-客户端验证证书：
客户端收到服务器发送的证书后，会验证证书的合法性和有效性，
包括检查证书的颁发机构是否受信任、证书是否过期、证书中的域名是否与访问的域名匹配等。
如果证书验证通过，则客户端信任服务器，并准备开始加密通信；
否则，客户端会显示警告信息，提示证书不受信任或存在安全问题。

4-协商加密算法：
客户端和服务器端在建立连接时会协商使用的加密算法和密钥长度，
以确保通信过程中的数据加密和解密的一致性。
通常会选择一种安全性较高的加密算法（如 RSA、AES）和适当长度的密钥来保护通信过程中的数据安全。

5-生成会话密钥：
客户端和服务器端使用协商好的加密算法和密钥长度来生成一个会话密钥（Session Key），
用于对通信过程中的数据进行加密和解密。
会话密钥通常是对称密钥，用于加密和解密数据，而非对称密钥用于在通信开始阶段对会话密钥进行安全交换。

6-加密通信：
客户端和服务器端使用协商好的加密算法和会话密钥来加密通信过程中的数据，
从而保护数据在传输过程中的安全性。
客户端发送的数据经过加密后传输到服务器端，服务器端收到数据后使用会话密钥进行解密，
同样，服务器端发送的数据经过加密后传输到客户端，客户端收到数据后使用会话密钥进行解密。
```

### 2.21 和缓存有关的请求头有哪些？优先级是怎样的？

```
和缓存有关的请求头有Cache-Control、If-Match、If-None-Match、If-Modified-Since、If-Unmodified-Since，
在缓存中 总体来说是Cache-Control优先于Expires，Cache-Control中会需要检测Cache-Control是否过期，
过期的话检验会优先检测Etag， 也就是If-Match、If-None-Match,
不一致则验证Last-Modify请求头也就是If-Modified-Since、If-Unmodified-Since。
```

### 2.22 介绍一下DNS的查找过程？

```
1-本地缓存查找
2-递归查询
3-根域名服务器查询
4-顶级域名服务器查询
5-权威域名服务器查询
6-返回结果
```

### 2.23 http连接性能优化，长连接，keep-alive

```
HTTP 连接性能优化是提高 Web 应用性能的重要手段之一。
长连接和 HTTP Keep-Alive 是两种常用的 HTTP 连接性能优化技术，
它们可以减少连接建立和关闭的开销，提高数据传输的效率，从而加速页面加载和提升用户体验。

1. **长连接（HTTP Persistent Connection）**：
   - 长连接是一种在单个 TCP 连接上可以发送和接收多个 HTTP 请求和响应的机制。
   - 在传统的 HTTP/1.0 协议中，每个 HTTP 请求都需要建立一个独立的 TCP 连接，
   请求结束后立即关闭连接，这样会导致频繁的 TCP 连接建立和关闭，增加了网络开销和延迟。
   - HTTP/1.1 引入了长连接的概念，允许客户端和服务器在同一个 TCP 连接上发送和接收多个 HTTP 请求和响应，
   连接在完成一定数量的请求后才关闭，从而减少了连接建立和关闭的开销，提高了传输效率。
2. **Keep-Alive（HTTP Keep-Alive）**：
   - Keep-Alive 是一种在长连接中保持连接活跃的机制，用于避免连接由于空闲而被中断或超时关闭。
   - 在 HTTP/1.1 协议中，默认启用了 Keep-Alive，
   客户端和服务器可以通过 Keep-Alive 头部字段来指定连接的保持时间，单位为秒。
   - 在 Keep-Alive 时间内，如果连接上没有数据传输，则客户端和服务器会发送心跳消息以维持连接活跃，
   确保连接不被中断。

通过使用长连接和 Keep-Alive 技术，可以有效地减少 HTTP 请求的网络延迟和连接建立的开销，
提高数据传输的效率和网页加载速度。这些技术对于减少不必要的网络开销
、提升 Web 应用性能和用户体验具有重要意义。
```

### 2.24 https的详细过程，使用的加密算法，是对称加密算法还是非对称加密算法。md5、SHA、AES分别是对称加密的还是非对称加密的

### 2.25 https没有大规模应用的原因

```
1-成本和性能问题：在 HTTPS 出现之初，采用 SSL/TLS 加密传输会增加服务器的计算成本和传输延迟，
尤其是在计算能力和网络速度有限的时代。因此，一些网站和服务可能觉得不值得为所有的网络通信都采用加密。

2-证书颁发机构（CA）的信任问题：HTTPS 使用数字证书来验证服务器的身份，
而这些证书通常需要由受信任的第三方证书颁发机构（CA）签发。
在过去，一些 CA 存在信任问题，他们可能会签发不安全的证书，从而降低了 HTTPS 的可靠性。

3-SEO 和性能问题：在过去，一些搜索引擎可能会降低未加密网站的搜索排名，
从而导致一些网站担心转向 HTTPS 会影响其搜索引擎优化（SEO）。
此外，HTTPS 的加密和解密过程可能会增加页面加载时间，对性能产生影响。

4-技术难题：在刚开始推广 HTTPS 时，一些网站可能由于技术难题而无法轻松实现 HTTPS，
尤其是那些采用了旧版本服务器软件或者缺乏安全专家的组织。

然而，随着时间的推移，这些问题已经逐渐得到解决。现代的服务器硬件和软件提供了更好的加密性能，
证书颁发机构也加强了对证书的审核和管理，同时，HTTPS 也成为了互联网标准的一部分，
现在大多数主流的网站都采用了 HTTPS 来保护用户的隐私和安全。
```

### 2.26 http2有哪些新特性？

```
HTTP/2 是 HTTP 协议的下一代版本，旨在提高网站性能和用户体验。它引入了许多新特性和改进，主要包括以下几点：

1. **多路复用（Multiplexing）**：
   - HTTP/2 允许在单个 TCP 连接上并行发送多个 HTTP 请求和响应，解决了 HTTP/1.x 中的队头阻塞问题，提高了连接的利用率和性能。
2. **二进制分帧（Binary Framing）**：
   - HTTP/2 将 HTTP 报文分割为更小的二进制帧，每个帧都是独立的，可以按需调整大小和优先级，从而更加高效地传输数据。
3. **头部压缩（Header Compression）**：
   - HTTP/2 使用 HPACK 算法对 HTTP 报文头部进行压缩，减少了报文的大小，降低了网络传输的开销，提高了性能。
4. **服务器推送（Server Push）**：
   - HTTP/2 允许服务器在客户端请求之前主动推送资源给客户端，避免了客户端请求资源的等待时间，加速了页面加载速度。
5. **流量控制（Flow Control）**：
   - HTTP/2 引入了流量控制机制，允许客户端和服务器控制数据流的速率，防止了过载和拥塞，提高了网络的稳定性和可靠性。
6. **服务器端推送（Header Field Priority）**：
   - HTTP/2 允许客户端指定请求的优先级，服务器可以根据请求的优先级来优先处理响应，提高了页面加载的效率和质量。
7. **安全性（TLS Requirement）**：
   - HTTP/2 推荐使用 TLS 加密传输，保护用户的隐私和安全，同时也加速了页面加载速度，提高了网络的安全性。

这些新特性使得 HTTP/2 比 HTTP/1.x 更快、更高效，可以更好地满足现代网站和应用的性能需求，提升用户体验。
```

### 2.27 端口号的作用是什么？

```
作用是区分服务类别和同一时间进行多个会话
```


## 三 参考

* [FE-Interview—网络部分](https://huruji.github.io/FE-Interview/#/docs/NetWork)


