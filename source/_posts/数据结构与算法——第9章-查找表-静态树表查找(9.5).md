---
title: 数据结构与算法——第9章-查找表-静态树表查找(9.5)
categories:
  - 开发
  - N-数据与算法
  - 数据结构与算法
tags:
  - 数据结构与算法
abbrlink: 2710e78e
date: 2023-05-10 18:24:54
---
## 一 概述

```
1.静态树表查找算法
2.次优查找树的构建方法
3.完整事例演示
```

<!--more-->

## 二 静态树表查找算法

### 2.1 算法选择

```
前面章节所介绍的有关在静态查找表中对特定关键字进行顺序查找、折半查找或者分块查找，
都是在查找表中各关键字被查找概率相同的前提下进行的。

例如查找表中有 n 个关键字，表中每个关键字被查找的概率都是 1/n。
在等概率的情况，使用折半查找算法的性能最优。
而在某些情况下，查找表中各关键字被查找的概率是不同的。
例如水果商店中有很多种水果，对于不同的顾客来说，由于口味不同，各种水果可能被选择的概率是不同的。
假设该顾客喜吃酸，那么相对于苹果和橘子，选择橘子的概率肯定要更高一些。
```

### 2.2 折半查找对应的判定树

```
在查找表中各关键字查找概率不相同的情况下，对于使用折半查找算法，
按照之前的方式进行，其查找的效率并不一定是最优的。
例如，某查找表中有 5 个关键字，各关键字被查找到的概率分别为：0.1，0.2，0.1，0.4，0.2
（全部关键字被查找概率和为 1 ），则根据之前介绍的折半查找算法，建立相应的判定树为（树中各关键字用概率表示）：
```

![][1]

```
折半查找查找成功时的平均查找长度的计算方式为：
ASL = 判定树中各结点的查找概率*所在层次
所以该平均查找长度为：
ASL=0.1*1 + 0.1*2 + 0.4*2 + 0.2*3 + 0.2*3 = 2.3
```

### 2.3 折半查找对应的新判定树

```
由于各关键字被查找的概率是不相同的，所以若在查找时遵循被查找关键字先和查找概率大的关键字进行比对，
建立的判定树为：
```

![][2]



```
相应的平均查找长度为：
ASL=0.4*1 + 0.2*2 + 0.2*2 + 0.1*3 + 0.1*3=1.8
```

### 2.4 最优查找树和次优查找树

```
后者折半查找的效率要比前者高，所以在查找表中各关键字查找概率不同时，要考虑建立一棵查找性能最佳的判定树。
若在只考虑查找成功的情况下，描述查找过程的判定树其带权路径长度之和（用 PH 表示）最小时，
查找性能最优，称该二叉树为静态最优查找树。

带权路径之和的计算公式为：PH = 所有结点所在的层次数 * 每个结点对应的概率值。

但是由于构造最优查找树花费的时间代价较高，
而且有一种构造方式创建的判定树的查找性能同最优查找树仅差 1% - 2%，
称这种极度接近于最优查找树的二叉树为次优查找树。
```

## 三 次优查找树的构建方法

### 3.1 计算公式

```
首先取出查找表中每个关键字及其对应的权值，采用如下公式计算出每个关键字对应的一个值：
```

![][3]

```
其中 w j 表示每个关键字的权值（被查找到的概率），h 表示关键字的个数。

表中有多少关键字，就会有多少个 △P i ，取其中最小的做为次优查找树的根结点，
然后将表中关键字从第 i 个关键字的位置分成两部分，分别作为该根结点的左子树和右子树。
同理，左子树和右子树也这么处理，直到最后构成次优查找树完成。
```

### 3.2 实现代码

```
typedef int KeyType;//定义关键字类型
typedef struct {
	KeyType key;
} ElemType; //定义元素类型
typedef struct BiTNode {
	ElemType data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;
//定义变量
int i;
int min;
int dw;
//创建次优查找树，R 数组为查找表，sw 数组为存储的各关键字的概率（权值），low 和 high 表示的 sw 数组中的权值的范围
void SecondOptimal(BiTree T, ElemType R[], float sw[], int low, int high) {
//由有序表 R[low...high]及其累计权值表 sw（其中 sw[0]==0）递归构造次优查找树
	i = low;
	min = abs(sw[high] - sw[low]);
	dw = sw[high] + sw[low - 1];
//选择最小的△Pi 值
	for (int j = low+1; j <=high; j++) {
		if (abs(dw-sw[j]-sw[j-1])<min) {
			i = j;
			min = abs(dw - sw[j] - sw[j - 1]);
		}
	}
	T = (BiTree)malloc(sizeof(BiTNode));
	T->data = R[i];//生成结点（第一次生成根）
	if (i == low) T->lchild = NULL;//左子树空
	else SecondOptimal(T->lchild, R, sw, low, i - 1);//构造左子树
	if (i == high) T->rchild = NULL;//右子树空
	else SecondOptimal(T->rchild, R, sw, i + 1, high);//构造右子树
}
```

## 四 完整事例演示

### 4.1 图表

```
例如，一含有 9 个关键字的查找表及其相应权值如下表所示：
则构建次优查找树的过程如下：
```

![][4]

### 4.2 过程

一、步骤1

```
首先求出查找表中所有的 △P 的值，找出整棵查找表的根结点：
例如，关键字 F 的 △P 的计算方式为：从 G 到 I 的权值和 - 从 A 到 E 的权值和 = 4+3+5-1-1-2-5-3 = 0。
```

![][5]

二、步骤2

```
通过上图左侧表格得知，根结点为 F，以 F 为分界线，左侧子表为 F 结点的左子树，
右侧子表为 F 结点的右子树（如上图右侧所示），继续查找左右子树的根结点：
```

![][6]

三、步骤3

```
通过重新分别计算左右两查找子表的 △P 的值，得知左子树的根结点为 D，
右子树的根结点为 H （如上图右侧所示），以两结点为分界线，继续判断两根结点的左右子树：
```

![][7]



```
通过计算，构建的次优查找树如上图右侧二叉树所示。
后边还有一步，判断关键字 A 和 C 在树中的位置，最后一步两个关键字的权值为 0 ，
分别作为结点 B 的左孩子和右孩子，这里不再用图表示

注意：在建立次优查找树的过程中，由于只根据的各关键字的 P 的值进行构建，没有考虑单个关键字的相应权值的大小，
有时会出现根结点的权值比孩子结点的权值还小，此时就需要适当调整两者的位置。
```

## 五 总结

```
由于使用次优查找树和最优查找树的性能差距很小，构造次优查找树的算法的时间复杂度为 O(nlogn)，
因此可以使用次优查找树表示概率不等的查找表对应的静态查找表（又称为静态树表）。
```


## 六 参考

* [C语言中文网—静态树表查找算法详解](https://c.biancheng.net/view/vip_3430.html)


[1]:https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-data-struct-basic/ds-chap9-5-1.png
[2]:https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-data-struct-basic/ds-chap9-5-2.png
[3]:https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-data-struct-basic/ds-chap9-5-3.png
[4]:https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-data-struct-basic/ds-chap9-5-4.png
[5]:https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-data-struct-basic/ds-chap9-5-5.png
[6]:https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-data-struct-basic/ds-chap9-5-6.png
[7]:https://cdn.jsdelivr.net/gh/PGzxc/CDN/blog-data-struct-basic/ds-chap9-5-7.png

