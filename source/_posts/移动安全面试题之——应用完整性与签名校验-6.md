---
title: 移动安全面试题之——应用完整性与签名校验(6)
categories:
  - 面试相关
  - 移动安全面试题
tags:
  - 移动安全面试题
abbrlink: 250dc7db
date: 2025-09-29 09:48:58
---
## 一 概述

```
本文题目来自于：
 - 面试招聘要求
 - 网友分享
```

<!--more-->

## 二  面试要求和面试题

```
1.APK/IPA 签名与加固：
-jarsigner/apksigner → 确保 APK 未被篡改（Android）；codesign（iOS）
-DexGuard/商业加固 → 增强反逆向能力（Android）；iXGuard（iOS）
2.运行时完整性校验：
-Play Integrity Attestation：检测 Root/篡改（Android）
-App Attest：验证应用真实性（iOS）
3.防篡改机制：
-PackageManager 校验 APK 签名一致性（Android）；App Attest（iOS）
```

### 三 面试题解答(仅供参考)

### 3.1 APK/IPA签名与加固

面试考点

```
1.APK/IPA 签名：确保 APK/IPA 文件未被篡改，验证开发者身份，Google Play/App Store 强制要求
2.签名工具：apksigner 推荐使用，支持多种签名版本（v1~v4），比 jarsigner 更安全（Android）；codesign（iOS）
3.APK/IPA 加固：通过混淆、加密、反调试等提升防逆向能力，常见工具如 DexGuard、360加固保（Android）；iXGuard、Arxan（iOS）
4.运行时签名验证：防止二次打包和篡改，通过比对签名哈希值确保完整性
```

1、APK/IPA 签名的定义与作用

```
1、定义：
使用私钥对 APK/IPA 进行数字签名，保证来源可信，内容未被篡改

2、作用：
-完整性保障：防止 APK/IPA 被篡改后安装
-身份认证：验证开发者身份，保证同签名者应用的兼容性
-强制性要求：Google Play/App Store 发布必须签名

3、面试要点：
签名是 Android/iOS 安全机制基础，防止二次打包和恶意篡改
```

2、Jarsigner 与 Apksigner 的区别（Android）；codesign（iOS）

```
1、Jarsigner（旧/Android）：
-基于 JDK，仅支持 v1 签名
-适合 Android 7.0 以下，验证速度慢，安全性较低

2、Apksigner（推荐/Android）：
-Android 官方工具，支持 v1、v2（全文件签名）、v3（密钥轮换）、v4（流式签名）
-v2/v3 签名更快、更安全，现代开发的首选

iOS：codesign使用Apple证书签名，确保App Store合规
```

3、APK/IPA 加固的作用与 DexGuard/iXGuard 优势

```
1、目的：
防止反编译、破解、篡改，保护核心代码与数据

2、常见措施：
-代码混淆（类/方法重命名）
-字符串加密（隐藏 API Key 等敏感数据）
-资源加密、防动态调试
-反 Hook 检测（阻止 Xposed/Frida 等框架）

3、DexGuard 特点（Android）：
-比 ProGuard / R8 更强：支持运行时检查、资源加密
-适合高安全需求（金融、支付类应用）
-缺点：收费高、可能增加 APK 体积和性能开销

iXGuard特点（iOS）：
-支持Swift混淆、反逆向，集成Xcode
```

4、运行时签名验证（防篡改）

```
1、目的：
防止 APK/IPA 被二次打包

2、实现步骤：
-预计算签名哈希：发布前计算并存储 SHA-256/MD5 值
-获取当前签名：PackageManager.getPackageInfo()(Android)；App Attest生成attestation（iOS）
-比对签名：若不一致，说明 APK/IPA 被篡改

3、处理方式：
不一致时可退出应用、上报日志、禁用功能

4、工具：
apksigner verify <apk> 检查签名有效性（Android）；codesign -dv（iOS）
```

5、APK/IPA 加固原理与常见工具

```
1、原理（以 Dex/Mach-O 加固为例）：
-加密原始 classes.dex/Mach-O 文件
-生成壳 Dex/dylib 文件，负责启动时解密原始 Dex/Mach-O
-运行时通过 DexClassLoader/dlopen 动态加载解密后的 Dex/Mach-O 执行

2、常见工具：
-商业：DexGuard、腾讯御安全、360 加固保、梆梆安全（Android）；iXGuard、Arxan（iOS）
-开源/免费：ProGuard、R8（仅混淆，保护力有限/Android）；SwiftShield（iOS）
```

6、总结要点

```
-APK/IPA 签名：保证完整性与身份，v2/v3 是主流（Android）；codesign（iOS）
-签名工具：推荐使用 Apksigner，替代 Jarsigner（Android）；codesign（iOS）
-APK/IPA 加固：通过混淆、加密、反调试增强安全性，DexGuard/iXGuard 提供高级防护
-运行时验证：在应用中比对签名，防止二次打包
-最佳实践：结合 Apksigner v2/v3/codesign、加固工具与运行时校验，构建多层安全防护
```

### 3.2 运行时完整性校验

面试考点

```
运行时完整性校验：保证应用运行在安全、可信的环境中，防止 Root/越狱、篡改或伪造请求
Play Integrity API：Google 服务验证设备/应用完整性（Android）
App Attest：Apple 服务验证应用真实性（iOS）
```

1、什么是运行时完整性校验？其作用是什么？

```
1、定义：
在应用运行时验证 APK/IPA 签名、环境完整性，防止篡改/Root/越狱

2、作用：
-防篡改：检测二次打包
-防 Root/越狱：限制高风险环境运行
-提升安全性：结合服务端验证，保护敏感操作

3、适用场景：
银行/支付类应用，满足 PCI-DSS 合规
```

2、如何实现运行时签名校验？

```
流程（Android）：
1、预存签名哈希：发布前计算 SHA-256 哈希值
-安全存储在应用内（加密）或由服务器下发

1.2、获取当前签名：
-API 28 以下：PackageManager.GET_SIGNATURES → signatures[]
-API 28+：PackageManager.GET_SIGNING_CERTIFICATES → signingInfo

1.3、比对结果：
-哈希值一致 → 应用可信
-不一致 → 触发防护措施（退出、禁用功能、上报日志）

流程（iOS）：
1、生成密钥：DCAppAttestService.generateKey()
2、生成attestation：attestKey() with hash
3、服务器验证attestation

二、注意点：
-校验应在 Application 启动或 敏感功能（支付/登录）前执行
-避免将签名直接硬编码，推荐加密存储或动态获取
-支持多签名场景（如密钥轮换）
```

3、最佳实践

```
1、运行时验证：应用启动时、关键操作前执行签名校验

2、结合多重防护：
-服务端验证（Play Integrity/Android；App Attest/iOS）
-代码混淆、DexGuard/iXGuard 加固、反调试检测

3、应对篡改：发现异常 → 立即终止或限制功能，并上报事件

4、测试验证：
-修改 APK/IPA 并重新签名，确认能被拦截
-使用 apksigner verify <apk-file>（Android）；codesign -dv（iOS） 校验签名完整性
```

4、总结要点

```
防篡改机制 = 签名一致性校验 + 多重安全措施
核心实现：PackageManager/App Attest 获取当前签名 → 哈希比对预存签名（API 28+ 用 signingInfo/Android）
最佳实践：应用启动时/敏感操作前校验，结合加固和服务端验证
高安全场景（银行/支付）：需严格防篡改，满足合规要求
```

### 3.3 综合实践

面试考点

```
目标：通过编译时、运行时、通信层的多层次安全措施，提升应用安全性
关键点：APK/IPA 签名、加固、运行时完整性校验、通信加密
面试亮点：强调分层防御、服务器端验证，以及安全与性能的平衡
```

1、如何综合运用上述技术提升应用安全性？

```
1、定义：
综合利用签名校验、加固、防篡改、环境检测和通信安全机制，形成完整的应用安全方案

2、重要性：
-防止逆向、二次打包和篡改
-保障用户数据与后端服务安全
-满足银行、支付类场景的合规（PCI-DSS 等）
-平衡安全与性能，兼顾用户体验
```

2、如何设计一个完整的应用安全方案？

```
一、编译与发布阶段

1.1、APK/IPA 签名：
-使用 apksigner 完成 v2/v3 签名（Android）；codesign（iOS）
-v2：全文件签名，速度快、安全性高（Android 7.0+）
-v3：支持密钥轮换，适合长期维护

1.2、加固：
-R8/ProGuard：代码混淆、资源加密（Android）
-iXGuard：Swift混淆（iOS）
-注意反射/JNI 场景测试，避免运行时错误（Android）；Objective-C桥接（iOS）

二、客户端运行时

2.1、签名校验：
-使用 PackageManager 获取当前签名，计算哈希并与预期值对比（Android）
-App Attest（iOS）
-API 28+ 使用 GET_SIGNING_CERTIFICATES 支持多签名/密钥轮换（Android）

2.2、环境检测：
-Play Integrity API（Android）：检测 Root、Bootloader 解锁、模拟器等
-App Attest（iOS）：验证应用完整性

2.3、反调试防护：
-检测调试器、Hook/Xposed/Frida 框架或 Root/越狱 状态，异常时进入安全模式或退出

三、客户端与服务器交互

3.1、通信安全：
-强制使用 HTTPS/TLS
-配置 证书锁定（Certificate Pinning），抵御中间人攻击

3.2、后端验证：
-服务器端验证 Play Integrity/App Attest 返回的 JWS/attestation
```

3、最佳实践

```
1、多层防御：
-编译时：v2/v3/codesign 签名 + 加固
-运行时：签名校验 + Play Integrity/App Attest
-通信层：HTTPS + 证书锁定

2、测试验证：
-篡改 APK/IPA、Root/越狱/模拟器环境测试
-使用 apksigner verify 检查签名完整性（Android）；codesign（iOS）

3、性能与体验：
-签名校验可异步执行，避免影响启动速度
-控制加固强度，避免 APK/IPA 过大或运行缓慢

4、高安全场景：
银行/支付类应用需结合 DexGuard/iXGuard + Play Integrity/App Attest + 证书锁定，确保满足合规要求
```

4、总结要点

```
综合安全方案：
签名(Apksigner v2/v3/codesign)+ 加固(DexGuard/iXGuard)
+ 运行时校验(PackageManager/App Attest、Play Integrity)+ 通信安全(HTTPS、证书锁定)

分层防御：编译时保护代码，运行时验证环境，通信层保证传输安全
面试亮点：强调服务器端验证、场景化应用（支付/银行）、以及安全与性能的平衡
```

