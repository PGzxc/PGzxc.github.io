---
title: 移动安全面试题之——身份验证与授权(4)
categories:
  - 面试相关
  - 移动安全面试题
tags:
  - 移动安全面试题
abbrlink: e1f42c9
date: 2025-09-28 09:12:00
---
## 一 概述

```
本文题目来自于：
 - 面试招聘要求
 - 网友分享
```

<!--more-->

## 二  面试要求和面试题

```
1.生物识别：
BiometricPrompt(指纹、面部识别) + Keystore（Android）；
LocalAuthentication + Secure Enclave（iOS）
2.OAuth 2.0/OpenID Connect：第三方登录(如 Google Sign-In/Android；Sign in with Apple/iOS)
3.Token 管理：JWT、刷新令牌 → 存储在 EncryptedSharedPreferences（Android）；Keychain（iOS）
```

### 三 面试题解答(仅供参考)

### 3.1 生物识别(Biometrics)

面试考点

```
1、BiometricPrompt（Android）/LocalAuthentication（iOS）：
统一生物识别 API(指纹、面部)，提供标准化UI和跨设备一致性

2、Android Keystore/iOS Secure Enclave：
安全密钥容器，可绑定硬件安全模块(HSM)，确保密钥即使在 root/越狱 设备上也难以提取

3、组合使用：
BiometricPrompt/LocalAuthentication做用户认证→认证成功后使用Keystore/Secure Enclave密钥进行敏感数据加解密 → 形成“生物识别 + 数据安全”闭环
```

1、如何在 Android/iOS 应用中实现生物识别认证(如指纹或面部识别)？

```
1、BiometricPrompt 的作用（Android）：
提供统一接口处理指纹、面部等生物识别，
支持 BIOMETRIC_STRONG 和 BIOMETRIC_WEAK 认证器，确保跨设备一致的用户体验

LocalAuthentication的作用（iOS）：
类似，提供Face ID/Touch ID统一接口

2、步骤（Android）：
1、检查支持：BiometricManager.canAuthenticate()确认设备支持 BIOMETRIC_STRONG/BIOMETRIC_WEAK
2、配置 PromptInfo：设置标题、说明、认证器类型、备选方案（PIN/Pattern）
3、实例化 BiometricPrompt：传入Executor和 AuthenticationCallback 处理成功/失败/错误(如 ERROR_LOCKOUT)
4、启动认证：biometricPrompt.authenticate(promptInfo, cryptoObject)结合 Keystore 时传入 CryptoObject
5、认证成功后操作：使用 Keystore 中密钥加解密敏感数据（API 密钥、用户凭证）

步骤（iOS）：
1、检查支持：LAContext.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics)
2、启动认证：context.evaluatePolicy，处理成功/失败
3、认证成功：使用Secure Enclave密钥操作

3、优势：
-API 兼容性好，安全性高
-AndroidX Biometric 推荐用于多设备兼容；iOS内置支持
```

2、BiometricPrompt/LocalAuthentication 如何与 Android Keystore/iOS Secure Enclave 结合保护敏感数据？

```
一、流程（Android）：
1、生成密钥：KeyGenParameterSpec.Builder.setUserAuthenticationRequired(true)可生成 AES(对称)或 RSA(非对称)密钥
2、封装 CryptoObject：用密钥初始化 Cipher/Signature，封装为 BiometricPrompt.CryptoObject
3、认证与操作：authenticate(CryptoObject)，成功后系统返回可用 Cipher 用于加解密
4、安全性
-密钥永不离开 Keystore
-生物识别认证作为访问控制，保证数据安全
-即使设备被 root，密钥仍受保护

二、流程（iOS）：
1、生成密钥：SecKeyGeneratePair with kSecAttrTokenIDSecureEnclave
2、认证：LAContext.evaluatePolicy
3、成功后使用Secure Enclave密钥进行操作

三、注意事项：
-生物识别重置可能导致密钥失效 → 提供 PIN/Pattern fallback
-处理认证失败（如 ERROR_LOCKOUT）和异常场景
```

3、生物识别认证的潜在风险与最佳实践

```
1、风险：
-假阳性：BIOMETRIC_WEAK 可能被绕过（Android）；Face ID仿冒（iOS）
-设备兼容性：旧设备不支持 BIOMETRIC_STRONG/Secure Enclave
-Root/越狱 设备可能绕过 Keystore/Secure Enclave
-生物识别重置导致密钥失效

2、最佳实践：
-使用 BIOMETRIC_STRONG/Secure Enclave
-提供 PIN/Pattern fallback
-密钥绑定 Keystore/Secure Enclave，认证成功后立即解密敏感数据
-多设备测试，保证兼容性
-处理错误状态和锁定状态（ERROR_LOCKOUT）
```

4、工作流程总结

```
1、工作流程
-初始化：配置 BiometricPrompt.PromptInfo（Android）；LAContext（iOS）
-实例化：创建 BiometricPrompt + Callback（Android）；evaluatePolicy（iOS）
-封装密钥：Keystore/Secure Enclave 中生成密钥 → Cipher/Signature → CryptoObject
-启动认证：authenticate(promptInfo, cryptoObject)
-认证成功：获得 Cipher，用于本地数据加解密

2、优势：
-即使攻击者拿到加密数据，没有生物识别认证也无法解密
-适合银行、支付等高安全场景
```

5、面试重点

```
-能描述 BiometricPrompt/LocalAuthentication 的流程 和 Keystore/Secure Enclave 密钥绑定
-理解 密钥永不离开 Keystore/Secure Enclave 的安全意义
-能列举 风险与对策（假阳性、root/越狱、重置失效）
-了解 AndroidX Biometric、setUserAuthenticationRequired、BIOMETRIC_STRONG 等关键 API；
iOS LAContext、kSecAttrTokenIDSecureEnclave
```

6、一句话总结

```
BiometricPrompt/LocalAuthentication + Keystore/Secure Enclave 
实现“生物识别解锁密钥 → 用密钥加解密数据”的闭环，
确保敏感数据即使在被攻击或设备被 root/越狱 的情况下仍安全；

适合银行、支付等高安全场景，开发时需兼顾兼容性、错误处理和密钥管理
```

### 3.2 OAuth 2.0 与 OpenID Connect

面试考点

```
1、OAuth 2.0：授权框架，允许第三方访问资源而不暴露凭据
2、OpenID Connect（OIDC）：OAuth 扩展，提供身份认证
3、Android/iOS 实现：Google Sign-In（Android）；Sign in with Apple（iOS）
4、安全实践：PKCE、state 参数防 CSRF、Token 安全存储
```

1、OAuth 2.0 与 OpenID Connect 的区别？

```
OAuth 2.0：授权（访问资源）
OpenID Connect：身份认证（用户身份验证）+ 授权
OIDC 基于 OAuth，提供 ID Token 包含用户信息
```

2、Android/iOS 如何实现第三方登录？

```
1、流程（Authorization Code Flow）：
-客户端注册（Google Developer Console/Android；Apple Developer/iOS）
-发起授权请求：打开浏览器/系统登录页
-用户授权后，返回授权码
-交换 Token：用授权码获取 Access/ID Token
-验证 Token：检查签名、过期时间
-存储 Token：EncryptedSharedPreferences/Keychain

2、Google Sign-In（Android）/Sign in with Apple（iOS）：
-集成 GoogleApiClient/ASAuthorizationController
-请求 scopes（如 email、profile）
-处理回调，获取用户身份
-使用 Access Token 调用 Google/Apple API（如获取用户照片）

2、优势：
结合 OAuth 2.0 的授权 + OIDC 的身份认证，安全、可靠，满足登录与 API 访问需求
iOS强制Sign in with Apple合规
```

3、第三方登录中 OAuth Token 的安全性与常见攻击

```
1、安全实践：
-使用 PKCE（Proof Key for Code Exchange）防止授权码拦截
-Token 存储在安全位置（如 EncryptedSharedPreferences/Android；Keychain/iOS）
-使用短寿命 Token + HTTPS 传输
-请求中添加 state 参数防御 CSRF 攻击
-调用 revokeAccess() 在登出时撤销 Token

2、常见攻击：
-CSRF：伪造请求窃取授权码 → 使用 state 防御
-Token 窃取：不安全网络拦截 → HTTPS + 短寿命 Token

3、最佳实践：
-最小化权限请求，优化用户体验
-处理错误场景（网络失败、Token 过期）
```

4、面试重点

```
掌握 Authorization Code Flow 流程及 Android/iOS 实现方式
能区分 OAuth 2.0 与 OIDC 的区别及应用场景
熟悉 PKCE、state、防止 CSRF、Token 安全存储 等安全实践
能描述 Google Sign-In/Sign in with Apple 的完整流程 与安全保障
```

### 3.3 Token 管理

面试考点

```
1.JWT（JSON Web Token）：轻量级、无状态、安全传输用户身份信息
2.Refresh Token（刷新令牌）：长期有效，辅助 Access Token 自动续期
3.安全存储：Access Token 存内存，Refresh Token 用 EncryptedSharedPreferences（Android）；Keychain（iOS）
4.相关技术：OAuth 2.0/OpenID Connect、BiometricPrompt/LocalAuthentication、生物识别、令牌撤销策略
```

1、JWT(JSON Web Token)简介及工作原理

```
一、定义：
JWT 是一种轻量级、开放标准的令牌，用于安全传输信息，

二、结构(Header.Payload.Signature)
Header：指定签名算法（如 HS256、RS256）
Payload：用户信息（ID、权限、过期时间 exp）
Signature：验证完整性与真实性

三、工作流程
-用户登录成功，服务器生成 JWT 并返回客户端
-客户端在 API 请求的 Authorization: Bearer <JWT> 中携带 JWT
-服务器验证签名并解析 Payload，无需查询数据库即可获取用户信息

四、优缺点
-优点：无状态、可自包含、扩展性强、签名防篡改
-缺点：体积较大，无法直接废弃（需短有效期或黑名单机制）

五、Android/iOS 实现要点
-使用库解析 JWT（如 com.auth0:java-jwt/Android；JWTDecode/iOS），检查有效期 exp
-使用公钥/密钥验证签名
-过期时通过 Refresh Token 获取新 JWT
```

2、刷新令牌(Refresh Token)的功能与实现

```
一、作用
-安全性：Access Token 短期有效，泄露风险低
-用户体验：Refresh Token 长期有效，支持无感续期

二、实现流程
-登录后获取 Access Token 和 Refresh Token
-存储策略
 Access Token：存内存
 Refresh Token：使用 EncryptedSharedPreferences 加密存储（Android）；Keychain（iOS）

-过期检测：检查 JWT exp 或处理 API 返回 401
-刷新流程：向 /token 端点发送 Refresh Token，获取新 Access Token（可选新 Refresh Token）
-令牌旋转（可选）：每次刷新使旧 Refresh Token 失效，提升安全性

三、关键点
实现“静默刷新”，后台自动续期，提升用户体验
```

3、Android/iOS 中 Token 的安全存储

```
1、存储需求
-Token 是敏感数据，泄露可导致身份冒用
-明文存储风险高（Root/越狱 或恶意应用可读取）

2、推荐方案
-Access Token：内存存储
-Refresh Token：EncryptedSharedPreferences（基于 AES-256-GCM + Android Keystore/Android）；Keychain（iOS）
-可选增强：结合 BiometricPrompt/LocalAuthentication 进行生物识别验证

3、优势
-数据加密，即使设备被 Root/越狱，数据难以直接读取
-API 简单，集成 Jetpack Security（Android），Security.framework（iOS），无需手动加密

3、备选方案
-HTTP-only Cookies（适用于 WebView）
-最小存储原则：仅存储必要数据，定期清理

5、风险提示
-Root/越狱 设备可能破解加密
-必须结合 HTTPS 和短效 Token 降低风险
```

4、相关技术要点

```
1、OAuth 2.0 / OpenID Connect
-OAuth 2.0：授权
-OpenID Connect：身份认证（Android/iOS 常见实践：Google Sign-In/Sign in with Apple）

2、生物识别
BiometricPrompt + Keystore（Android），LocalAuthentication + Secure Enclave（iOS），保护密钥或 Token

3、令牌撤销
JWT 无法主动失效，需要黑名单或短有效期 + Refresh Token 配合
```

5、总结要点

```
-JWT：无状态、自包含，适合分布式系统，需要处理过期和撤销
-刷新令牌：短效 Access Token + 长效 Refresh Token，平衡安全与用户体验
-安全存储：优先 EncryptedSharedPreferences/Keychain，结合 Keystore/Secure Enclave / 生物识别
-最佳实践：静默刷新、令牌旋转、HTTPS 传输、最小存储原则
-Android/iOS 实战：JWT + Refresh Token + 安全存储 + 生物识别 + OAuth2/OIDC
```

