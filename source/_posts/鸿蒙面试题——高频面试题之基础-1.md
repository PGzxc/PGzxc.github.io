---
title: 鸿蒙面试题——高频面试题之基础(1)
categories:
  - 面试相关
  - Harmony面试题
tags:
  - Harmony面试题
abbrlink: 575d008b
date: 2025-09-19 11:55:31
---
## 一 概述

```
本文题目来自于：
 - 面试招聘要求
 - 网友分享
```

<!--more-->

## 二 高频常见问题(根据官网稍加补充)

### 2.1 面试要求(技术点提取)

```
1、ArkTS对比(ts/仓颉/compose)
2、openharmony应用模型：FA/Stage模型
3、arkui(ArkUI框架,如布局组件，动画等)
4、UIAbility 生命周期及回调？资源释放时机？
5、arkts装饰器
6、arkts状态管理器(v1和v2版本、$和$$、全局状态管理)
```

### 2.2 如何提问(注意关键词)

```
1.想谁提问：
-借助于AI：回答的精确度和准确度跟模型有关，可以多试几个或多试几次
-可以尝试的AI工具：chatgpt，gemini，grok，豆包等语言环境明确且对编程语言识别度高

2.关键词
-哪个开发语言：鸿蒙
-来自于哪里或去哪里查找：如(结合面试招聘要求和互联网分享)
-如何归纳：结合一下知识点
-如何总结：总结常见面试题并给出解答

3.结合之后的示例
-帮我分析一下下面鸿蒙的技能是否有重复
-结合面试招聘要求和互联网分享，结合一下知识点，总结常见面试题并给出解答
-用适合程序员的文档整理，要求回答尽量贴近官方文档，并加以整理优化
```

### 2.3 如何处理

```
1.每个知识点
-ai会给出答案，不一定准确，可以切换ai工具或模型来提问

2.如何处理
-根据现有知识，粗读一下，判断ai给出的知识准确性和精确性及回答专业性和扩展知识点
-多问几次或重试或切换ai工具或模型，结合每次回答或综合考虑后给出结果
-最终还是要参考官方文档，搜索官方文档最终确定下来
```

## 三 高频面试题及解答(仅供参考)

### 3.1 ArkTS对比(ts/仓颉/compose)

面试考点

```
核心：ArkTS 的语言定位、特性扩展、声明式 UI 模型、与 HarmonyOS 的结合度。
常考点：与 TypeScript 的兼容性、与仓颉的应用场景差异、与 Compose 的 UI 开发体验对比
```

1、ArkTS 与 TypeScript 区别

```
1、ArkTS
-定位：TS 超集，专为 HarmonyOS/OpenHarmony 应用层设计，深度整合系统 API。
-特性：
 保留 TS 语法 + 扩展状态管理(@State/@Observed/@Link)、声明式 UI(ArkUI)、
 并发模型(TaskPool/Worker)、装饰器机制(@Component/@Entry)。
-优势：优化运行时性能，支持分布式协同，TS 代码可平滑迁移。
-场景：多设备交互、分布式应用开发。

2、TypeScript
-定位：通用语言，JS 的静态类型扩展。
-特性：类型系统 + 模块化，跨平台但无系统 API/分布式支持。
-场景：Web/Node.js 应用，非系统级开发。

3、面试重点：
ArkTS 兼容 TS，但在 状态管理、装饰器、分布式能力 上有系统级增强
```

2、ArkTS 与 Cangjie(仓颉)区别

```
1、ArkTS
-定位：应用层语言，声明式开发，偏 UI 和应用逻辑。
-特性：ArkUI 支持响应式界面，学习曲线平缓，前端开发者容易上手。
-场景：分布式 UI、跨设备应用。

2、仓颉 (Cangjie)
-定位：华为自研静态强类型语言，偏系统和底层开发。
-特性：性能、安全性优先，语法类似 C++，适合高性能场景。
-场景：内核、驱动、系统中间件开发。

3、面试重点：
ArkTS → 应用层效率；仓颉 → 底层性能，二者定位互补
```

3、ArkTS 与 Android Jetpack Compose 对比

```
1、相似点
-声明式 UI，理念：UI = f(状态)。
-状态驱动更新，组件化，减少命令式代码。

2、ArkTS + ArkUI
-语言：基于 ArkTS，内建状态装饰器。
-特性：深度集成 HarmonyOS，支持分布式能力和跨端（手机/平板/车机/IoT）。
-场景：分布式生态应用。

3、Jetpack Compose
-语言：基于 Kotlin，通过 Modifier 构建 UI。
-特性：依赖 Android 平台，UI 工具丰富（Material Design），但仅限单设备。
-场景：Android 应用开发。

4、面试重点：Compose 强在 Android UI 现代化；ArkTS 独有 分布式能力和跨设备适配
```

### 3.2 openharmony应用模型：FA/Stage模型

面试考点

```
FA 与 Stage 模型的区别、适用场景
FA → Stage 迁移步骤与注意事项
Stage 在进程共享和分布式场景的优势
```

1、FA 模型与 Stage 模型的区别及适用场景

```
1、FA 模型 (Feature Ability)
-特点：基于 Ability 组件，强调页面级独立性；组件多运行在独立进程，数据共享需依赖 IPC。
-适用场景：早期应用开发，或需要较强隔离性的场景。
-局限性：进程隔离带来通信开销，数据共享复杂。

2、Stage 模型
-特点：
 引入Stage作为应用入口，采用对象导向设计；
 UIAbility/ExtensionAbility 可在进程内共享，支持全局 Context。
-适用场景：复杂应用、分布式协同、多设备互联，尤其是 HarmonyOS NEXT 纯血架构。
-优势：减少 IPC 开销，数据共享效率高，开发体验更统一。

3、总结：
FA → 简单应用 / 高隔离场景
Stage → 复杂应用 / 分布式场景 / HarmonyOS NEXT
```

2、从 FA 模型迁移到 Stage 模型

```
1、迁移步骤
-替换组件：Ability → UIAbility，并调整相关逻辑。
-更新配置：在 module.json5 中启用 "stageModel": true。
-适配交互：检查组件间交互逻辑，确保兼容。
-优化共享：利用进程内共享和全局 Context，减少 IPC。

2、注意事项
-验证迁移后的组件功能，尤其在分布式场景下。
-确认 HarmonyOS NEXT 环境下的兼容性。
```

3、面试问答：FA 模型与 Stage 模型的主要区别？

```
FA：组件独立进程，隔离性强，通信开销大。
Stage：组件共享进程，全局 Context，数据共享高效。
```

4、面试问答：何时选择 Stage 模型？

```
当应用需要高效数据共享、分布式协同，或必须适配 HarmonyOS NEXT 时。
```

5、面试问答：Stage 模型在分布式场景的优势？

```
进程内共享 + 全局 Context → 减少 IPC，提升多设备间数据交互效率
```

### 3.3 arkui(ArkUI框架,如布局组件，动画等)

面试考点

```
ArkUI 的核心特性与声明式 UI 优势
常见布局组件与使用场景
动画实现方式及与状态管理结合
与 Android/Flutter 框架的对比
```

1、ArkUI 框架的核心特性是什么？

```
1、核心特性
-声明式编程：状态驱动 UI，状态变更自动触发界面更新，无需手动操作 DOM。
-组件化 & 响应式：UI 由组件树构成，支持跨组件通信与状态共享。
-多设备自适应：支持手机、平板、车机、IoT，内置布局/控件自动适配。
-性能优化：与 ArkTS 状态管理深度结合，UI 更新高效。

2、优势对比命令式 UI
-语法简洁 → 提高开发效率
-自动响应状态 → 降低维护成本
-原生支持分布式 & 多设备 → 适配性强
```

2、常见布局组件

```
1、常见布局组件
Row / Column：水平或垂直线性布局。
Flex：弹性盒布局，适合响应式排列。
Stack：叠加布局，适合卡片、浮层。
Grid：网格布局，适合复杂表格式界面。
RelativeContainer：相对定位，适配动态布局需求。

2、面试要点
-能写出简单的 Stack / Flex 示例。
-理解如何用响应式布局做多设备适配。
```

3、动画实现

```
1、类型
-属性动画：.animateTo 改变属性值。
-转场动画：.transition 页面切换。
-手势驱动：拖动、缩放绑定动画。
-装饰器动画：@Animate 与状态绑定。

2、示例（旋转动画）

@State angle: number = 0
@Animate({ duration: 1000, curve: Easing.linear })
Rotate({ angle: $angle }) {
  Image('example.png')
}


3、关键点：状态 ($angle) 更新 → 自动触发动画重绘。
4、参数可调：时长 (duration)、曲线 (curve)、重复次数 (repeatCount)。
5、常见考点
Tab 界面切换：用 Stack 叠放 + 动画切换状态
```

4、对比 Android/Flutter

4-1、表格

|    特性    |             ArkUI             |        Android View        |        Flutter         |
| :--------: | :---------------------------: | :------------------------: | :--------------------: |
|  编程范式  |      声明式，状态驱动 UI      |   命令式，手动更新 View    | 声明式，Widget 树重绘  |
| 语法简洁性 | ArkTS 内聚逻辑+样式，高度简洁 | XML + Java/Kotlin，较繁琐  | 简洁但 Widget 嵌套较深 |
|  状态管理  |      状态与 UI 自动绑定       |   需手动管理(ViewModel)    |   需 Provider 等工具   |
| 多设备适配 |     内置支持多设备自适应      | 需额外适(ConstraintLayout) |   较好，但需额外配置   |

4-2、ArkUI 优势

```
更简洁 → 降低开发/维护成本
状态管理原生支持 → 无需额外框架
HarmonyOS 原生适配 → 多设备场景最佳
```

5、如何实现响应式布局？

```
1、如何实现
-Flex 弹性布局：用 flexGrow/flexShrink 自动适应空间。
-相对单位：使用百分比、dp 或 vw/vh 替代固定像素。
-条件渲染：根据屏幕尺寸或方向切换 Row/Column 或调整布局。
-嵌套布局：组合 Flex/Row/Column 实现复杂响应式。

2、一句话
-用弹性布局 + 相对尺寸 + 条件适配即可实现响应式
```

6、常见面试题：ArkUI 的声明式 UI 有何优势？

```
状态驱动 UI，开发者只关注状态变化，无需操作 DOM，代码更简洁，可维护性更高。
```

7、常见面试题：如何实现一个 Tab 界面切换动画？

```
使用 Stack 叠放内容 + @Animate/transition 控制切换状态，实现平滑切换。
```

8、常见面试题：ArkUI 在多设备适配中的优势？

```
内置 Flex/Grid 等响应式布局，自动适配不同屏幕和设备类型，无需额外适配逻辑
```

### 3.4 UIAbility 生命周期及回调？资源释放时机？

面试考点

```
生命周期方法（与 Android Activity 对比）
资源释放点
常见回调、启动模式、通信方式
```

1、UIAbility基本概念

```
1、定义：鸿蒙应用中的 界面窗口组件，承载并展示 UI 页面。
2、类比：类似 Android Activity。
3、特点：一个 UIAbility 可包含多个 ArkUI Page，通过路由切换。
4、作用：
 -管理界面窗口生命周期（创建、显示、隐藏、销毁）。
 -作为应用与用户交互的主要入口。
5、声明：必须在 module.json5 → abilities 节点中配置（name、srcEntry、icon、label 等）。
```

2、生命周期

```
1、生命周期
onCreate：初始化资源。
onWindowStageCreate：窗口创建，windowStage.loadContent() 加载 UI。
onForeground：进入前台，可恢复任务、播放动画。
onBackground：进入后台，保存状态、释放临时资源。
onWindowStageDestroy：窗口销毁，释放与窗口绑定的资源。
onDestroy：Ability 销毁，释放全局资源。
onNewWant：处理新的启动请求（类似 Android onNewIntent）。

2、资源释放点：
-窗口相关 → onWindowStageDestroy
-全局资源 → onDestroy
```

3、常见回调方法

```
onWindowStageCreate(windowStage)：创建窗口，加载 UI。
onWindowStageDestroy(windowStage)：窗口销毁。
onNewWant(want)：接收新的启动请求。
```

4、启动模式

```
singleton：单实例（默认）。
multiton：多实例，每次启动新建。
specified：指定实例复用。
```

5、常用方法

```
启动：this.context.startAbility(want)
关闭：this.context.terminateSelf()
新 API：startAbilityByCall() → 支持调用方与目标 Ability 长连接通信。
```

6、数据通信

```
EventHub：事件总线，on/emit/off。
AppStorage/LocalStorage：应用内状态共享。
DataShareExtensionAbility（推荐）：跨 Ability 数据共享
```

7、说明

```
UIAbility ≈ Android Activity，但更灵活：
-支持多实例启动模式。
-提供跨 Ability 数据通信能力。
-生命周期分为 窗口级 和 Ability级，资源释放点更细化
```

### 3.5 arkts装饰器

面试考点

```
常见装饰器作用
状态绑定 & UI 构建的语法糖，适用场景
```

1、状态管理类

|        装饰器         |                   功能                   |   典型场景   |
| :-------------------: | :--------------------------------------: | :----------: |
|        @State         |      定义组件内部状态，变化触发刷新      |   局部状态   |
|         @Prop         |         接收父组件传参，单向绑定         |    父传子    |
|         @Link         |               父子双向绑定               |  输入框共享  |
|   @Provide/@Consume   |         跨层级依赖注入，数据共享         |  跨组件通信  |
| @Observed/@ObjectLink | 观测对象变化(深层次属性变更也能触发刷新) | 复杂对象共享 |

2、UI 构建类

|    装饰器     |               功能                |   典型场景   |
| :-----------: | :-------------------------------: | :----------: |
|   @Builder    | 定义可复用 UI 片段，可跨组件调用  | 公共 UI 片段 |
| @LocalBuilder |       组件内部专用 UI 片段        |   内部复用   |
| @BuilderParam | 将 Builder 作为参数传递，类似插槽 | 子组件定制化 |

3、样式类

| 装饰器  |      功能      |   典型场景   |
| :-----: | :------------: | :----------: |
| @Styles | 定义可复用样式 | 公共样式管理 |
| @Extend |  扩展组件样式  | 定制样式增强 |

4、其他常见装饰器

```
@Entry：应用入口 UI 组件。
@Component：定义 UI 组件。
@Builder：动态生成布局。
```

5、总结

```
@Entry：应用入口 UI
@Component：定义 UI 组件
@Builder：动态生成布局
@State：定义状态变量，值变更触发 UI 刷新
@Observed / @ObjectLink：实现父子组件状态共享
@Provide / @Consume：跨层级组件通信
@Link：父子组件双向绑定

本质：装饰器 = 状态与 UI 绑定的语法糖，使得 ArkUI 具备声明式特性。
```

6、一句话

```
ArkTS 装饰器本质是 状态与 UI 绑定的语法糖：

-解决 状态管理（@State/@Prop/@Link/@Observed/@Provide/@Consume）。
-支持 UI 构建复用（@Builder/@LocalBuilder/@BuilderParam）。
-提供 样式复用（@Styles/@Extend）→使 ArkUI 具备类似 React/Compose 的 声明式编程特性。
```

### 3.6 arkts状态管理器(v1和v2版本、$和$$、全局状态管理)

面试考点

```
状态管理演进（v1 → v2）
$ 和 $$ 区别
全局状态管理方式
```

1、状态管理演进（v1 → v2）

1-1、说明

```
1、V1（旧版，API 9 初期）
@State：组件内部状态，更新触发刷新
@Prop：父传子，单向绑定
@Link：父子双向绑定，但对象属性更新需手动处理
@Provide/@Consume：跨层级注入，依赖结构复杂
@Observed：只能观测整体对象，不能深度追踪属性
@Watch：监听值变化，但只能拿到新值
LocalStorage / AppStorage / PersistentStorage：本地 / 全局 / 持久化存储

痛点：语义不清晰、性能不足、深度观测能力弱。

2、V2(新版，推荐，API 11+)
@Local：替代 @State，更严格，仅组件内部管理
@Param：接收外部参数，单向绑定
@Event：与 @Param 搭配，实现父子双向通信（取代 @Link）
@ObservedV2 + @Trace：支持对象属性的深度观测，粒度更细
@Monitor：监听变化前后值，便于业务逻辑处理
@Computed：计算属性，依赖更新时才重新计算
AppStorageV2：全局状态容器，支持分布式同步

优势：更现代（类似 Vue3/React），语义清晰、性能更优、可深度观测。
```

1-2、迁移对照表

|        V1        |     V2 推荐替代      |
| :--------------: | :------------------: |
|      @State      |        @Local        |
|      @Link       |   @Param + @Event    |
| @Provide/Consume |     AppStorageV2     |
|    @Observed     | @ObservedV2 + @Trace |
|      @Watch      |       @Monitor       |

2、$ vs $$

```
1、对比
$：普通读写，不触发 UI 自动刷新。
$$：绑定读写，触发 UI 自动刷新（典型用于状态变量）。

2、面试常考：什么时候用 $，什么时候用 $$？
-$ → 内部逻辑计算，不需要界面刷新。
-$$ → 需要绑定 UI，状态变化触发重绘。
```

3、如何做全局状态管理？

```
1、V1和V2版本
V1：AppStorage、PersistentStorage + @Provide/@Consume
V2：AppStorageV2（支持分布式同步），推荐统一管理全局状态

2、常见实现方式：
-全局 AppStorage 容器存放状态
-组件通过 $$ 变量绑定
-跨组件通信用 @Param + @Event，避免过度依赖全局

3、面试点：
招聘方常问 V2 迁移痛点 → 不兼容旧 API，需重构数据流。
```

