---
title: 鸿蒙面试题——高频面试题之架构(3)
categories:
  - 面试相关
  - Harmony面试题
tags:
  - Harmony面试题
abbrlink: 656b6209
date: 2025-09-19 14:57:02
---
## 一 概述

```
本文题目来自于：
 - 面试招聘要求
 - 网友分享
```

<!--more-->

## 二 高频常见问题

### 2.1 面试要求

```
1.常见架构(MVC/MVP/MVVM)
2.项目工程与架构实践(工程结构、模块划分、依赖管理、构建流程)
3.组件化设计模式(模块化、解耦、重用)
4.ability框架(UIAbility/ServiceAbility/生命周期/路由栈)
```

## 三 高频面试题及解答(仅供参考)

### 3.1 常见架构(MVC/MVP/MVVM)

面试考点

```
鸿蒙项目常用的架构模式及其优缺点
MVVM 在 ArkTS/ArkUI 中的数据绑定实现
如何根据项目需求选择架构模式
MVVM 中状态装饰器的作用
```

1、MVC、MVP 和 MVVM 的核心区别及 HarmonyOS 适用场景

```
1、MVC (Model-View-Controller)
-核心：Model 管理数据，View 展示 UI，Controller 协调交互。
-特点：单向通信，View 与 Model 耦合度高。
-优缺点：简单易用，适合小型项目；但耦合性高，难以维护复杂 UI。
-适用场景：HarmonyOS 小型、快速迭代应用。

2、MVP (Model-View-Presenter)
-核心：Presenter 作为中介，负责逻辑处理和更新 UI。
-特点：View 被动，Presenter 主动驱动。
-优缺点：解耦性强、易测试；但 Presenter 容易臃肿。
-适用场景：中等复杂度项目，需要高可测试性。

3、MVVM (Model-View-ViewModel)
-核心：ViewModel 管理状态与逻辑，通过数据绑定与 UI 自动同步。
-特点：View 与 Model 无直接交互，ArkUI 支持声明式 UI 与装饰器。
-优缺点：自动化 UI 更新，代码简洁，维护性强；学习曲线略陡，复杂项目中 ViewModel 可能膨胀。
-适用场景：推荐在 HarmonyOS 使用，特别适合复杂 UI、分布式协同场景。

4、区别总结：
-MVC：单向通信，耦合高。
-MVP：引入 Presenter 解耦，但需手动更新。
-MVVM：双向绑定，自动化更新，最契合 HarmonyOS ArkUI。
```

2、HarmonyOS 中 MVVM 架构实现及优势

```
1、实现方式：
-View：ArkUI 声明式 UI 构建界面。
-ViewModel：通过 @State、@Link、@Observed 等装饰器管理状态。
-Model：处理数据逻辑，如分布式数据存储。

2、示例：

@Component
struct CounterView {
  @State count: number = 0
  @Observed model: CounterModel = new CounterModel()

  build() {
    Column() {
      Text(`Count: ${this.count}`)
      Button('Increment').onClick(() => {
        this.count++
        this.model.increment()
      })
    }
  }
}
class CounterModel { increment() { /* 业务逻辑 */ } }


3、优势：
-UI 自动更新：@State 触发界面重绘。
-分层清晰：View / ViewModel / Model 各司其职。
-适配分布式：支持跨设备数据同步。
-高效开发：声明式 UI + 状态管理减少模板代码。
```

3、MVC/MVP/MVVM 的演进逻辑及选择依据

```
1、演进逻辑：
MVC → MVP → MVVM，逐步提升解耦与自动化程度。

2、选择依据：
-MVC：简单小项目。
-MVP：中型项目，追求可测试性。
-MVVM：大型或复杂项目，HarmonyOS 官方推荐。

3、招聘趋势：
大厂更青睐 MVVM，因其最契合 ArkUI 与分布式开发
```

4、MVVM 与 MVC 对比

```
1、对比
-MVC：View 直接访问 Model，需手动更新 UI。
-MVVM：ViewModel 层隔离，支持双向绑定，UI 自动刷新。

2、MVVM 优势：
-自动化更新，减少模板代码。
-ViewModel 独立，单元测试更方便。
-适合复杂 UI 和分布式场景。
-提升开发效率和团队协作能力。
```

5、状态装饰器在 MVVM 中的作用

```
1、状态装饰器
@State：组件本地状态，变化自动触发 UI 更新。
@Prop：父 → 子 单向传递。
@Link：父 ↔ 子 双向绑定。
@Observed / @Track：对象属性跟踪，避免无效重绘。
@Provide / @Consume：跨层级共享状态。

2、加分点：
HarmonyOS V2 版装饰器更高效（如 @Track），可避免性能问题。
```

### 3.2 项目工程与架构实践(工程结构、模块划分、依赖管理、构建流程)

面试考点

```
HarmonyOS 工程结构及模块类型
模块化设计与依赖管理实践
构建流程及常见优化策略
```

1、HarmonyOS 项目工程结构

```
1、核心配置文件
-module.json5：定义模块信息（类型、入口 Ability 等）。
-oh-package.json5：依赖管理（类似 npm）。
-build-profile.json5：构建参数与多设备适配。

2、模块类型
-Entry：应用入口，包含主 Ability，负责启动和核心导航逻辑。
-Feature：功能模块，独立编译，可按需动态加载（如支付、搜索）。
-Shared：共享库模块，提供工具类、状态管理、通用逻辑。

3、优势
模块化设计，支持代码复用、动态加载和跨设备扩展。

4、示例：
电商 App 中，Entry 负责首页导航；Feature 模块实现支付；Shared 模块提供网络工具和日志。
```

2、模块划分实践

```
1、划分原则
-按业务（订单、用户、支付）或技术分层（UI、网络、数据）。
-高内聚、低耦合，支持分布式运行。
-模块可打包为独立 HAP，支持动态加载。

2、实践示例
-UI 模块：界面渲染。
-Network 模块：API 请求。
-Data 模块：数据库或分布式存储操作。
```

3、依赖管理

```
1、方式

1.1、使用 ohpm 安装和管理依赖：
ohpm install @ohos/lodash


1.2、配置在 oh-package.json5：
{
  "dependencies": {
    "@ohos/lodash": "^1.0.0"
  }
}

2、最佳实践
-保持模块低耦合，通过接口隔离。
-锁定版本，避免依赖冲突。
-支持离线构建，保障稳定性。

3、面试加分点：
强调接口隔离 + 版本管理，体现架构意识。
```

4、构建流程

```
1、流程
-编译 ArkTS/JS 源代码。
-打包资源（图片、配置文件）。
-注入依赖（ohpm）。
-生成 HAP 包。
-签名并上传到 AppGallery Connect。

2、工具
DevEco Studio 提供可视化构建与多设备配置。
```

5、构建优化策略

```
1、常见优化
--release 模式压缩代码，减小包体积。
并行编译：多模块并发编译缩短时间。
多设备适配：在 build-profile.json5 中配置手机、手表、车机等。

2、面试经验
常考 构建性能优化 和 跨设备适配。
强调熟悉 DevEco Studio 配置和分布式构建流程。
```

### 3.3 组件化设计模式(模块化、解耦、重用)

面试考点

```
模块化：业务功能拆分与独立部署  
解耦：模块间低耦合通信（接口/事件）  
重用：跨项目、跨设备的 UI/逻辑复用  
跨层级状态共享：@Provide/@Consume  
```

1、HarmonyOS 中组件化设计的核心原则及模块化实现

```
1、核心原则
-模块化：业务按功能拆分为独立模块，降低复杂度。
-解耦：通过接口、事件总线、抽象层隔离依赖。
-重用：抽取通用组件（UI + 逻辑），支持跨模块和跨设备。

2、模块化实现
UI 层：@Component 定义声明式可重用组件（如按钮、列表项）。
工程层：module.json5 配置 entry/feature HAP，实现业务模块独立打包和部署。
示例
@Component
struct MyButton {
  @Prop text: string = 'Click';
  build() {
    Button(this.text).onClick(() => console.log('clicked'))
  }
}

使用：<MyButton text="Submit" />

3、优势：
模块清晰、可单独迭代，适配分布式场景（如同一组件复用到手机、手表）
```

2、解耦与重用的实现方式及项目应用

```
1、解耦实现
-模块通信：CommonEvent、接口协议，避免直接依赖。
-组件通信：
 单向：@Prop
 双向：@Link
 跨层级/复杂：EventHub 或全局状态管理。

2、重用实现
-UI 抽取：公共组件放入 Shared 模块（如商品卡片、ListItem）。
-业务模块：作为 feature HAP，通过 Intent 与主模块交互。

3、项目应用示例(电商 App)
-UI 组件 → Shared 模块，手机/平板通用。
-业务模块（订单/支付）→ 独立 HAP，通过事件总线交互，避免循环依赖。

4、面试经验：
强调 接口优先、事件驱动，提升扩展性与可测试性；分布式下组件可在不同设备（如手表）复用。
```

3、组件化 vs 模块化及结合方式

```
1、区别
-组件化：UI 粒度 → @Component，聚焦视图逻辑。
-模块化：工程粒度 → HAP 包，聚焦业务拆分与部署。

2、结合方式
-组件定义在模块内，通过 module.json5 导出/导入。
-示例：Shared 模块 → 提供组件，Entry/Feature 模块导入使用。

3、优势
-UI 与业务分层清晰，支持跨模块调用。
-跨设备一致性：同一 UI 组件在手机/平板/手表运行，降低重复开发成本。
```

### 3.4 ability框架(UIAbility/ServiceAbility/生命周期/路由栈)

面试考点

```
1. Ability 框架：UIAbility 与 ServiceAbility 的区别及场景  
2. 生命周期管理：关键回调与资源释放  
3. 路由栈与启动模式：页面跳转、多实例处理  
4. 分布式能力：跨设备路由与后台任务  
```

1、UIAbility 与 ServiceAbility 有何区别？

```
1、UIAbility
-定义：带界面，负责 UI 展示 + 用户交互。
-生命周期：Create → Inactive → Active → Background → Destroy
-路由：支持 router.pushUrl / replaceUrl / back
-特点：每个 UIAbility 对应一个任务栈
-场景：电商首页、订单详情页、媒体播放界面

2、ServiceAbility
-定义：无 UI，运行于后台，处理 逻辑任务
-生命周期：Create → Connect → Disconnect → Destroy
-场景：后台同步、消息推送、分布式数据共享

3、区别总结
-UIAbility → 面向前台 UI，生命周期含 WindowStage。
-ServiceAbility → 面向后台逻辑，支持长时间运行。
-配置：在 module.json5 的 abilities 数组中声明类型。
```

2、使用场景与面试话术

```
1、UIAbility
-场景：用户操作界面（如购物浏览、订单结算）。
-面试点：强调其 路由管理 + 多设备 UI 适配能力。

2、ServiceAbility
-场景：后台运行（数据同步/消息推送）。
-面试点：突出 分布式协同，如手表与手机共享任务。

3、面试加分点：
“在分布式场景下，ServiceAbility 可以承担跨设备任务调度，比如手机下单后，手表可直接收到订单提醒。”
```

3、Ability 跳转与路由

```
1、跨 Ability 启动
context.startAbility({
  bundleName: 'com.example.app',
  abilityName: 'DetailAbility',
  parameters: { id: 1 }
})

2、页面路由
-router.pushUrl() → 入栈
-router.replaceUrl() → 替换
-router.back() → 出栈

3、分布式场景：
跨设备跳转需指定 deviceId。
```

4、UIAbility 生命周期与关键回调

```
1、生命周期状态
-Create → 初始化资源
-Inactive → 短暂未激活
-Active → 前台交互
-Background → 后台运行
-Destroy → 释放资源

2、关键回调

export default class MainAbility extends UIAbility {
  onCreate(want, launchParam) { }
  onWindowStageCreate(windowStage) {
    windowStage.loadContent('pages/Index')
  }
  onForeground() { }
  onBackground() { }
  onDestroy() { }
}

3、面试要点
-onWindowStageCreate：解耦 UI 与生命周期
-onBackground：保存状态，优化资源
-onDestroy：清理，避免内存泄漏
```

5、路由栈管理与启动模式

```
1、路由栈
-每个 UIAbility 有独立任务栈
-支持 pushUrl / replaceUrl / back

2、启动模式
-standard：默认，每次新建实例，支持多实例
-singleton：单实例，复用已有，触发 onNewWant()
-specified：按 Key 管理实例

{
  "abilities": [{
    "name": "MainAbility",
    "launchType": "singleton"
  }]
}

3、面试加分点
-多任务栈优化：避免冗余实例
-分布式路由：考虑 deviceId，减少内存占用
```

